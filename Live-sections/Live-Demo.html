<!-- ═══════════════════════════════════════════════════════════════════════════
     SHOCKWAVE LIVE DEMO - COMPLETE BUNDLE
     Generated: 2025-12-26T04:05:11.826Z
     
     Architecture:
     1. CSS Styles
     2. THREE.js + Post-processing CDN
     3. Shader Globals (GLSL)
     4. Enhancement Modules:
        - industry-presets.js (color/motion presets)
        - adaptive-quality.js (FPS monitoring)
        - morph-engine.js (35+ shapes, word morphing)
        - particle-system.js (GPU renderer)
        - particle-intelligence.js (11-state machine)
        - text-collision.js (text avoidance)
        - emma-avatar.js (holographic AI)
     5. Core Engine (voice, proof bar, analytics)
     6. Main Demo Logic (UI, chat, webhooks)
     7. Auto-initialization
     
     Modules Loaded: 8
     ═══════════════════════════════════════════════════════════════════════════ -->

<style>
/* ═══════════════════════════════════════════════════════════════════════════
   LIVE-DEMO SECTION STYLES
   ═══════════════════════════════════════════════════════════════════════════ */
/* ============================================================
   LIVE-DEMO SECTION STYLES
   ShockwaveHQ - Elite AI Demo Section v2.0
   File: live-demo.css
   
   Complete rewrite with:
   - Full-field particle support
   - Industry-adaptive glows
   - Pointer parallax CSS hooks
   - Explosion/morph state styles
   - Elite Emma avatar integration
   - 3D ring depth system
   - Text collision safe zones
   - Voice-reactive backgrounds
   - Complete responsive system
   - Accessibility compliance
   - Print styles
   
   Last Updated: 2025-12-06
   ============================================================ */


/* ============================================================
   CSS CUSTOM PROPERTIES (DESIGN TOKENS)
   ============================================================ */

.live-demo,
#live-ai-demo {
  /* Core design tokens */
  --sw-bg: #111418;
  --sw-bg-2: #0b0e12;
  --sw-bg-3: #050816;
  --sw-text: #e5e7eb;
  --sw-text-bright: #f9fafb;
  --sw-muted: #9aa3b2;
  --sw-muted-2: #6b7280;
  --sw-border: #1e2430;
  --sw-border-light: rgba(148, 163, 184, 0.35);
  --sw-card: #131820;
  --sw-card-hover: #1a2332;
  
  /* Brand colors */
  --sw-accent: #D12E1F;
  --sw-accent-hover: #B22222;
  --sw-accent-2: #F03E3E;
  --sw-accent-light: rgba(209, 46, 31, 0.15);
  --sw-purple: #7C3AED;
  --sw-purple-light: #a78bfa;
  --sw-purple-glow: rgba(124, 58, 237, 0.3);
  
  /* Extended brand tokens */
  --shockwave-red: #D12E1F;
  --shockwave-red-hover: #B22222;
  --shockwave-red-light: rgba(209, 46, 31, 0.12);
  --trust-blue: #00c2cb;
  --trust-blue-light: rgba(0, 194, 203, 0.15);
  --success-green: #22c55e;
  --success-green-light: rgba(34, 197, 94, 0.15);
  --warning-orange: #f97316;
  --warning-orange-light: rgba(249, 115, 22, 0.15);

  /* Parallax control (updated by JS) */
  --ld-parallax-x: 0px;
  --ld-parallax-y: 0px;
  --ld-parallax-factor: 1;

  /* Voice amplitude (updated by JS) */
  --voice-amplitude: 0;
  --voice-glow-opacity: 0.3;
  --voice-glow-color: rgba(124, 58, 237, 0.1);
  --voice-pulse-scale: 1;

  /* Industry color hooks (updated by JS) */
  --industry-primary: #7C3AED;
  --industry-secondary: #a78bfa;
  --industry-glow: rgba(124, 58, 237, 0.3);
  --industry-accent: #7C3AED;

  /* Animation timing */
  --transition-fast: 0.15s;
  --transition-normal: 0.25s;
  --transition-slow: 0.4s;
  --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);
  --ease-out-back: cubic-bezier(0.34, 1.56, 0.64, 1);
  --ease-in-out-smooth: cubic-bezier(0.25, 0.46, 0.45, 0.94);

  /* Z-index layers */
  --z-background: 0;
  --z-particles: 2;
  --z-sonic: 3;
  --z-particle-layer: 4;
  --z-emma: 5;
  --z-content: 10;
  --z-sticky: 12;
  --z-indicator: 15;
  --z-modal: 50;
  --z-voice-overlay: 60;
  --z-debug: 100000;

  /* Spacing scale */
  --space-xs: 4px;
  --space-sm: 8px;
  --space-md: 16px;
  --space-lg: 24px;
  --space-xl: 32px;
  --space-2xl: 48px;
  --space-3xl: 64px;

  /* Border radius */
  --radius-sm: 4px;
  --radius-md: 8px;
  --radius-lg: 12px;
  --radius-xl: 16px;
  --radius-2xl: 20px;
  --radius-full: 999px;

  /* Shadows */
  --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.15);
  --shadow-md: 0 8px 24px rgba(0, 0, 0, 0.25);
  --shadow-lg: 0 16px 48px rgba(0, 0, 0, 0.4);
  --shadow-xl: 0 24px 70px rgba(0, 0, 0, 0.6);
  --shadow-glow: 0 0 30px var(--industry-glow);
}


/* ============================================================
   ROOT SECTION - FULL BLEED LAYOUT
   ============================================================ */

.live-demo,
#live-ai-demo {
  /* FULL-BLEED BREAKOUT from any container */
  position: relative;
  left: 50%;
  right: 50%;
  margin-left: -50vw;
  margin-right: -50vw;
  width: 100vw;
  max-width: 100vw;
  box-sizing: border-box;

  /* Stacking context isolation */
  z-index: var(--z-background);
  isolation: isolate;

  /* Spacing */
  padding: 0;
  overflow: hidden;

  /* Typography base */
  color: var(--sw-text);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Inter", "Segoe UI", Roboto, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;

  /* Lighter base background for better contrast */
  background: #0a0d12;
}

/* Section with loaded particles */
.live-demo[data-particles-ready="true"],
#live-ai-demo[data-particles-ready="true"] {
  --particles-loaded: 1;
}

/* Section in voice mode */
.live-demo[data-demo-mode="voice"],
#live-ai-demo[data-demo-mode="voice"] {
  --voice-active: 1;
}

/* Section with Emma visible */
.live-demo[data-emma-visible="true"],
#live-ai-demo[data-emma-visible="true"] {
  --emma-visible: 1;
}

/* ============================================================
   BACKGROUND WRAPPER - PARTICLE CONTAINER
   ============================================================ */

.live-demo-bg-wrap {
  position: relative;
  width: 100%;
  min-height: 100%;
  z-index: var(--z-background);
  isolation: isolate;
}

/* Content container - sits above all background layers */
.live-demo-inner {
  position: relative;
  z-index: 5;
  max-width: 1120px;
  margin: 0 auto;
  padding: 80px 20px;
}

/* ============================================================
   FULL-BLEED BACKGROUND LAYERS (CSS FALLBACK)
   These render when WebGL is unavailable or loading
   Reduced opacity to let WebGL particles shine through
   ============================================================ */

.live-demo::before,
#live-ai-demo::before {
  content: '';
  position: absolute;
  inset: 0 calc(50% - 50vw);
  z-index: 0;
  pointer-events: none;

  background:
    /* Dimmed glassmorphic rings - very subtle strokes */
    
    /* Purple ring - top left - DIMMED */
    radial-gradient(
      circle 600px at 20% 25%,
      transparent 0%,
      transparent 48%,
      rgba(124, 58, 237, 0.06) 48.5%,
      rgba(124, 58, 237, 0.06) 51.5%,
      transparent 52%,
      transparent 100%
    ),
    
    /* Green ring - top right - DIMMED */
    radial-gradient(
      circle 520px at 80% 35%,
      transparent 0%,
      transparent 48%,
      rgba(16, 185, 129, 0.045) 48.5%,
      rgba(16, 185, 129, 0.045) 51.5%,
      transparent 52%,
      transparent 100%
    ),
    
    /* Red ring - bottom center - DIMMED */
    radial-gradient(
      circle 750px at 50% 78%,
      transparent 0%,
      transparent 48%,
      rgba(209, 46, 31, 0.07) 48.5%,
      rgba(209, 46, 31, 0.07) 51.5%,
      transparent 52%,
      transparent 100%
    ),

    /* Very subtle ambient glows - DIMMED */
    radial-gradient(
      ellipse 900px 620px at 20% 25%,
      rgba(124, 58, 237, 0.04) 0%,
      transparent 65%
    ),
    radial-gradient(
      ellipse 780px 700px at 80% 35%,
      rgba(16, 185, 129, 0.025) 0%,
      transparent 60%
    ),
    radial-gradient(
      ellipse 1000px 560px at 50% 82%,
      rgba(209, 46, 31, 0.04) 0%,
      transparent 70%
    );

  opacity: 1;
  filter: saturate(1.1) contrast(1.02); /* Reduced saturation/contrast */

  transform: translate3d(
    calc(var(--ld-parallax-x) * 0.15),
    calc(var(--ld-parallax-y) * 0.12),
    0
  );
  transition: transform var(--transition-normal) var(--ease-out-expo), 
              opacity var(--transition-slow) ease;
  will-change: transform;
}

/* When WebGL rings are active, hide CSS rings completely since 3D handles it */
.live-demo.webgl-rings-active::before,
#live-ai-demo.webgl-rings-active::before {
  background:
    /* Only very faint ambient aura, no ring strokes */
    radial-gradient(
      ellipse 900px 620px at 20% 25%,
      rgba(124, 58, 237, 0.03) 0%,
      transparent 65%
    ),
    radial-gradient(
      ellipse 780px 700px at 80% 35%,
      rgba(16, 185, 129, 0.02) 0%,
      transparent 60%
    ),
    radial-gradient(
      ellipse 1000px 560px at 50% 82%,
      rgba(209, 46, 31, 0.03) 0%,
      transparent 70%
    );
}

/* Dots layer - secondary decorative */
.live-demo::after,
#live-ai-demo::after {
  content: '';
  position: absolute;
  inset: 0 calc(50% - 50vw);
  z-index: 0;
  pointer-events: none;

  background-image:
    /* Node cluster dots */
    radial-gradient(circle 5px at 16% 22%, rgba(124, 58, 237, 0.5), transparent),
    radial-gradient(circle 4px at 10% 30%, rgba(124, 58, 237, 0.4), transparent),
    radial-gradient(circle 6px at 22% 34%, rgba(124, 58, 237, 0.45), transparent),
    radial-gradient(circle 5px at 50% 26%, rgba(16, 185, 129, 0.5), transparent),
    radial-gradient(circle 4px at 54% 34%, rgba(16, 185, 129, 0.4), transparent),
    radial-gradient(circle 6px at 78% 68%, rgba(209, 46, 31, 0.55), transparent),
    radial-gradient(circle 5px at 72% 76%, rgba(240, 62, 62, 0.5), transparent);

  background-size: 220% 220%;
  animation: live-demo-wave-drift 32s ease-in-out infinite;
  opacity: 0.7;

  /* Parallax with different factor */
  transform: translate3d(
    calc(var(--ld-parallax-x) * 0.25),
    calc(var(--ld-parallax-y) * 0.2),
    0
  );
  transition: transform var(--transition-normal) var(--ease-out-expo);
  will-change: transform;
}

/* Voice-active background boost */
.live-demo[data-demo-mode="voice"]::before,
#live-ai-demo[data-demo-mode="voice"]::before {
  filter: saturate(1.5) contrast(1.12);
}

.live-demo[data-demo-mode="voice"]::after,
#live-ai-demo[data-demo-mode="voice"]::after {
  opacity: 0.85;
  animation-duration: 20s;
}

@keyframes live-demo-wave-drift {
  0%, 100% {
    background-position: 0% 0%, 100% 100%, 50% 50%;
    opacity: 0.4;
  }
  25% {
    background-position: 50% 25%, 75% 75%, 25% 75%;
    opacity: 0.45;
  }
  50% {
    background-position: 100% 100%, 0% 0%, 0% 100%;
    opacity: 0.5;
  }
  75% {
    background-position: 75% 50%, 25% 50%, 75% 25%;
    opacity: 0.45;
  }
}

/* When WebGL rings are active:
   - keep ambient aura glows,
   - hide crisp CSS ring strokes (3D rings replace them)
*/
.live-demo.webgl-rings-active::before,
#live-ai-demo.webgl-rings-active::before {
  opacity: 1;
  z-index: 0;
  pointer-events: none;

  /* Only ambient ellipse glows, NO circle rings */
  background:
    radial-gradient(
      ellipse 900px 620px at 20% 25%,
      rgba(124, 58, 237, 0.12) 0%,
      transparent 65%
    ),
    radial-gradient(
      ellipse 780px 700px at 80% 35%,
      rgba(16, 185, 129, 0.08) 0%,
      transparent 60%
    ),
    radial-gradient(
      ellipse 1000px 560px at 50% 82%,
      rgba(209, 46, 31, 0.12) 0%,
      transparent 70%
    );

  filter: saturate(1.3) contrast(1.05);
  transform: translate3d(
    calc(var(--ld-parallax-x) * 0.15),
    calc(var(--ld-parallax-y) * 0.12),
    0
  );
  transition: transform var(--transition-normal) var(--ease-out-expo),
              opacity var(--transition-slow) ease;
  will-change: transform;
}

/* ============================================================
   THREE.JS PARTICLE CANVAS
   ============================================================ */

/* Legacy canvas (hidden when v2 active) */
.sw-particle-background {
  position: absolute !important;
  inset: 0;
  width: 100% !important;
  height: 100% !important;
  z-index: var(--z-particles) !important;
  pointer-events: none;
}

/* V2 enhanced canvas */
.sw-particle-canvas-v2 {
  position: absolute !important;
  top: 0;
  left: 0;
  width: 100% !important;
  height: 100% !important;
  z-index: var(--z-particles) !important;
  pointer-events: none;
  opacity: 0;
  transition: opacity 1.5s var(--ease-in-out-smooth);
}

/* Canvas loaded state */
.sw-particle-canvas-v2.loaded,
.live-demo-bg-wrap.v2-active .sw-particle-canvas-v2 {
  opacity: 1;
}

/* Hide legacy when v2 active */
.live-demo-bg-wrap.v2-active .sw-particle-background:not(.sw-particle-canvas-v2),
.live-demo-bg-wrap.v2-active #particle-canvas:not(.sw-particle-canvas-v2) {
  display: none !important;
}


/* ============================================================
   VOICE SONIC CANVAS (WAVEFORM BARS)
   ============================================================ */

.live-demo-sonic-canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: var(--z-sonic);
  pointer-events: none;
  opacity: 0.6;

  /* Parallax movement */
  transform: translate3d(
    calc(var(--ld-parallax-x) * 0.1),
    calc(var(--ld-parallax-y) * 0.08),
    0
  );
  transition: transform 0.2s ease, opacity 0.3s ease;
  will-change: transform, opacity;
}

/* Voice state variations */
.live-demo-bg-wrap[data-voice-state="AI_SPEAKING"] .live-demo-sonic-canvas {
  opacity: 0.85;
}

.live-demo-bg-wrap[data-voice-state="USER_SPEAKING"] .live-demo-sonic-canvas {
  opacity: 0.8;
}

.live-demo-bg-wrap[data-voice-state="SILENCE"] .live-demo-sonic-canvas {
  opacity: 0.4;
}

.live-demo-bg-wrap[data-voice-state="IDLE"] .live-demo-sonic-canvas {
  opacity: 0.3;
}

/* Particle overlay layer */
.live-demo-particle-layer {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: var(--z-particle-layer);
  pointer-events: none;
  overflow: hidden;

  transform: translate3d(
    calc(var(--ld-parallax-x) * 0.2),
    calc(var(--ld-parallax-y) * 0.15),
    0
  );
  transition: transform 0.22s ease;
  will-change: transform;
}

/* Decorative particle pulses */
.live-demo-particle-layer::before,
.live-demo-particle-layer::after {
  content: '';
  position: absolute;
  width: 4px;
  height: 4px;
  border-radius: 50%;
  background: rgba(139, 92, 246, 0.4);
  animation: live-demo-particle-drift 8s ease-in-out infinite;
}

.live-demo-particle-layer::before {
  top: 20%;
  left: 15%;
  animation-delay: 0s;
}

.live-demo-particle-layer::after {
  top: 60%;
  left: 75%;
  animation-delay: 4s;
}

@keyframes live-demo-particle-drift {
  0%, 100% { 
    transform: translate(0, 0) scale(1); 
    opacity: 0.15; 
  }
  25% {
    transform: translate(16px, -24px) scale(1.2);
    opacity: 0.5;
  }
  50% { 
    transform: translate(32px, -48px) scale(1.5); 
    opacity: 0.8; 
  }
  75% {
    transform: translate(24px, -36px) scale(1.2);
    opacity: 0.5;
  }
}

/* Voice state particle colors */
.live-demo-bg-wrap[data-voice-state="AI_SPEAKING"] .live-demo-particle-layer::before,
.live-demo-bg-wrap[data-voice-state="AI_SPEAKING"] .live-demo-particle-layer::after {
  background: rgba(139, 92, 246, 0.85);
  animation-duration: 4s;
}

.live-demo-bg-wrap[data-voice-state="USER_SPEAKING"] .live-demo-particle-layer::before,
.live-demo-bg-wrap[data-voice-state="USER_SPEAKING"] .live-demo-particle-layer::after {
  background: rgba(16, 185, 129, 0.85);
  animation-duration: 3s;
}

/* Real-time mode badge */
.live-demo-bg-wrap[data-voice-mode="realtime"]::after {
  content: 'LIVE';
  position: absolute;
  top: 16px;
  right: 16px;
  padding: 4px 8px;
  background: rgba(16, 185, 129, 0.2);
  border: 1px solid rgba(16, 185, 129, 0.5);
  border-radius: var(--radius-sm);
  color: #10B981;
  font-size: 10px;
  font-weight: 600;
  letter-spacing: 0.5px;
  text-transform: uppercase;
  z-index: var(--z-indicator);
  pointer-events: none;
  animation: live-badge-pulse 2s ease-in-out infinite;
}

@keyframes live-badge-pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}


/* ============================================================
   INDUSTRY-SPECIFIC PARTICLE GLOWS
   Applied via data-industry attribute
   ============================================================ */

/* Dental - Pink/Rose */
.live-demo[data-industry="dental"] .sw-particle-canvas-v2,
#live-ai-demo[data-industry="dental"] .sw-particle-canvas-v2 {
  filter: drop-shadow(0 0 40px rgba(255, 107, 155, 0.12));
}

.live-demo[data-industry="dental"] {
  --industry-primary: #ff6b9b;
  --industry-secondary: #ffc6e0;
  --industry-glow: rgba(255, 107, 155, 0.3);
  --industry-accent: #d946ef;
}

/* HVAC - Orange/Warm */
.live-demo[data-industry="hvac"] .sw-particle-canvas-v2,
#live-ai-demo[data-industry="hvac"] .sw-particle-canvas-v2 {
  filter: drop-shadow(0 0 40px rgba(255, 122, 60, 0.12));
}

.live-demo[data-industry="hvac"] {
  --industry-primary: #ff7a3c;
  --industry-secondary: #ffb380;
  --industry-glow: rgba(255, 122, 60, 0.3);
  --industry-accent: #f97316;
}

/* Law/Legal - Blue/Trust */
.live-demo[data-industry="law"] .sw-particle-canvas-v2,
.live-demo[data-industry="legal"] .sw-particle-canvas-v2,
#live-ai-demo[data-industry="law"] .sw-particle-canvas-v2,
#live-ai-demo[data-industry="legal"] .sw-particle-canvas-v2 {
  filter: drop-shadow(0 0 40px rgba(125, 168, 255, 0.12));
}

.live-demo[data-industry="law"],
.live-demo[data-industry="legal"] {
  --industry-primary: #7da8ff;
  --industry-secondary: #b3d1ff;
  --industry-glow: rgba(125, 168, 255, 0.3);
  --industry-accent: #3b82f6;
}

/* Plumbing - Cyan/Flow */
.live-demo[data-industry="plumbing"] .sw-particle-canvas-v2,
#live-ai-demo[data-industry="plumbing"] .sw-particle-canvas-v2 {
  filter: drop-shadow(0 0 40px rgba(0, 180, 216, 0.12));
}

.live-demo[data-industry="plumbing"] {
  --industry-primary: #00B4D8;
  --industry-secondary: #90e0ef;
  --industry-glow: rgba(0, 180, 216, 0.3);
  --industry-accent: #06b6d4;
}

/* MedSpa - Purple/Luxury */
.live-demo[data-industry="medspa"] .sw-particle-canvas-v2,
#live-ai-demo[data-industry="medspa"] .sw-particle-canvas-v2 {
  filter: drop-shadow(0 0 40px rgba(193, 102, 216, 0.12));
}

.live-demo[data-industry="medspa"] {
  --industry-primary: #C166D8;
  --industry-secondary: #f0abfc;
  --industry-glow: rgba(193, 102, 216, 0.3);
  --industry-accent: #e879f9;
}

/* Pest Control - Green/Protection */
.live-demo[data-industry="pest"] .sw-particle-canvas-v2,
#live-ai-demo[data-industry="pest"] .sw-particle-canvas-v2 {
  filter: drop-shadow(0 0 40px rgba(34, 197, 94, 0.12));
}

.live-demo[data-industry="pest"] {
  --industry-primary: #22c55e;
  --industry-secondary: #86efac;
  --industry-glow: rgba(34, 197, 94, 0.3);
  --industry-accent: #22c55e;
}


/* ============================================================
   EMMA AVATAR CONTAINER
   ============================================================ */

.sw-emma-avatar-container {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 280px;
  height: 280px;
  z-index: var(--z-emma);
  pointer-events: none;
  opacity: 0;
  transition: opacity 1s ease-out;
}

.sw-emma-avatar-container.visible {
  opacity: 1;
}

.sw-emma-avatar-container.speaking {
  animation: emma-speak-pulse 0.6s ease-in-out infinite alternate;
}

@keyframes emma-speak-pulse {
  0% {
    filter: brightness(1) drop-shadow(0 0 25px var(--industry-glow));
    transform: translate(-50%, -50%) scale(1);
  }
  100% {
    filter: brightness(1.2) drop-shadow(0 0 45px var(--industry-glow));
    transform: translate(-50%, -50%) scale(1.02);
  }
}

/* Position variants */
.sw-emma-avatar-container.position-center {
  top: 50%;
  left: 50%;
}

.sw-emma-avatar-container.position-left {
  top: 50%;
  left: 30%;
}

.sw-emma-avatar-container.position-right {
  top: 50%;
  left: 70%;
}

/* Responsive sizing */
@media (max-width: 768px) {
  .sw-emma-avatar-container {
    width: 160px;
    height: 160px;
  }
}

@media (max-width: 480px) {
  .sw-emma-avatar-container {
    width: 120px;
    height: 120px;
  }
}


/* ============================================================
   RING CLICK INDICATOR
   Visual feedback for click-to-spawn-rings
   ============================================================ */

.sw-ring-click-indicator {
  position: absolute;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: 2px solid var(--industry-primary, rgba(124, 58, 237, 0.6));
  pointer-events: none;
  opacity: 0;
  transform: scale(0);
  z-index: var(--z-indicator);
}

.sw-ring-click-indicator.active {
  animation: ring-click-ripple 0.7s ease-out forwards;
}

@keyframes ring-click-ripple {
  0% {
    opacity: 1;
    transform: scale(0);
  }
  50% {
    opacity: 0.6;
  }
  100% {
    opacity: 0;
    transform: scale(4);
  }
}


/* ============================================================
   MORPH STATE INDICATORS
   ============================================================ */

.live-demo[data-morph-active="true"],
#live-ai-demo[data-morph-active="true"] {
  --particle-transition-speed: 1.6s;
}

/* Explosion state */
.live-demo[data-explosion-active="true"],
#live-ai-demo[data-explosion-active="true"] {
  --explosion-active: 1;
}

/* Shape indicator badge */
.sw-morph-indicator {
  position: absolute;
  bottom: 24px;
  right: 24px;
  padding: 8px 14px;
  background: rgba(15, 23, 42, 0.9);
  border: 1px solid var(--industry-primary, rgba(124, 58, 237, 0.5));
  border-radius: 24px;
  font-size: 0.8rem;
  font-weight: 500;
  color: #e5e7eb;
  opacity: 0;
  transform: translateY(12px);
  transition: opacity 0.35s ease, transform 0.35s ease;
  z-index: var(--z-indicator);
  pointer-events: none;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
}

.sw-morph-indicator.visible {
  opacity: 1;
  transform: translateY(0);
}

.sw-morph-indicator .shape-icon {
  margin-right: 8px;
  font-size: 1rem;
}


/* ============================================================
   SYSTEM STATUS BAR
   ============================================================ */

.live-demo-system-status {
  display: inline-flex;
  align-items: center;
  gap: 10px;
  padding: 10px 16px;
  margin: 0 auto 24px;
  background: linear-gradient(135deg,
    rgba(9, 11, 17, 0.85) 0%,
    rgba(9, 11, 17, 0.95) 100%);
  border-radius: var(--radius-full);
  border: 1px solid var(--sw-border-light);
  backdrop-filter: blur(20px) saturate(170%);
  -webkit-backdrop-filter: blur(20px) saturate(170%);
  box-shadow:
    0 16px 45px rgba(0, 0, 0, 0.6),
    0 0 0 1px rgba(255, 255, 255, 0.04) inset;
  font-size: 0.8rem;
  color: var(--sw-muted);
  position: relative;
  z-index: var(--z-content);
}

.live-demo-system-left {
  display: inline-flex;
  align-items: center;
  gap: 6px;
}

.live-demo-status-dot {
  width: 8px;
  height: 8px;
  border-radius: var(--radius-full);
  background: var(--success-green);
  box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7);
  animation: live-demo-status-pulse 2.2s ease-out infinite;
}

.live-demo-status-text {
  font-weight: 600;
  color: #bbf7d0;
}

.live-demo-status-divider {
  color: rgba(148, 163, 184, 0.35);
}

.live-demo-status-metric {
  display: inline-flex;
  align-items: baseline;
  gap: 4px;
}

.live-demo-status-metric strong {
  font-weight: 700;
  color: #e0e7ff;
}

.live-demo-status-label {
  font-weight: 500;
  color: var(--sw-muted);
}

@keyframes live-demo-status-pulse {
  0% {
    transform: scale(1);
    box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7);
  }
  70% {
    transform: scale(1.5);
    box-shadow: 0 0 0 8px rgba(16, 185, 129, 0);
  }
  100% {
    transform: scale(1);
    box-shadow: 0 0 0 0 rgba(16, 185, 129, 0);
  }
}


/* ============================================================
   HEADER
   ============================================================ */

.live-demo-header {
  text-align: center;
  max-width: 880px;
  margin: 0 auto 40px;
  position: relative;
  z-index: var(--z-content);
}

.eyebrow {
  font-size: 0.82rem;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--sw-accent-2);
  font-weight: 600;
  margin-bottom: 4px;
}

.live-demo-title {
  font-size: clamp(2.1rem, 4vw, 2.9rem);
  font-weight: 800;
  color: #ffffff;
  letter-spacing: -0.035em;
  margin-bottom: 12px;
  text-shadow: 0 2px 20px rgba(0, 0, 0, 0.5);
  line-height: 1.15;
}

.live-demo-subtitle {
  font-size: clamp(0.98rem, 2vw, 1.1rem);
  color: var(--sw-muted);
  line-height: 1.7;
  margin-bottom: 4px;
}

.live-demo-subsubtitle {
  font-size: 0.9rem;
  color: rgba(156, 163, 175, 0.9);
  margin-bottom: 18px;
}

/* Trust strip */
.live-demo-trust-strip {
  display: inline-flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 10px;
  padding: 8px 16px;
  border-radius: var(--radius-full);
  background: rgba(15, 23, 42, 0.7);
  border: 1px solid var(--sw-border-light);
  font-size: 0.8rem;
  color: var(--sw-muted);
}

.live-demo-trust-strip span {
  white-space: nowrap;
}

/* Why now */
.sw-demo-why-now {
  margin-top: 10px;
  font-size: 0.85rem;
  color: #e5e7eb;
  opacity: 0.9;
}

/* ROI chip */
.live-demo-roi-chip {
  margin-top: 8px;
  font-size: 0.82rem;
  color: #e5e7eb;
  opacity: 0.9;
}

.live-demo-roi-chip strong {
  color: var(--warning-orange);
}

/* Interaction hint */
.sw-demo-interaction-hint {
  margin-top: 16px;
  padding: 8px 16px;
  background: rgba(124, 58, 237, 0.1);
  border: 1px solid rgba(124, 58, 237, 0.3);
  border-radius: var(--radius-md);
  font-size: 0.78rem;
  color: rgba(167, 139, 250, 0.9);
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.sw-demo-interaction-hint .hint-icon {
  font-size: 1rem;
}

.sw-demo-interaction-hint .hint-text {
  opacity: 0.9;
}


/* ============================================================
   PROOF BAR (CORE-POWERED)
   ============================================================ */

.sw-live-demo-proof-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 32px 24px;
  margin-top: 20px;
  background: rgba(0, 0, 0, 0.45);
  border-radius: var(--radius-xl);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border: 1px solid rgba(255, 255, 255, 0.08);
  gap: 4px;
  position: relative;
  z-index: var(--z-content);
}

.sw-live-proof-top {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
}

.sw-live-proof-label {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: rgba(255, 255, 255, 0.5);
  font-weight: 500;
}

.sw-live-proof-top-value {
  font-size: 18px;
  font-weight: 600;
  color: rgba(255, 255, 255, 0.9);
  font-variant-numeric: tabular-nums;
}

.sw-live-proof-context {
  font-size: 13px;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  color: rgba(0, 255, 136, 0.85);
  margin-top: 10px;
  font-weight: 600;
}

.sw-live-proof-bar {
  font-size: 56px;
  font-weight: 700;
  color: #00ff88;
  text-shadow: 0 0 30px rgba(0, 255, 136, 0.35);
  line-height: 1;
  margin: 8px 0 12px 0;
  letter-spacing: -0.02em;
  font-variant-numeric: tabular-nums;
}

.sw-live-proof-footnote {
  font-size: 12px;
  color: rgba(255, 255, 255, 0.65);
  text-align: center;
  line-height: 1.5;
  max-width: 420px;
  margin-bottom: 20px;
}

.sw-live-proof-footnote span[data-live-demo-client-count] {
  font-weight: 600;
  color: rgba(255, 255, 255, 0.9);
}

.sw-live-proof-footnote .bullet {
  margin: 0 6px;
  opacity: 0.4;
}

.sw-live-proof-secondary {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding-top: 16px;
  border-top: 1px solid rgba(255, 255, 255, 0.1);
  width: 100%;
  gap: 4px;
}

.secondary-value {
  font-size: 28px;
  font-weight: 700;
  color: rgba(255, 255, 255, 0.98);
  line-height: 1;
  font-variant-numeric: tabular-nums;
}

.secondary-label {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: rgba(255, 255, 255, 0.55);
  font-weight: 500;
}


/* ============================================================
   BODY LAYOUT
   ============================================================ */

.sw-demo-body {
  display: flex;
  flex-direction: column;
  gap: 24px;
  margin-top: 26px;
  position: relative;
  z-index: var(--z-content);
}

/* Mini Steps */
.sw-demo-mini-steps {
  max-width: 720px;
  margin: 0 auto 6px;
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  font-size: 0.8rem;
  color: #9ca3af;
  justify-content: center;
}

.sw-demo-mini-step {
  padding: 4px 8px;
  border-radius: var(--radius-full);
  border: 1px solid rgba(148, 163, 184, 0.5);
  background: rgba(15, 23, 42, 0.4);
  transition: all var(--transition-fast) ease;
}

.sw-demo-mini-step--active {
  border-color: var(--sw-accent);
  background: var(--shockwave-red-light);
  color: #fed7d7;
  font-weight: 600;
}

.sw-demo-mini-step--done {
  border-color: var(--success-green);
  background: var(--success-green-light);
  color: #bbf7d0;
}


/* ============================================================
   EMMA CHAT WIDGET
   ============================================================ */

.sw-demo-chat {
  max-width: 720px;
  margin: 0 auto;
  background: rgba(249, 250, 251, 0.98);
  border-radius: var(--radius-2xl);
  padding: 20px 18px 18px;
  box-shadow:
    0 20px 60px rgba(15, 23, 42, 0.75),
    0 0 0 1px var(--sw-border-light);
  color: #111827;
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  transition: transform var(--transition-normal) ease, 
              box-shadow var(--transition-normal) ease;
  position: relative;
  z-index: var(--z-content);
}

.sw-demo-chat:hover {
  transform: translateY(-3px);
  box-shadow:
    0 26px 80px rgba(15, 23, 42, 0.85),
    0 0 0 1px rgba(30, 64, 175, 0.5);
}

/* Industry chat card glows */
.live-demo[data-industry="dental"] .sw-demo-chat,
#live-ai-demo[data-industry="dental"] .sw-demo-chat {
  box-shadow:
    0 20px 60px rgba(15, 23, 42, 0.85),
    0 0 0 1px rgba(255, 107, 155, 0.4);
}

.live-demo[data-industry="hvac"] .sw-demo-chat,
#live-ai-demo[data-industry="hvac"] .sw-demo-chat {
  box-shadow:
    0 20px 60px rgba(15, 23, 42, 0.85),
    0 0 0 1px rgba(255, 122, 60, 0.4);
}

.live-demo[data-industry="law"] .sw-demo-chat,
.live-demo[data-industry="legal"] .sw-demo-chat,
#live-ai-demo[data-industry="law"] .sw-demo-chat,
#live-ai-demo[data-industry="legal"] .sw-demo-chat {
  box-shadow:
    0 20px 60px rgba(15, 23, 42, 0.85),
    0 0 0 1px rgba(125, 168, 255, 0.4);
}

.live-demo[data-industry="plumbing"] .sw-demo-chat,
#live-ai-demo[data-industry="plumbing"] .sw-demo-chat {
  box-shadow:
    0 20px 60px rgba(15, 23, 42, 0.85),
    0 0 0 1px rgba(45, 212, 191, 0.4);
}

.live-demo[data-industry="medspa"] .sw-demo-chat,
#live-ai-demo[data-industry="medspa"] .sw-demo-chat {
  box-shadow:
    0 20px 60px rgba(15, 23, 42, 0.85),
    0 0 0 1px rgba(244, 114, 182, 0.4);
}

.live-demo[data-industry="pest"] .sw-demo-chat,
#live-ai-demo[data-industry="pest"] .sw-demo-chat {
  box-shadow:
    0 20px 60px rgba(15, 23, 42, 0.85),
    0 0 0 1px rgba(190, 242, 100, 0.4);
}

/* Chat header */
.sw-demo-chat-header {
  display: flex;
  align-items: center;
  gap: 12px;
  padding-bottom: 10px;
  border-bottom: 1px solid #e5e7eb;
  margin-bottom: 14px;
}

/* Chat avatar container (replaces the old emoji circle) */
.sw-demo-chat-avatar {
  position: relative;
  width: 44px;
  height: 44px;
  flex-shrink: 0;
}

/* Outer orbit ring */
.sw-chat-avatar-orbit {
  position: absolute;
  inset: 0;
  border-radius: var(--radius-full);
  background:
    radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.25), transparent 55%),
    conic-gradient(
      from 180deg,
      rgba(255, 255, 255, 0.12),
      rgba(255, 255, 255, 0.0),
      rgba(255, 255, 255, 0.16),
      rgba(255, 255, 255, 0.0),
      rgba(255, 255, 255, 0.12)
    );
  border: 1px solid rgba(255, 255, 255, 0.22);
  box-shadow:
    0 0 0 1px rgba(15, 23, 42, 0.85) inset,
    0 0 0 1px rgba(255, 255, 255, 0.08),
    0 0 18px var(--industry-glow, rgba(124, 58, 237, 0.3));
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  transform: translateZ(0);
}

/* Inner Emma core */
.sw-chat-avatar-core {
  position: relative;
  width: 28px;
  height: 28px;
  border-radius: var(--radius-full);
  background:
    radial-gradient(circle at 25% 20%, rgba(255, 255, 255, 0.85), rgba(255, 255, 255, 0.1) 40%, transparent 65%),
    linear-gradient(135deg, var(--shockwave-red), var(--industry-primary, #7C3AED));
  box-shadow:
    0 0 0 1px rgba(255, 255, 255, 0.35),
    0 4px 10px rgba(15, 23, 42, 0.6);
  display: flex;
  align-items: center;
  justify-content: center;
}

/* SVG glyph inside Emma core */
.sw-chat-avatar-glyph {
  position: relative;
  z-index: 2;
  width: 16px;
  height: 16px;
  color: #0b1020; /* dark ink against the bright core */
  filter: drop-shadow(0 1px 0 rgba(255,255,255,0.25));
}

.sw-chat-avatar-glyph path {
  fill: currentColor;
}

/* Inner glow blob */
.sw-chat-avatar-glow {
  position: absolute;
  inset: 2px;
  border-radius: inherit;
  background:
    radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.6), transparent 55%),
    radial-gradient(circle at 70% 80%, rgba(251, 113, 133, 0.55), transparent 60%);
  mix-blend-mode: screen;
  opacity: 0.85;
  pointer-events: none;
}

/* Online dot */
.sw-chat-avatar-status-dot {
  position: absolute;
  bottom: -1px;
  right: -1px;
  width: 11px;
  height: 11px;
  border-radius: var(--radius-full);
  background: #22c55e;
  box-shadow:
    0 0 0 1px #f9fafb,
    0 0 0 4px rgba(34, 197, 94, 0.3);
}

/* Idle animation */
.sw-demo-chat-avatar[data-avatar-state="idle"] .sw-chat-avatar-orbit {
  animation: sw-chat-orbit-spin 16s linear infinite;
}

/* Speaking */
.sw-demo-chat-avatar[data-avatar-state="speaking"] .sw-chat-avatar-orbit {
  animation: sw-chat-orbit-spin 6s linear infinite;
  box-shadow:
    0 0 0 1px rgba(15, 23, 42, 0.85) inset,
    0 0 0 1px rgba(255, 255, 255, 0.12),
    0 0 24px var(--industry-glow, rgba(124, 58, 237, 0.45));
}

.sw-demo-chat-avatar[data-avatar-state="speaking"] .sw-chat-avatar-core {
  animation: sw-chat-avatar-pulse 0.9s ease-in-out infinite;
}

/* Listening */
.sw-demo-chat-avatar[data-avatar-state="listening"] .sw-chat-avatar-core {
  animation: sw-chat-avatar-breathe 1.8s ease-in-out infinite;
}

/* Voice mode active: tie the halo to "live" */
#live-ai-demo[data-voice-active="true"] .sw-demo-chat-avatar .sw-chat-avatar-orbit {
  box-shadow:
    0 0 0 1px rgba(15, 23, 42, 0.85) inset,
    0 0 0 1px rgba(34, 197, 94, 0.4),
    0 0 30px rgba(34, 197, 94, 0.6);
}

/* Animations */
@keyframes sw-chat-orbit-spin {
  0% { transform: rotate(0deg) translateZ(0); }
  100% { transform: rotate(360deg) translateZ(0); }
}

@keyframes sw-chat-avatar-pulse {
  0%   { transform: scale(1);   box-shadow: 0 4px 10px rgba(15, 23, 42, 0.6); }
  50%  { transform: scale(1.06); box-shadow: 0 10px 22px rgba(15, 23, 42, 0.9); }
  100% { transform: scale(1);   box-shadow: 0 4px 10px rgba(15, 23, 42, 0.6); }
}

@keyframes sw-chat-avatar-breathe {
  0%   { transform: scale(1); }
  50%  { transform: scale(1.03); }
  100% { transform: scale(1); }
}

/* Reduced motion safety */
@media (prefers-reduced-motion: reduce) {
  .sw-demo-chat-avatar * {
    animation: none !important;
  }
}

.sw-demo-chat-meta {
  display: flex;
  flex-direction: column;
  gap: 2px;
  min-width: 0;
}

.sw-demo-chat-name {
  font-weight: 600;
  font-size: 0.95rem;
  color: #111827;
}

.sw-demo-chat-status {
  font-size: 0.8rem;
  color: #6b7280;
}

/* Chat messages */
.sw-demo-chat-messages {
  max-height: 320px;
  overflow-y: auto;
  padding-right: 4px;
  margin-bottom: 10px;
  scroll-behavior: smooth;
}

/* Custom scrollbar */
.sw-demo-chat-messages::-webkit-scrollbar {
  width: 6px;
}

.sw-demo-chat-messages::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.05);
  border-radius: 3px;
}

.sw-demo-chat-messages::-webkit-scrollbar-thumb {
  background: rgba(0, 0, 0, 0.15);
  border-radius: 3px;
}

.sw-demo-chat-messages::-webkit-scrollbar-thumb:hover {
  background: rgba(0, 0, 0, 0.25);
}

.sw-demo-chat-message {
  display: flex;
  margin-bottom: 8px;
  animation: message-appear 0.3s ease-out;
}

@keyframes message-appear {
  from {
    opacity: 0;
    transform: translateY(8px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.sw-demo-chat-message--assistant {
  justify-content: flex-start;
}

.sw-demo-chat-message--user {
  justify-content: flex-end;
}

.sw-demo-chat-bubble {
  max-width: 92%;
  padding: 10px 12px;
  border-radius: var(--radius-lg);
  font-size: 0.9rem;
  line-height: 1.5;
}

.sw-demo-chat-message--assistant .sw-demo-chat-bubble {
  background: #eff6ff;
  color: #111827;
  border-top-left-radius: var(--radius-sm);
}

.sw-demo-chat-message--user .sw-demo-chat-bubble {
  background: #111827;
  color: #f9fafb;
  border-bottom-right-radius: var(--radius-sm);
}

/* Typing indicator */
.sw-demo-chat-typing {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 10px 12px;
  background: #eff6ff;
  border-radius: var(--radius-lg);
  border-top-left-radius: var(--radius-sm);
  width: fit-content;
}

.sw-demo-chat-typing-dot {
  width: 6px;
  height: 6px;
  background: #6b7280;
  border-radius: 50%;
  animation: typing-bounce 1.4s infinite ease-in-out;
}

.sw-demo-chat-typing-dot:nth-child(1) { animation-delay: 0s; }
.sw-demo-chat-typing-dot:nth-child(2) { animation-delay: 0.2s; }
.sw-demo-chat-typing-dot:nth-child(3) { animation-delay: 0.4s; }

@keyframes typing-bounce {
  0%, 60%, 100% { transform: translateY(0); }
  30% { transform: translateY(-4px); }
}

/* Industry chips */
.sw-demo-chat-industry-select {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
  gap: 8px;
  margin-top: 4px;
}

.sw-demo-chip {
  border-radius: var(--radius-full);
  border: 1px solid #e5e7eb;
  background: #ffffff;
  padding: 7px 10px;
  font-size: 0.88rem;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  cursor: pointer;
  transition: background-color var(--transition-fast) ease, 
              border-color var(--transition-fast) ease, 
              transform 0.12s ease,
              box-shadow var(--transition-fast) ease;
  font-family: inherit;
}

.sw-demo-chip:hover {
  border-color: var(--shockwave-red);
  background: rgba(209, 46, 31, 0.06);
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(209, 46, 31, 0.1);
}

.sw-demo-chip:active {
  transform: translateY(0);
}

.sw-demo-chip--active {
  border-color: var(--shockwave-red);
  background: var(--shockwave-red-light);
  color: #b91c1c;
  font-weight: 600;
}

/* Chat footer */
.sw-demo-chat-footer {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 10px;
}

.sw-demo-chat-input {
  flex: 1;
  min-height: 40px;
  padding: 8px 12px;
  border-radius: var(--radius-full);
  border: 1px solid #d1d5db;
  font-size: 0.9rem;
  font-family: inherit;
  outline: none;
  transition: border-color var(--transition-fast) ease, 
              box-shadow var(--transition-fast) ease;
}

.sw-demo-chat-input:focus {
  border-color: var(--shockwave-red);
  box-shadow:
    0 0 0 1px rgba(209, 46, 31, 0.5),
    0 0 0 4px rgba(209, 46, 31, 0.12);
}

.sw-demo-chat-input::placeholder {
  color: #9ca3af;
}

.sw-demo-chat-send {
  flex-shrink: 0;
  border-radius: var(--radius-full);
  border: none;
  padding: 8px 14px;
  font-size: 0.88rem;
  font-weight: 600;
  background: #111827;
  color: #f9fafb;
  cursor: pointer;
  transition: background var(--transition-fast) ease, 
              transform 0.1s ease, 
              box-shadow var(--transition-fast) ease;
  font-family: inherit;
}

.sw-demo-chat-send:hover {
  background: #020617;
  box-shadow: 0 8px 18px rgba(15, 23, 42, 0.25);
  transform: translateY(-1px);
}

.sw-demo-chat-send:active {
  transform: translateY(0);
  box-shadow: none;
}

.sw-demo-chat-send:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none;
}

/* Typewriter suggestions */
.sw-demo-chat-suggest {
  margin-top: 8px;
  font-size: 0.82rem;
  color: #6b7280;
  display: flex;
  align-items: baseline;
  gap: 6px;
  min-height: 1.2em;
}

.sw-demo-chat-suggest-label {
  font-weight: 600;
  color: #4b5563;
  flex-shrink: 0;
}

.sw-demo-chat-suggest-text {
  font-style: italic;
  color: #374151;
  min-height: 1.2em;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* System note */
.sw-demo-chat-next {
  margin-top: 10px;
  font-size: 0.85rem;
  color: #6b7280;
}

/* CTA banner */
.sw-demo-chat-cta-banner {
  margin-top: 12px;
  padding: 10px 12px;
  border-radius: var(--radius-lg);
  background: #111827;
  color: #f9fafb;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 8px;
  justify-content: space-between;
}

.sw-demo-chat-cta-text {
  font-size: 0.9rem;
}

.sw-demo-chat-cta-btn {
  border: none;
  border-radius: var(--radius-full);
  padding: 9px 16px;
  font-size: 0.88rem;
  font-weight: 600;
  background: linear-gradient(135deg, #d12e1f, #f97316);
  color: #f9fafb;
  cursor: pointer;
  white-space: nowrap;
  transition: transform var(--transition-fast) ease, 
              box-shadow var(--transition-fast) ease;
  font-family: inherit;
}

.sw-demo-chat-cta-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 12px 22px rgba(220, 38, 38, 0.35);
}

.sw-demo-chat-cta-btn:active {
  transform: translateY(0);
}


/* ============================================================
   LIVE VOICE CONSOLE
   ============================================================ */

.sw-demo-console {
  max-width: 720px;
  margin: 4px auto 0;
  background:
    radial-gradient(circle at top left, rgba(124, 58, 237, 0.2), transparent 60%),
    radial-gradient(circle at bottom right, rgba(16, 185, 129, 0.15), transparent 55%),
    linear-gradient(145deg, rgba(15, 23, 42, 0.98), rgba(6, 10, 18, 1));
  border-radius: var(--radius-2xl);
  padding: 18px 18px 16px;
  border: 1px solid rgba(148, 163, 184, 0.5);
  box-shadow:
    0 24px 70px rgba(0, 0, 0, 0.9),
    0 0 0 1px rgba(15, 23, 42, 1);
  color: #e5e7eb;
  position: relative;
  z-index: var(--z-content);
}

/* Console header */
.sw-demo-console-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  margin-bottom: 12px;
}

.sw-demo-console-title-block {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.sw-demo-console-title {
  font-size: 0.95rem;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.09em;
  color: #f9fafb;
}

.sw-demo-console-scenario {
  font-size: 0.75rem;
  color: #9ca3af;
}

.sw-demo-console-scenario span {
  font-weight: 500;
  color: #e5e7eb;
}

/* Steps */
.sw-demo-console-steps {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  justify-content: flex-end;
}

.sw-step {
  font-size: 0.72rem;
  padding: 3px 7px;
  border-radius: var(--radius-full);
  border: 1px solid rgba(148, 163, 184, 0.5);
  color: rgba(209, 213, 219, 0.85);
  transition: all var(--transition-fast) ease;
}

.sw-step--active {
  border-color: #fbbf24;
  background: rgba(251, 191, 36, 0.15);
  color: #fef3c7;
  font-weight: 600;
}

.sw-step--done {
  border-color: rgba(34, 197, 94, 0.7);
  background: rgba(34, 197, 94, 0.15);
  color: #bbf7d0;
}

/* Console body */
.sw-demo-console-body {
  padding: 12px 2px 10px;
}

/* Status row */
.sw-demo-console-status {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  gap: 12px;
  margin-bottom: 12px;
}

.sw-console-status-label {
  font-size: 0.88rem;
  color: #e5e7eb;
}

.sw-console-timer {
  font-size: 0.78rem;
  color: #9ca3af;
  display: flex;
  align-items: baseline;
  gap: 4px;
}

.sw-console-timer strong {
  font-size: 0.92rem;
  font-variant-numeric: tabular-nums;
}

/* Decisions */
.sw-demo-console-decisions {
  padding: 10px 10px 8px;
  border-radius: var(--radius-lg);
  background: radial-gradient(circle at top left,
    rgba(15, 23, 55, 0.95),
    rgba(6, 8, 18, 1));
  border: 1px solid rgba(55, 65, 81, 0.9);
}

.sw-console-decision {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 0;
  font-size: 0.8rem;
  color: rgba(209, 213, 219, 0.85);
  transition: color var(--transition-fast) ease;
}

.sw-console-decision-icon {
  width: 18px;
  height: 18px;
  border-radius: var(--radius-full);
  border: 1px solid rgba(148, 163, 184, 0.8);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 0.7rem;
  flex-shrink: 0;
  transition: all var(--transition-fast) ease;
}

.sw-console-decision[data-status="active"] .sw-console-decision-icon {
  border-color: #f97316;
  box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.35);
  animation: decision-pulse 1s ease-in-out infinite;
}

@keyframes decision-pulse {
  0%, 100% { box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.35); }
  50% { box-shadow: 0 0 0 5px rgba(249, 115, 22, 0.15); }
}

.sw-console-decision[data-status="done"] .sw-console-decision-icon {
  border-color: #22c55e;
  background: rgba(34, 197, 94, 0.2);
}

.sw-console-decision[data-status="done"] {
  color: #bbf7d0;
}

.sw-console-decision-text {
  flex: 1;
}

/* Transcript */
.sw-demo-console-transcript {
  margin-top: 10px;
  padding: 10px 12px;
  border-radius: var(--radius-lg);
  background: rgba(15, 23, 42, 0.95);
  border: 1px solid rgba(55, 65, 81, 0.9);
}

.sw-demo-console-transcript-title {
  font-size: 0.85rem;
  font-weight: 600;
  color: #e5e7eb;
  margin-bottom: 6px;
}

.sw-demo-console-transcript-body {
  max-height: 120px;
  overflow-y: auto;
  font-size: 0.8rem;
  color: #d1d5db;
}

.sw-demo-console-transcript-line {
  display: flex;
  gap: 6px;
  margin-bottom: 4px;
}

.sw-demo-console-transcript-speaker {
  font-weight: 600;
  color: #9ca3af;
  flex-shrink: 0;
}

.sw-demo-console-transcript-text {
  flex: 1;
}

.sw-demo-console-transcript-line--user .sw-demo-console-transcript-speaker {
  color: #60a5fa;
}

.sw-demo-console-transcript-line--assistant .sw-demo-console-transcript-speaker {
  color: #34d399;
}

/* Summary */
.sw-demo-console-summary {
  margin-top: 12px;
  padding: 10px 12px 10px;
  border-radius: var(--radius-lg);
  background: rgba(15, 23, 42, 0.95);
  border: 1px solid rgba(55, 65, 81, 0.9);
}

.sw-demo-console-summary h3 {
  font-size: 0.9rem;
  font-weight: 600;
  color: #e5e7eb;
  margin-bottom: 6px;
}

.sw-demo-console-summary-body {
  font-size: 0.82rem;
  color: #d1d5db;
}

.sw-demo-console-summary-body p {
  margin-bottom: 8px;
}

.sw-demo-console-summary-body ul {
  padding-left: 1.1rem;
  margin: 4px 0 8px;
}

.sw-demo-console-summary-body li {
  margin-bottom: 3px;
}

.sw-demo-console-summary-body strong {
  color: #f9fafb;
}

/* Tier block */
.sw-demo-console-tier {
  margin-top: 10px;
  padding-top: 10px;
  border-top: 1px solid rgba(55, 65, 81, 0.85);
}

.sw-demo-console-tier-label {
  font-size: 0.75rem;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: rgba(148, 163, 184, 0.9);
  margin-bottom: 4px;
}

.sw-demo-console-tier-main {
  display: flex;
  flex-wrap: wrap;
  align-items: baseline;
  gap: 8px;
  margin-bottom: 2px;
}

.sw-demo-console-tier-name {
  font-size: 0.9rem;
  font-weight: 600;
  color: #e5e7eb;
}

.sw-demo-console-tier-price {
  font-size: 0.8rem;
  font-weight: 500;
  color: rgba(209, 213, 219, 0.85);
}

.sw-demo-console-tier-tagline {
  font-size: 0.8rem;
  font-weight: 500;
  color: rgba(248, 250, 252, 0.92);
  margin-bottom: 3px;
}

.sw-demo-console-tier-note {
  font-size: 0.8rem;
  color: rgba(148, 163, 184, 0.95);
  line-height: 1.5;
}

/* Reasoning */
.sw-demo-console-reasoning {
  margin-top: 10px;
  padding-top: 10px;
  border-top: 1px solid rgba(55, 65, 81, 0.85);
}

.sw-demo-console-reasoning-title {
  font-size: 0.8rem;
  font-weight: 600;
  color: #e5e7eb;
  margin-bottom: 4px;
}

.sw-demo-console-reasoning-list {
  list-style: disc;
  padding-left: 1.1rem;
  margin: 4px 0 0;
  font-size: 0.8rem;
  color: #d1d5db;
}

.sw-demo-console-reasoning-list li {
  margin-bottom: 3px;
}

.sw-demo-console-reasoning-list strong {
  color: #f9fafb;
}

/* Console footer */
.sw-demo-console-footer {
  margin-top: 12px;
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  justify-content: flex-end;
}

.sw-demo-console-primary,
.sw-demo-console-secondary,
.sw-demo-console-ghost {
  font-size: 0.86rem;
  border-radius: var(--radius-full);
  padding: 9px 14px;
  cursor: pointer;
  border: none;
  transition: background var(--transition-fast) ease, 
              transform 0.12s ease, 
              box-shadow var(--transition-fast) ease;
  white-space: nowrap;
  font-family: inherit;
}

.sw-demo-console-primary {
  background: linear-gradient(135deg, #4f46e5, #7c3aed, #ec4899);
  color: #f9fafb;
  font-weight: 600;
}

.sw-demo-console-primary:hover {
  transform: translateY(-1px);
  box-shadow:
    0 12px 30px rgba(15, 23, 42, 0.65),
    0 0 0 1px rgba(255, 255, 255, 0.06) inset;
}

.sw-demo-console-primary:active {
  transform: translateY(0);
}

.sw-demo-console-secondary {
  background: transparent;
  color: #e5e7eb;
  border: 1px solid rgba(148, 163, 184, 0.75);
}

.sw-demo-console-secondary:hover {
  background: rgba(15, 23, 42, 0.9);
}

.sw-demo-console-ghost {
  background: transparent;
  color: #9ca3af;
  text-decoration: underline;
  padding-inline: 0;
}

.sw-demo-console-ghost:hover {
  color: #e5e7eb;
}


/* ============================================================
   MODAL (VOICE / EMAIL GATE)
   ============================================================ */

.sw-demo-modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(15, 23, 42, 0.8);
  z-index: var(--z-modal);
  display: none;
  align-items: center;
  justify-content: center;
  padding: 16px;
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
}

.sw-demo-modal-overlay:not([hidden]) {
  display: flex;
}

.sw-demo-modal {
  max-width: 460px;
  width: 100%;
  background: #ffffff;
  border-radius: var(--radius-xl);
  padding: 20px 18px 18px;
  box-shadow:
    0 24px 80px rgba(0, 0, 0, 0.5),
    0 0 0 1px var(--sw-border-light);
  position: relative;
  color: #111827;
  animation: modal-appear 0.3s ease-out;
}

@keyframes modal-appear {
  from {
    opacity: 0;
    transform: scale(0.95) translateY(10px);
  }
  to {
    opacity: 1;
    transform: scale(1) translateY(0);
  }
}

.sw-demo-modal-close {
  position: absolute;
  top: 10px;
  right: 10px;
  border-radius: var(--radius-full);
  border: none;
  width: 28px;
  height: 28px;
  font-size: 18px;
  cursor: pointer;
  background: #f3f4f6;
  color: #111827;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  transition: background var(--transition-fast) ease;
  font-family: inherit;
}

.sw-demo-modal-close:hover {
  background: #e5e7eb;
}

.sw-demo-modal-icon {
  font-size: 2.4rem;
  text-align: center;
  margin-bottom: 6px;
}

.sw-demo-modal-title {
  text-align: center;
  font-size: 1.25rem;
  font-weight: 700;
  margin-bottom: 4px;
}

.sw-demo-modal-sub {
  text-align: center;
  font-size: 0.88rem;
  color: #4b5563;
  margin-bottom: 16px;
}

.sw-demo-modal-form {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

/* Form fields */
.sw-demo-form-group {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.sw-demo-form-label {
  font-size: 0.8rem;
  font-weight: 600;
  color: #111827;
}

.sw-demo-required {
  color: #dc2626;
  margin-left: 3px;
}

.sw-demo-form-input {
  width: 100%;
  padding: 9px 11px;
  border-radius: var(--radius-md);
  border: 1px solid #e5e7eb;
  font-size: 0.9rem;
  font-family: inherit;
  outline: none;
  transition: border-color var(--transition-fast) ease, 
              box-shadow var(--transition-fast) ease;
}

.sw-demo-form-input:focus {
  border-color: var(--shockwave-red);
  box-shadow:
    0 0 0 1px rgba(209, 46, 31, 0.45),
    0 0 0 4px rgba(209, 46, 31, 0.12);
}

.sw-demo-form-input::placeholder {
  color: #9ca3af;
}

.sw-demo-form-radio-row {
  display: flex;
  align-items: center;
  gap: 14px;
  margin-top: 4px;
}

.sw-demo-form-radio {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  font-size: 0.85rem;
  cursor: pointer;
}

.sw-demo-form-radio input[type="radio"] {
  accent-color: var(--shockwave-red);
}

.sw-demo-form-hint {
  font-size: 0.75rem;
  color: #6b7280;
}

/* Trust row */
.sw-demo-trust-row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  font-size: 0.78rem;
  color: #6b7280;
  justify-content: center;
  margin-top: 4px;
}

/* Submit */
.sw-demo-modal-submit {
  margin-top: 4px;
  border-radius: var(--radius-lg);
  border: none;
  background: var(--shockwave-red);
  color: #f9fafb;
  font-size: 0.96rem;
  font-weight: 600;
  padding: 10px 14px;
  cursor: pointer;
  width: 100%;
  transition: background var(--transition-fast) ease, 
              transform 0.12s ease, 
              box-shadow var(--transition-fast) ease;
  font-family: inherit;
}

.sw-demo-modal-submit:hover {
  background: var(--shockwave-red-hover);
  box-shadow: 0 14px 30px rgba(220, 38, 38, 0.35);
  transform: translateY(-1px);
}

.sw-demo-modal-submit:active {
  transform: translateY(0);
}

.sw-demo-modal-submit:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none;
}

.sw-demo-modal-dismiss {
  margin-top: 8px;
  font-size: 0.8rem;
  text-align: center;
  color: #6b7280;
}

.sw-demo-modal-dismiss-link {
  border: none;
  background: transparent;
  color: #6b7280;
  text-decoration: underline;
  cursor: pointer;
  font-size: 0.8rem;
  font-family: inherit;
}

.sw-demo-modal-dismiss-link:hover {
  color: #374151;
}


/* ============================================================
   VOICE OVERLAY
   ============================================================ */

.sw-voice-overlay {
  position: fixed;
  inset: 0;
  z-index: var(--z-voice-overlay);
  display: none;
  align-items: center;
  justify-content: center;
  padding: 16px;
  background: rgba(10, 14, 39, 0.92);
  backdrop-filter: blur(28px);
  -webkit-backdrop-filter: blur(28px);
}

.sw-voice-overlay:not([hidden]) {
  display: flex;
}

.sw-voice-overlay-inner {
  max-width: 720px;
  width: 100%;
  animation: voice-overlay-appear 0.4s ease-out;
}

@keyframes voice-overlay-appear {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

.sw-voice-bubble {
  width: 100%;
  max-height: 85vh;
  background: rgba(15, 23, 42, 0.98);
  border-radius: var(--radius-2xl);
  border: 1px solid rgba(148, 163, 184, 0.45);
  box-shadow: 0 24px 70px rgba(0, 0, 0, 0.75);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* Voice header */
.sw-voice-header {
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 18px 18px 14px;
  border-bottom: 1px solid rgba(55, 65, 81, 0.85);
}

.sw-voice-avatar-block {
  display: flex;
  flex-direction: column;
  gap: 8px;
  flex-shrink: 0;
}

.sw-voice-avatar {
  width: 52px;
  height: 52px;
  border-radius: var(--radius-full);
  background: radial-gradient(circle at 30% 30%, #f97316, #d12e1f);
}

.sw-voice-status {
  display: flex;
  align-items: center;
  gap: 6px;
}

.sw-voice-status-dot {
  width: 9px;
  height: 9px;
  border-radius: var(--radius-full);
  background: #22c55e;
  animation: sw-voice-dot-pulse 2s ease-in-out infinite;
}

.sw-voice-status-text {
  font-size: 0.82rem;
  color: #e5e7eb;
}

@keyframes sw-voice-dot-pulse {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.5; transform: scale(0.8); }
}

/* Waveform */
.sw-voice-waveform-wrap {
  flex: 1;
  height: 60px;
  min-width: 0;
}

#sw-voice-wave {
  width: 100%;
  height: 100%;
  display: block;
}

/* Transcript */
.sw-voice-overlay-transcript {
  flex: 1;
  padding: 12px 18px;
  overflow-y: auto;
  font-size: 0.86rem;
  color: #e5e7eb;
}

/* Controls */
.sw-voice-controls {
  padding: 10px 18px 14px;
  border-top: 1px solid rgba(55, 65, 81, 0.85);
  display: flex;
  justify-content: flex-end;
}

.sw-voice-end-btn {
  border-radius: var(--radius-full);
  border: 1px solid rgba(239, 68, 68, 0.7);
  background: rgba(239, 68, 68, 0.1);
  color: #fecaca;
  font-size: 0.84rem;
  font-weight: 600;
  padding: 7px 16px;
  cursor: pointer;
  transition: background var(--transition-fast) ease, 
              transform 0.1s ease;
  font-family: inherit;
}

.sw-voice-end-btn:hover {
  background: rgba(239, 68, 68, 0.18);
  transform: translateY(-1px);
}

.sw-voice-end-btn:active {
  transform: translateY(0);
}


/* ============================================================
   DEMO COMPLETE RECAP CARD
   ============================================================ */

.sw-demo-complete-card {
  max-width: 720px;
  margin: 16px auto 0;
  opacity: 0;
  transform: translateY(24px);
  transition: opacity 0.4s ease, transform 0.4s ease;
  position: relative;
  z-index: var(--z-content);
}

.sw-demo-complete-card:not([hidden]) {
  opacity: 1;
  transform: translateY(0);
}

.sw-demo-complete-inner {
  padding: 18px 18px 16px;
  border-radius: var(--radius-2xl);
  background:
    radial-gradient(circle at top left, rgba(124, 58, 237, 0.15), transparent 65%),
    radial-gradient(circle at bottom right, rgba(209, 46, 31, 0.15), transparent 60%),
    linear-gradient(145deg, #0f172a, #020617);
  border: 1px solid rgba(148, 163, 184, 0.6);
  box-shadow: 0 20px 60px rgba(15, 23, 42, 0.85);
}

.sw-demo-complete-title {
  font-size: 1rem;
  font-weight: 600;
  color: #f9fafb;
  margin-bottom: 4px;
}

.sw-demo-complete-sub {
  font-size: 0.88rem;
  color: #cbd5f5;
  margin-bottom: 14px;
}

.sw-demo-complete-stats {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-bottom: 12px;
}

.sw-demo-complete-stat {
  flex: 1 1 30%;
  min-width: 150px;
}

.sw-complete-stat-label {
  font-size: 0.78rem;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  color: #9ca3af;
  margin-bottom: 3px;
}

.sw-complete-stat-value {
  font-size: 1.1rem;
  font-weight: 700;
  color: #e5e7eb;
  font-variant-numeric: tabular-nums;
}

/* Tier in recap */
.sw-demo-complete-tier {
  margin-top: 4px;
  padding-top: 8px;
  border-top: 1px solid rgba(55, 65, 81, 0.85);
}

.sw-complete-tier-label {
  font-size: 0.78rem;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: #9ca3af;
  margin-bottom: 3px;
}

.sw-complete-tier-main {
  display: flex;
  flex-wrap: wrap;
  align-items: baseline;
  gap: 8px;
  margin-bottom: 2px;
}

.sw-complete-tier-name {
  font-size: 0.96rem;
  font-weight: 600;
  color: #e5e7eb;
}

.sw-complete-tier-price {
  font-size: 0.84rem;
  font-weight: 500;
  color: #cbd5f5;
}

.sw-complete-tier-tagline {
  font-size: 0.8rem;
  color: #e5e7eb;
}

/* Decision tree container */
.sw-decision-tree {
  margin-top: 10px;
  min-height: 100px;
}

.sw-decision-tree svg {
  display: block;
  width: 100%;
  height: auto;
}

/* Recap CTAs */
.sw-demo-complete-ctas {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 12px;
}

.sw-demo-complete-primary,
.sw-demo-complete-secondary {
  border-radius: var(--radius-full);
  font-size: 0.86rem;
  padding: 9px 14px;
  cursor: pointer;
  border: none;
  white-space: nowrap;
  transition: transform var(--transition-fast) ease, 
              box-shadow var(--transition-fast) ease;
  font-family: inherit;
}

.sw-demo-complete-primary {
  background: linear-gradient(135deg, #d12e1f, #f97316);
  color: #f9fafb;
  font-weight: 600;
}

.sw-demo-complete-primary:hover {
  transform: translateY(-1px);
  box-shadow: 0 12px 28px rgba(220, 38, 38, 0.35);
}

.sw-demo-complete-primary:active {
  transform: translateY(0);
}

.sw-demo-complete-secondary {
  background: transparent;
  color: #e5e7eb;
  border: 1px solid rgba(148, 163, 184, 0.7);
}

.sw-demo-complete-secondary:hover {
  background: rgba(15, 23, 42, 0.85);
}


/* ============================================================
   DEBUG & LOADING STATES
   ============================================================ */

/* Loading indicator */
.sw-particles-loading {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
  z-index: 5;
  opacity: 1;
  transition: opacity 0.5s ease;
}

.sw-particles-loading.hidden {
  opacity: 0;
  pointer-events: none;
}

.sw-particles-loading-spinner {
  width: 40px;
  height: 40px;
  border: 3px solid rgba(124, 58, 237, 0.2);
  border-top-color: #7C3AED;
  border-radius: 50%;
  animation: loading-spin 1s linear infinite;
}

.sw-particles-loading-text {
  font-size: 0.8rem;
  color: #9ca3af;
}

@keyframes loading-spin {
  to {
    transform: rotate(360deg);
  }
}

/* Performance monitor */
.sw-performance-monitor {
  position: fixed;
  top: 10px;
  right: 10px;
  padding: 8px 12px;
  background: rgba(0, 0, 0, 0.85);
  border: 1px solid rgba(34, 197, 94, 0.5);
  border-radius: var(--radius-md);
  font-family: 'Monaco', 'Consolas', 'Courier New', monospace;
  font-size: 11px;
  color: #e5e7eb;
  z-index: var(--z-debug);
  pointer-events: none;
  display: none;
}

.sw-performance-monitor.visible {
  display: block;
}

.sw-performance-monitor .fps {
  color: #22c55e;
  font-weight: 700;
}

.sw-performance-monitor .fps.warning {
  color: #f59e0b;
}

.sw-performance-monitor .fps.critical {
  color: #ef4444;
}

/* Debug collision overlay */
#sw-text-collision-debug {
  position: fixed !important;
  top: 0 !important;
  left: 0 !important;
  width: 100vw !important;
  height: 100vh !important;
  pointer-events: none !important;
  z-index: calc(var(--z-debug) - 1) !important;
}


/* ============================================================
   FALLBACK STATES
   ============================================================ */

/* WebGL fallback - when WebGL is not supported */
.live-demo.webgl-fallback .sw-particle-canvas-v2,
#live-ai-demo.webgl-fallback .sw-particle-canvas-v2 {
  display: none !important;
}

.live-demo.webgl-fallback .live-demo-bg-wrap::before,
#live-ai-demo.webgl-fallback .live-demo-bg-wrap::before {
  content: '';
  position: absolute;
  inset: 0;
  background: 
    radial-gradient(ellipse 800px 600px at 30% 30%, rgba(124, 58, 237, 0.15), transparent),
    radial-gradient(ellipse 600px 500px at 70% 60%, rgba(209, 46, 31, 0.1), transparent),
    linear-gradient(180deg, rgba(5, 8, 22, 0.95), rgba(2, 3, 8, 1));
  z-index: 1;
  pointer-events: none;
}

/* WebGL context lost - temporary state during GPU recovery */
.live-demo-bg-wrap.webgl-context-lost .sw-particle-canvas-v2 {
  opacity: 0.3 !important;
  filter: blur(4px) !important;
  transition: opacity 0.3s ease, filter 0.3s ease;
}

.live-demo-bg-wrap.webgl-context-lost::after {
  content: 'Recovering graphics...';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  padding: 12px 24px;
  background: rgba(15, 23, 42, 0.9);
  border: 1px solid rgba(124, 58, 237, 0.5);
  border-radius: var(--radius-lg);
  color: #e5e7eb;
  font-size: 0.85rem;
  z-index: 10;
  pointer-events: none;
  animation: context-lost-pulse 2s ease-in-out infinite;
}

@keyframes context-lost-pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.6; }
}

/* Reduced motion - when user prefers reduced motion */
.live-demo.reduced-motion .sw-particle-canvas-v2,
#live-ai-demo.reduced-motion .sw-particle-canvas-v2 {
  animation: none !important;
  transition: none !important;
}

.live-demo.reduced-motion .sw-emma-avatar-container,
#live-ai-demo.reduced-motion .sw-emma-avatar-container {
  animation: none !important;
}

/* CSS-only animated fallback for no-WebGL environments */
.live-demo.webgl-fallback .live-demo-bg-wrap .css-particle-fallback,
#live-ai-demo.webgl-fallback .live-demo-bg-wrap .css-particle-fallback {
  position: absolute;
  inset: 0;
  z-index: 2;
  pointer-events: none;
  overflow: hidden;
}

/* Floating orbs fallback animation */
.css-particle-fallback::before,
.css-particle-fallback::after {
  content: '';
  position: absolute;
  border-radius: 50%;
  opacity: 0.4;
  animation: css-orb-float 8s ease-in-out infinite;
}

.css-particle-fallback::before {
  width: 300px;
  height: 300px;
  background: radial-gradient(circle, rgba(124, 58, 237, 0.3) 0%, transparent 70%);
  top: 20%;
  left: 15%;
  animation-delay: 0s;
}

.css-particle-fallback::after {
  width: 250px;
  height: 250px;
  background: radial-gradient(circle, rgba(209, 46, 31, 0.25) 0%, transparent 70%);
  bottom: 25%;
  right: 20%;
  animation-delay: 4s;
}

@keyframes css-orb-float {
  0%, 100% {
    transform: translate(0, 0) scale(1);
  }
  25% {
    transform: translate(30px, -20px) scale(1.1);
  }
  50% {
    transform: translate(60px, 10px) scale(0.95);
  }
  75% {
    transform: translate(20px, 30px) scale(1.05);
  }
}

/* ============================================================
   RESPONSIVE - TABLET
   ============================================================ */

@media (max-width: 900px) {
  .live-demo-inner {
    padding: 60px 16px;
  }

  .sw-demo-chat,
  .sw-demo-console {
    max-width: 100%;
  }

  .live-demo-system-status {
    flex-wrap: wrap;
    justify-content: center;
  }
}


/* ============================================================
   RESPONSIVE - MOBILE
   ============================================================ */

@media (max-width: 768px) {
  .live-demo,
  #live-ai-demo {
    padding: 0;
  }

  .live-demo-header {
    margin-bottom: 32px;
  }

  .sw-demo-console-header {
    flex-direction: column;
    align-items: flex-start;
  }

  .sw-demo-console-steps {
    justify-content: flex-start;
    margin-top: 8px;
  }

  .sw-demo-console-footer {
    justify-content: flex-start;
  }

  .live-demo-trust-strip {
    flex-direction: column;
    gap: 6px;
    padding: 8px 12px;
  }

  .sw-demo-chat-cta-banner {
    position: sticky;
    bottom: 8px;
    z-index: var(--z-sticky);
  }

  .sw-voice-overlay-inner {
    max-width: 100%;
  }
  
  .sw-voice-bubble {
    border-radius: 0;
    max-height: 100vh;
  }

  .sw-voice-header {
    flex-direction: column;
    align-items: flex-start;
  }

  .sw-voice-waveform-wrap {
    width: 100%;
    margin-top: 12px;
  }

  /* Reduce particle glow for performance */
  .sw-particle-canvas-v2 {
    filter: none !important;
  }

  .live-demo::before,
  #live-ai-demo::before {
    opacity: 0.4;
    filter: saturate(1.1) contrast(1.02);
  }

  .live-demo::after,
  #live-ai-demo::after {
    opacity: 0.3;
  }

  /* Hide debug elements on mobile */
  .sw-performance-monitor,
  .sw-morph-indicator {
    display: none !important;
  }

  /* Hide interaction hint on mobile */
  .sw-demo-interaction-hint {
    display: none;
  }

  /* Adjust proof bar */
  .sw-live-proof-bar {
    font-size: 48px;
  }

  /* Stack mini steps */
  .sw-demo-mini-steps {
    flex-direction: column;
    align-items: center;
  }
}


/* ============================================================
   RESPONSIVE - SMALL MOBILE
   ============================================================ */

@media (max-width: 480px) {
  .live-demo-title {
    font-size: 1.7rem;
  }

  .sw-demo-chat {
    padding: 16px 14px 14px;
    border-radius: var(--radius-xl);
  }

  .sw-demo-chat-industry-select {
    grid-template-columns: 1fr 1fr;
  }

  .sw-demo-console {
    padding: 16px 14px 14px;
    border-radius: var(--radius-xl);
  }

  .sw-demo-console-footer {
    flex-direction: column;
    align-items: stretch;
  }

  .sw-demo-console-primary,
  .sw-demo-console-secondary {
    width: 100%;
    text-align: center;
  }

  .sw-demo-console-ghost {
    align-self: center;
  }

  .sw-demo-complete-ctas {
    flex-direction: column;
  }

  .sw-demo-complete-primary,
  .sw-demo-complete-secondary {
    width: 100%;
    text-align: center;
  }

  .sw-demo-complete-stats {
    flex-direction: column;
  }

  .sw-demo-complete-stat {
    min-width: 100%;
  }

  .live-demo::before,
  #live-ai-demo::before {
    opacity: 0.3;
  }

  .live-demo::after,
  #live-ai-demo::after {
    display: none;
  }

  .sw-live-proof-bar {
    font-size: 42px;
  }

  .sw-live-demo-proof-container {
    padding: 24px 16px;
  }

  /* Modal adjustments */
  .sw-demo-modal {
    padding: 16px 14px;
  }

  .sw-demo-form-radio-row {
    flex-direction: column;
    align-items: flex-start;
    gap: 8px;
  }
}


/* ============================================================
   ACCESSIBILITY & PREFERENCES
   ============================================================ */

/* Focus visible styles */
a:focus-visible,
button:focus-visible,
input:focus-visible,
select:focus-visible,
textarea:focus-visible {
  outline: 2px solid #7c3aed;
  outline-offset: 2px;
}

/* Skip link (if needed) */
.sw-skip-link {
  position: absolute;
  top: -100px;
  left: 50%;
  transform: translateX(-50%);
  background: #111827;
  color: #f9fafb;
  padding: 8px 16px;
  border-radius: var(--radius-md);
  z-index: calc(var(--z-debug) + 1);
  text-decoration: none;
  font-weight: 600;
}

.sw-skip-link:focus {
  top: 10px;
}

/* Reduced motion preference */
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }

  .live-demo-status-dot,
  .live-demo-particle-layer::before,
  .live-demo-particle-layer::after,
  .sw-voice-status-dot,
  .sw-console-decision[data-status="active"] .sw-console-decision-icon {
    animation: none !important;
  }

  .live-demo::before,
  .live-demo::after,
  #live-ai-demo::before,
  #live-ai-demo::after,
  .live-demo-sonic-canvas,
  .live-demo-particle-layer,
  .sw-particle-background,
  .sw-particle-canvas-v2 {
    animation: none !important;
    transform: none !important;
  }

  .sw-particle-canvas-v2,
  .sw-emma-avatar-container,
  .sw-ring-click-indicator {
    display: none !important;
  }

  .live-demo .live-demo-bg-wrap,
  #live-ai-demo .live-demo-bg-wrap {
    background: 
      radial-gradient(ellipse 900px 700px at 30% 30%, rgba(124, 58, 237, 0.1), transparent),
      radial-gradient(ellipse 700px 600px at 70% 60%, rgba(209, 46, 31, 0.08), transparent),
      linear-gradient(180deg, #0a0d14, #020308);
  }
}

/* High contrast preference */
@media (prefers-contrast: high) {
  .live-demo,
  #live-ai-demo {
    background:
      repeating-linear-gradient(
        0deg,
        transparent,
        transparent 39px,
        rgba(124, 58, 237, 0.18) 39px,
        rgba(124, 58, 237, 0.18) 40px
      ),
      linear-gradient(180deg, #111418 0%, #050609 100%);
  }

  .live-demo::before,
  .live-demo::after,
  #live-ai-demo::before,
  #live-ai-demo::after {
    display: none;
  }

  .sw-particle-canvas-v2 {
    opacity: 0.5;
    filter: contrast(1.4) !important;
  }

  .sw-demo-chat,
  .sw-demo-console,
  .sw-demo-modal {
    border: 2px solid currentColor;
  }

  .sw-demo-modal-submit,
  .sw-demo-chat-send,
  .sw-demo-console-primary {
    border: 2px solid #ffffff;
  }

  .sw-demo-chip {
    border: 2px solid currentColor;
  }

  .sw-demo-chip--active {
    border-color: #ffffff;
  }
}

/* Forced colors mode (Windows High Contrast) */
@media (forced-colors: active) {
  .sw-demo-chat,
  .sw-demo-console,
  .sw-demo-modal,
  .sw-demo-complete-card {
    border: 2px solid CanvasText;
  }

  .sw-demo-chip,
  .sw-step,
  .sw-demo-form-input {
    border: 1px solid CanvasText;
  }

  .sw-demo-modal-submit,
  .sw-demo-chat-send,
  .sw-demo-console-primary,
  .sw-demo-complete-primary {
    background: ButtonFace;
    color: ButtonText;
    border: 2px solid ButtonText;
  }
}


/* ============================================================
   PRINT STYLES
   ============================================================ */

@media print {
  /* Hide all animated/interactive elements */
  .sw-particle-canvas-v2,
  .sw-emma-avatar-container,
  .sw-ring-click-indicator,
  .live-demo-sonic-canvas,
  .live-demo-particle-layer,
  .sw-particle-background,
  #particle-canvas,
  .sw-voice-overlay,
  .sw-demo-modal-overlay,
  .live-demo-status-dot,
  .sw-performance-monitor,
  .sw-morph-indicator,
  .sw-demo-interaction-hint,
  .sw-demo-chat-cta-banner,
  .sw-demo-console-footer,
  .sw-demo-complete-ctas {
    display: none !important;
  }

  .live-demo,
  #live-ai-demo {
    background: #ffffff !important;
    color: #000000 !important;
    padding: 20px 0 !important;
    position: relative !important;
    left: auto !important;
    right: auto !important;
    margin-left: 0 !important;
    margin-right: 0 !important;
    width: auto !important;
  }

  .live-demo::before,
  .live-demo::after,
  #live-ai-demo::before,
  #live-ai-demo::after {
    display: none !important;
  }

  .live-demo-inner {
    max-width: 100% !important;
    padding: 0 !important;
  }

  .sw-demo-chat,
  .sw-demo-console,
  .sw-demo-complete-card {
    box-shadow: none !important;
    border: 1px solid #ccc !important;
    break-inside: avoid;
  }

  .sw-demo-chat {
    background: #f9fafb !important;
  }

  .sw-demo-console,
  .sw-demo-complete-inner {
    background: #f3f4f6 !important;
    color: #111827 !important;
  }

  .sw-demo-console-title,
  .sw-demo-console-summary h3,
  .sw-complete-stat-value,
  .sw-complete-tier-name {
    color: #111827 !important;
  }

  .sw-console-status-label,
  .sw-demo-console-tier-note,
  .sw-demo-console-reasoning-list,
  .sw-demo-console-summary-body,
  .sw-complete-stat-label,
  .sw-complete-tier-price {
    color: #374151 !important;
  }

  .live-demo-title {
    color: #111827 !important;
    text-shadow: none !important;
  }

  .live-demo-subtitle,
  .live-demo-subsubtitle,
  .eyebrow {
    color: #4b5563 !important;
  }

  .sw-live-demo-proof-container {
    background: #f3f4f6 !important;
    border: 1px solid #d1d5db !important;
  }

  .sw-live-proof-bar {
    color: #059669 !important;
    text-shadow: none !important;
  }

  .sw-live-proof-context {
    color: #059669 !important;
  }

  /* Page break handling */
  .live-demo-header {
    break-after: avoid;
  }

  .sw-demo-body {
    break-before: avoid;
  }
}


/* ============================================================
   UTILITY CLASSES
   ============================================================ */

/* Screen reader only */
.sw-visually-hidden,
.sw-sr-only {
  position: absolute !important;
  width: 1px !important;
  height: 1px !important;
  padding: 0 !important;
  margin: -1px !important;
  overflow: hidden !important;
  clip: rect(0, 0, 0, 0) !important;
  white-space: nowrap !important;
  border: 0 !important;
}

/* Hidden but maintains space */
.sw-invisible {
  visibility: hidden;
}

/* Completely hidden */
.sw-hidden {
  display: none !important;
}

/* Flex utilities */
.sw-flex {
  display: flex;
}

.sw-flex-col {
  flex-direction: column;
}

.sw-items-center {
  align-items: center;
}

.sw-justify-center {
  justify-content: center;
}

.sw-justify-between {
  justify-content: space-between;
}

.sw-gap-sm {
  gap: var(--space-sm);
}

.sw-gap-md {
  gap: var(--space-md);
}

/* Text utilities */
.sw-text-center {
  text-align: center;
}

.sw-text-muted {
  color: var(--sw-muted);
}

.sw-font-bold {
  font-weight: 700;
}

/* Animation utilities */
.sw-animate-pulse {
  animation: utility-pulse 2s ease-in-out infinite;
}

@keyframes utility-pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

.sw-animate-spin {
  animation: utility-spin 1s linear infinite;
}

@keyframes utility-spin {
  to { transform: rotate(360deg); }
}

.sw-animate-bounce {
  animation: utility-bounce 1s infinite;
}

@keyframes utility-bounce {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-10px); }
}

/* Transition utilities */
.sw-transition-all {
  transition: all var(--transition-normal) ease;
}

.sw-transition-opacity {
  transition: opacity var(--transition-normal) ease;
}

.sw-transition-transform {
  transition: transform var(--transition-normal) ease;
}
/* Restore bright tri-color aura rings */
.live-demo::before,
#live-ai-demo::before {
  content: '';
  position: absolute;
  inset: 0 calc(50% - 50vw);
  z-index: 1;
  pointer-events: none;

  background:
    /* Thin crisp rings - original strengths */

    /* Purple ring - top left */
    radial-gradient(
      circle 600px at 20% 25%,
      transparent 0%,
      transparent 48.5%,
      rgba(124, 58, 237, 0.14) 49%,
      rgba(124, 58, 237, 0.14) 51%,
      transparent 51.5%,
      transparent 100%
    ),

    /* Green ring - top right */
    radial-gradient(
      circle 520px at 80% 35%,
      transparent 0%,
      transparent 48.5%,
      rgba(16, 185, 129, 0.11) 49%,
      rgba(16, 185, 129, 0.11) 51%,
      transparent 51.5%,
      transparent 100%
    ),

    /* Red ring - bottom center */
    radial-gradient(
      circle 750px at 50% 78%,
      transparent 0%,
      transparent 48.5%,
      rgba(209, 46, 31, 0.16) 49%,
      rgba(209, 46, 31, 0.16) 51%,
      transparent 51.5%,
      transparent 100%
    ),

    /* Subtle ambient glows */
    radial-gradient(
      ellipse 900px 620px at 20% 25%,
      rgba(124, 58, 237, 0.12) 0%,
      transparent 65%
    ),
    radial-gradient(
      ellipse 780px 700px at 80% 35%,
      rgba(16, 185, 129, 0.08) 0%,
      transparent 60%
    ),
    radial-gradient(
      ellipse 1000px 560px at 50% 82%,
      rgba(209, 46, 31, 0.12) 0%,
      transparent 70%
    );

  opacity: 1;  /* <- key: full-strength aura */
  filter: saturate(1.3) contrast(1.05);

  transform: translate3d(
    calc(var(--ld-parallax-x) * 0.15),
    calc(var(--ld-parallax-y) * 0.12),
    0
  );
  transition: transform var(--transition-normal) var(--ease-out-expo),
              opacity var(--transition-slow) ease;
  will-change: transform;
}
/* ============================================================
   MOBILE CHAT FIX PACK (drop-in overrides)
   Put this at the VERY END of your <style>
   ============================================================ */

@media (max-width: 768px) {
  /* 1) Kill the full-bleed 100vw breakout on mobile (prevents keyboard/layout jump) */
  .live-demo,
  #live-ai-demo {
    left: auto !important;
    right: auto !important;
    margin-left: 0 !important;
    margin-right: 0 !important;
    width: 100% !important;
    max-width: 100% !important;
    overflow-x: hidden !important;
  }

  .live-demo::before,
  .live-demo::after,
  #live-ai-demo::before,
  #live-ai-demo::after {
    inset: 0 !important; /* avoid calc(50% - 50vw) weirdness on mobile */
  }

  /* 2) Disable hover lift on touch (it can trigger weird reflow feelings) */
  @media (hover: none) {
    .sw-demo-chat:hover {
      transform: none !important;
      box-shadow:
        0 20px 60px rgba(15, 23, 42, 0.75),
        0 0 0 1px var(--sw-border-light) !important;
    }
  }

  /* 3) iOS input zoom fix: MUST be >= 16px */
  .sw-demo-chat-input {
    font-size: 16px !important;
    min-height: 48px !important;   /* more thumb-friendly */
    line-height: 1.2 !important;
  }

  /* 4) Make the message area play nice with the keyboard / dynamic viewport */
  .sw-demo-chat-messages {
    max-height: min(52dvh, 420px) !important; /* dvh = dynamic viewport */
    -webkit-overflow-scrolling: touch;
    overscroll-behavior: contain;
    padding-bottom: 10px;
  }

  /* 5) Keep the input area visible and “anchored” */
  .sw-demo-chat-footer {
    position: sticky;
    bottom: calc(env(safe-area-inset-bottom, 0px) + 8px);
    background: rgba(249, 250, 251, 0.98);
    padding-top: 10px;
    padding-bottom: 10px;
    z-index: 20;
    border-top: 1px solid rgba(17, 24, 39, 0.08);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
  }

  /* 6) Sticky CTA is cool, but it’s the #1 thing that wrecks typing on small screens */
  .sw-demo-chat:focus-within .sw-demo-chat-cta-banner {
    position: static !important;
    bottom: auto !important;
  }

  /* Optional: reduce visual noise while typing */
  .sw-demo-chat:focus-within .sw-demo-chat-suggest,
  .sw-demo-chat:focus-within .sw-demo-chat-next {
    display: none !important;
  }
}

@media (max-width: 480px) {
  /* Give the chat a little more width + less padding */
  .sw-demo-chat {
    padding: 14px 12px 12px !important;
  }

  /* Ensure send button stays tappable */
  .sw-demo-chat-send {
    padding: 10px 14px !important;
    min-height: 48px !important;
  }
}

</style>

<!-- ═══════════════════════════════════════════════════════════════════════════
     BLOCK 1: THREE.JS CORE + POST-PROCESSING
     Must load BEFORE any enhancement code.
     ═══════════════════════════════════════════════════════════════════════════ -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/shaders/CopyShader.js"></script>
<script>
// Verify THREE.js loaded and attach post-processing to THREE namespace
(function() {
  'use strict';
  
  if (typeof THREE === 'undefined') {
    console.error('[Shockwave] THREE.js failed to load - 3D effects will be disabled');
    window.__SW_THREE_FAILED__ = true;
    return;
  }
  
  console.log('[Shockwave] THREE.js loaded, revision:', THREE.REVISION);
  
  // Attach post-processing classes to THREE namespace if loaded as window globals
  var classes = ['EffectComposer', 'RenderPass', 'UnrealBloomPass', 'ShaderPass', 'CopyShader', 'LuminosityHighPassShader'];
  classes.forEach(function(className) {
    if (typeof window[className] !== 'undefined' && typeof THREE[className] === 'undefined') {
      THREE[className] = window[className];
    }
  });
  
  // Verify post-processing availability
  var ppStatus = {
    EffectComposer: typeof THREE.EffectComposer !== 'undefined',
    RenderPass: typeof THREE.RenderPass !== 'undefined',
    UnrealBloomPass: typeof THREE.UnrealBloomPass !== 'undefined'
  };
  console.log('[Shockwave] Post-processing status:', ppStatus);
})();
</script>

<!-- ═══════════════════════════════════════════════════════════════════════════
     BLOCK 2: SHADER GLOBALS
     These are just strings - must exist before classes try to compile them.
     ═══════════════════════════════════════════════════════════════════════════ -->
<script>
(function() {
  'use strict';
  if (window.__SW_THREE_FAILED__) return;
  
// ═══ SHADER GLOBALS ═══
// These are window.* globals for classes to access

window.PARTICLE_MORPH_VERT = `/**
 * particle-morph.vert
 * ShockwaveHQ — Unified Particle Morphing Vertex Shader v2.0
 * 
 * Supports two modes:
 * 1. Standard Mode: Uses offset + targetPosition attributes (CPU-driven)
 * 2. Direct GPU Mode: Samples position/velocity from SPH render targets
 * 
 * Features:
 * - Full-field ellipsoid distribution
 * - Morphing between current and target positions
 * - SPH fluid data visualization (density, pressure, velocity)
 * - Text collision avoidance
 * - Z-depth oscillation
 * - Voice reactivity
 * - Explosion effects
 * - Industry-specific motion
 */

precision highp float;

// ===== ATTRIBUTES =====
attribute vec3 offset;           // Base position (used in standard mode)
attribute float pindex;          // Particle index
attribute float angle;           // Random rotation angle
attribute vec3 targetPosition;   // Morph destination (standard mode)
attribute vec3 color;            // Particle color

// ===== GPU SPH DATA TEXTURES =====
// These are only used when uUseDirectGPU > 0.5
uniform sampler2D tPosition;     // Position render target (xyz = pos, w = active)
uniform sampler2D tVelocity;     // Velocity render target
uniform sampler2D tPressure;     // Pressure data (x = pressure, y = nearPressure, z = density)
uniform vec2 uDataResolution;    // SPH texture dimensions
uniform float uUseDirectGPU;     // 1.0 = sample from textures, 0.0 = use attributes
uniform float uRestDensity;      // SPH rest density for normalization

// ===== STANDARD UNIFORMS =====
uniform float uTime;
uniform float uRandom;
uniform float uDepth;
uniform float uSize;
uniform vec2 uTextureSize;
uniform float uMorphProgress;
uniform float uVoiceAmplitude;

// ===== WARP JUMP (NEW) =====
uniform float uWarpActive;
uniform float uWarpProgress;
uniform float uWarpStrength;
varying float vWarpFade;
varying float vWarpGlow;

// ===== MOTION UNIFORMS =====
uniform float uMotionSpeed;
uniform float uTurbulence;
uniform float uWaveFrequency;

// ===== EXPLOSION UNIFORMS =====
uniform float uExplosionActive;
uniform vec3 uExplosionOrigin;
uniform float uExplosionProgress;
uniform float uExplosionRadius;

// ===== TEXT COLLISION =====
uniform vec2 uTextZoneCenters[32];
uniform float uTextZoneRadii[32];
uniform int uTextZoneCount;

// ===== POINTER =====
uniform vec2 uPointer;
uniform float uPointerInfluence;

// ===== VARYINGS =====
varying vec3 vColor;
varying float vAlpha;
varying float vDepth;
varying float vVoiceGlow;
varying float vSpeed;
varying float vDensity;
varying float vPressure;

// ===== HELPER FUNCTIONS =====

float random(float seed) {
  return fract(sin(seed * 12.9898) * 43758.5453123);
}

float random2d(vec2 co) {
  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

float noise(float x) {
  float i = floor(x);
  float f = fract(x);
  float u = f * f * (3.0 - 2.0 * f);
  return mix(random(i), random(i + 1.0), u);
}

float noise2d(vec2 p) {
  vec2 i = floor(p);
  vec2 f = fract(p);
  
  float a = random2d(i);
  float b = random2d(i + vec2(1.0, 0.0));
  float c = random2d(i + vec2(0.0, 1.0));
  float d = random2d(i + vec2(1.0, 1.0));
  
  vec2 u = f * f * (3.0 - 2.0 * f);
  
  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

float fbm(vec2 p) {
  float value = 0.0;
  float amplitude = 0.5;
  
  for (int i = 0; i < 4; i++) {
    value += amplitude * noise2d(p);
    p *= 2.0;
    amplitude *= 0.5;
  }
  
  return value;
}

float easeInOutCubic(float t) {
  return t < 0.5 
    ? 4.0 * t * t * t 
    : 1.0 - pow(-2.0 * t + 2.0, 3.0) / 2.0;
}

// ===== MAIN SHADER =====
void main() {
  // Particle-specific random seeds
  float seed = pindex * 0.01;
  float rnd = random(seed);
  float rnd2 = random(seed + 42.0);
  float rnd3 = random(seed + 137.0);
  
  // ===== POSITION SOURCING =====
  vec3 pos;
  vec3 vel = vec3(0.0);
  float density = uRestDensity;
  float pressure = 0.0;
  float particleActive = 1.0;
  
  if (uUseDirectGPU > 0.5) {
    // === DIRECT GPU MODE ===
    // Sample position and velocity from SPH render targets
    vec2 dataUV = vec2(
      mod(pindex, uDataResolution.x) / uDataResolution.x,
      floor(pindex / uDataResolution.x) / uDataResolution.y
    ) + 0.5 / uDataResolution;
    
    vec4 posData = texture2D(tPosition, dataUV);
    vec4 velData = texture2D(tVelocity, dataUV);
    vec4 pressureData = texture2D(tPressure, dataUV);
    
    pos = posData.xyz;
    particleActive = posData.w;
    vel = velData.xyz;
    density = pressureData.z;
    pressure = pressureData.x;
    
  } else {
    // === STANDARD MODE ===
    // Use attributes with morph interpolation
    pos = offset;
    
    // Morphing animation
    float morphEased = easeInOutCubic(uMorphProgress);
    pos = mix(pos, targetPosition, morphEased);
  }

    // ===== WARP JUMP (NEW) =====
  vWarpFade = 0.0;
  vWarpGlow = 0.0;

  if (uWarpActive > 0.5) {
    float tW = clamp(uWarpProgress, 0.0, 1.0);

    float charge = smoothstep(0.0, 0.2, tW) * (1.0 - smoothstep(0.2, 0.35, tW));
    vWarpGlow = charge;

    float compress = smoothstep(0.0, 0.2, tW) * (1.0 - smoothstep(0.2, 0.28, tW));
    float stretch  = smoothstep(0.2, 0.55, tW) * (1.0 - smoothstep(0.55, 0.70, tW));

    float scaleX = 1.0 + (-0.18 * uWarpStrength * compress) + (0.75 * uWarpStrength * stretch);
    pos.x *= scaleX;

    float taper = 1.0 - 0.22 * uWarpStrength * stretch;
    pos.y *= taper;
    pos.z *= taper;

    float alphaMul = mix(
      1.0 - smoothstep(0.2, 0.55, tW),
      smoothstep(0.55, 0.70, tW),
      step(0.55, tW)
    );
    vWarpFade = 1.0 - clamp(alphaMul, 0.0, 1.0);
  }
  
  // Pass fluid data to fragment shader
  vSpeed = length(vel);
  vDensity = density;
  vPressure = pressure;
  
  // ===== EXPLOSION EFFECT - GENTLER BLOOM =====
if (uExplosionActive > 0.5) {
  // Timing: 0-20% windup, 20-40% burst, 40-70% float, 70-100% return
  float rotatePhase = smoothstep(0.0, 0.2, uExplosionProgress);
  float burstPhase = smoothstep(0.2, 0.4, uExplosionProgress);
  float floatPhase = smoothstep(0.4, 0.7, uExplosionProgress);
  float returnPhase = smoothstep(0.7, 1.0, uExplosionProgress);
  
  // Softer easing
  float burstEased = burstPhase * burstPhase;
  float returnEased = returnPhase * returnPhase * (3.0 - 2.0 * returnPhase);
  
  vec3 originalPos = pos;
  
  // Gentle rotation (15 degrees max, was 28)
  float windupRotation = rotatePhase * 0.26;
  float cosR = cos(windupRotation);
  float sinR = sin(windupRotation);
  pos = vec3(
    pos.x * cosR - pos.z * sinR,
    pos.y,
    pos.x * sinR + pos.z * cosR
  );
  
  // REDUCED scatter distance
  float scatterDist = (random(seed + 3.0) * 0.4 + 0.3) * 15.0;  // Was 25.0 → 40% smaller
  
  vec3 scatterDir = vec3(
    cos(random(seed + 1.0) * 6.28) * cos(random(seed + 2.0) * 3.14 - 1.57),
    sin(random(seed + 2.0) * 3.14 - 1.57),
    sin(random(seed + 1.0) * 6.28) * cos(random(seed + 2.0) * 3.14 - 1.57)
  );
  
  float burstActive = burstEased * (1.0 - returnEased);
  pos += scatterDir * scatterDist * burstActive;
  
  // CALMER float motion
  float slowTime = uTime * 0.1;  // Was 0.2 → half speed
  float floatActive = burstActive * (1.0 - returnPhase);
  
  pos.x += sin(slowTime + seed * 2.0) * 0.8 * floatActive;  // Was 1.5
  pos.y += cos(slowTime * 0.6 + seed * 1.5) * 0.6 * floatActive;  // Was 1.2
  pos.z += sin(slowTime * 0.4 + seed) * 0.4 * floatActive;  // Was 0.8
  
  // Smooth reassembly
  pos = mix(pos, originalPos, returnEased);
  
  // Viewport clamp
  pos.x = clamp(pos.x, -36.0, 36.0);
  pos.y = clamp(pos.y, -18.0, 18.0);
  pos.z = clamp(pos.z, -28.0, 28.0);
}
  
  // ===== TEXT COLLISION AVOIDANCE =====
  vec2 collisionForce = vec2(0.0);
  
  for (int i = 0; i < 32; i++) {
    if (i >= uTextZoneCount) break;
    
    vec2 toZone = pos.xy - uTextZoneCenters[i];
    float dist = length(toZone);
    
    float effectiveRadius = uTextZoneRadii[i] * 1.15;
    
    if (dist < effectiveRadius && dist > 0.001) {
      float normalizedDist = dist / effectiveRadius;
      float forceMagnitude = pow(1.0 - normalizedDist, 3.0) * 0.5;
      
      vec2 repulsion = normalize(toZone) * forceMagnitude;
      collisionForce += repulsion;
    }
  }
  
  pos.xy += collisionForce;
  
  // ===== ORGANIC MOTION (Standard mode only) =====
  if (uUseDirectGPU < 0.5) {
    float timeOffset = uTime * uMotionSpeed;
    
    float noiseX = fbm(vec2(seed * 10.0, timeOffset * 0.3)) - 0.5;
    float noiseY = fbm(vec2(seed * 10.0 + 100.0, timeOffset * 0.3)) - 0.5;
    float noiseZ = fbm(vec2(seed * 10.0 + 200.0, timeOffset * 0.2)) - 0.5;
    
    pos.x += noiseX * uRandom * uTurbulence;
    pos.y += noiseY * uRandom * uTurbulence;
    
    // Z-depth oscillation
    float zWave = sin(timeOffset * uWaveFrequency + seed * 6.283) * 0.5 + 0.5;
    float zOffset = (noiseZ * 2.0 + zWave - 0.5) * uDepth;
    pos.z += zOffset;
  }
  
  // ===== VOICE REACTIVITY =====
  float voiceIntensity = uVoiceAmplitude;
  vVoiceGlow = voiceIntensity;
  
  // Z-extrusion
  float voiceZ = voiceIntensity * 25.0 * (rnd * 0.6 + 0.4);
  pos.z += voiceZ;
  
  // Radial displacement
  float radialForce = voiceIntensity * 12.0 * rnd;
  pos.x += cos(angle) * radialForce;
  pos.y += sin(angle) * radialForce;
  
  // ===== POINTER INFLUENCE =====
  if (uPointerInfluence > 0.01) {
    vec2 toPointer = uPointer * 30.0 - pos.xy;
    float pointerDist = length(toPointer);
    
    if (pointerDist < 15.0 && pointerDist > 0.1) {
      float pointerForce = (1.0 - pointerDist / 15.0) * uPointerInfluence * 2.0;
      pos.xy -= normalize(toPointer) * pointerForce;
    }
  }
  
  // ===== PASS COLOR =====
  vColor = color;
  
  // ===== ALPHA CALCULATION =====
  float depthFade = 1.0 - smoothstep(-25.0, 35.0, pos.z) * 0.25;
  float explosionFade = uExplosionActive > 0.5 ? (0.7 + 0.3 * (1.0 - uExplosionProgress)) : 1.0;
  
  // In GPU mode, factor in velocity and density
  float speedAlpha = 1.0;
  float densityAlpha = 1.0;
  
  if (uUseDirectGPU > 0.5) {
    speedAlpha = 0.7 + vSpeed * 0.025;
    densityAlpha = 0.85 + (density / max(uRestDensity, 1.0)) * 0.15;
    speedAlpha = clamp(speedAlpha, 0.6, 1.0);
    densityAlpha = clamp(densityAlpha, 0.7, 1.0);
  }
  
  vAlpha = depthFade * explosionFade * particleActive * speedAlpha * densityAlpha;
  vDepth = pos.z;
  
  // ===== FINAL PROJECTION =====
  vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
  gl_Position = projectionMatrix * mvPosition;
  
  // ===== PARTICLE SIZE =====
  float size = uSize;
  
  // Breathing pulse
  float pulse = 0.92 + 0.08 * sin(uTime * 1.8 + pindex * 0.15);
  size *= pulse;
  
  // Voice scale boost
  float voiceScale = 1.0 + voiceIntensity * 0.7;
  size *= voiceScale;
  
  // Explosion size variation
  if (uExplosionActive > 0.5) {
    float explosionSize = 1.0 + uExplosionProgress * 0.5 * (1.0 - uExplosionProgress * 0.8);
    size *= explosionSize;
  }
  
  // GPU mode: density and speed affect size
  if (uUseDirectGPU > 0.5) {
    float densitySize = 1.0 + (density / max(uRestDensity, 1.0) - 1.0) * 0.25;
    densitySize = clamp(densitySize, 0.75, 1.4);
    size *= densitySize;
    
    float speedSize = 1.0 + vSpeed * 0.02;
    speedSize = clamp(speedSize, 1.0, 1.3);
    size *= speedSize;
  }
  
  // Depth-based sizing
  float depthScale = 1.0 - smoothstep(-15.0, 25.0, pos.z) * 0.35;
  size *= depthScale;
  
  // Perspective scaling
  gl_PointSize = size * (350.0 / -mvPosition.z);
  gl_PointSize = clamp(gl_PointSize, 1.0, 80.0);
}
`;
window.PARTICLE_MORPH_FRAG = `/**
 * particle-morph.frag
 * ShockwaveHQ — Enhanced Particle Fragment Shader
 * 
 * Renders particles with:
 * - Circular shape with soft edges
 * - Central glow effect (bloom-ready)
 * - Voice-reactive brightness boost
 * - Industry color support
 * - Explosion state visual feedback
 */

precision highp float;

// ===== VARYINGS (from vertex shader) =====
varying vec3 vColor;
varying float vAlpha;
varying float vDepth;
varying float vVoiceGlow;
varying float vWarpFade;
varying float vWarpGlow;

// ===== UNIFORMS =====
uniform float uTime;
uniform float uExplosionActive;
uniform float uExplosionProgress;

// ===== MAIN SHADER =====
void main() {
  vec2 uv = gl_PointCoord;
  float dist = length(uv - vec2(0.5));
  
  if (dist > 0.5) discard;
  
  // SOFTER edge
  float softEdge = 1.0 - smoothstep(0.25, 0.5, dist);  // Was 0.2 → tighter
  
  // TIGHTER glow (less bloom pollution)
  float glow = pow(1.0 - smoothstep(0.0, 0.25, dist), 3.0);  // Was 2.5 power, 0.3 radius
  
  vec3 baseColor = vColor;

  // Warp charge glow
baseColor += vec3(0.25) * vWarpGlow;
  
  // MINIMAL voice brightness
  baseColor += vVoiceGlow * 0.15;  // Was 0.4 → 62% dimmer
  
  // DIM glow overlay
  baseColor += vec3(0.18) * glow;          // dimmer core
float alpha = softEdge * vAlpha + glow * 0.10;
alpha += vVoiceGlow * 0.04;              // less voice punch
alpha = clamp(alpha, 0.0, 0.95);
alpha *= (1.0 - clamp(vWarpFade, 0.0, 1.0));
  
  gl_FragColor = vec4(baseColor, alpha);
}
`;
window.RING_DEPTH_VERT = ``;
window.EMMA_HOLO_FRAG = `/**
 * emma-holo.frag
 * ShockwaveHQ — Emma Holographic Avatar Fragment Shader
 * 
 * Creates elite holographic AI assistant effect:
 * - Fresnel rim lighting (bright edges)
 * - Multi-layer scan lines (scrolling)
 * - Holographic noise/interference
 * - Voice-reactive pulsing and glow
 * - Industry color adaptation
 * - Glitch effects on voice peaks
 */

precision highp float;

// ===== UNIFORMS =====
uniform float uTime;
uniform float uVoiceAmplitude;
uniform vec3 uColor;
uniform vec3 uScanLineColor;
uniform float uOpacity;
uniform float uScanLineSpeed;
uniform float uGlowIntensity;
uniform float uIndustryHue;      // 0-1 hue shift for industry

// ===== VARYINGS (from vertex shader) =====
varying vec3 vNormal;
varying vec3 vPosition;
varying vec2 vUv;
varying vec3 vWorldPosition;

// ===== HELPER FUNCTIONS =====

float random(vec2 st) {
  return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

float noise(vec2 st) {
  vec2 i = floor(st);
  vec2 f = fract(st);
  
  float a = random(i);
  float b = random(i + vec2(1.0, 0.0));
  float c = random(i + vec2(0.0, 1.0));
  float d = random(i + vec2(1.0, 1.0));
  
  vec2 u = f * f * (3.0 - 2.0 * f);
  
  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

// RGB to HSV conversion
vec3 rgb2hsv(vec3 c) {
  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
  vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
  vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
  float d = q.x - min(q.w, q.y);
  float e = 1.0e-10;
  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

// HSV to RGB conversion
vec3 hsv2rgb(vec3 c) {
  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

// ===== MAIN SHADER =====
void main() {
  // ===== FRESNEL RIM LIGHTING =====
  vec3 viewDirection = normalize(cameraPosition - vWorldPosition);
  float NdotV = max(dot(viewDirection, vNormal), 0.0);
  
  // Multi-layer fresnel for richer rim
  float fresnel = pow(1.0 - NdotV, 3.5);
  float innerFresnel = pow(1.0 - NdotV, 1.8) * 0.35;
  float coreGlow = pow(NdotV, 2.0) * 0.2;
  
  // ===== SCAN LINES (PRIMARY) =====
  float scanLineFreq = 25.0;
  float scanLineY = vPosition.y * scanLineFreq - uTime * uScanLineSpeed;
  float scanLine = sin(scanLineY) * 0.5 + 0.5;
  scanLine = smoothstep(0.35, 0.65, scanLine);
  
  // ===== SCAN LINES (SECONDARY/FINE) =====
  float fineScanFreq = 70.0;
  float fineScanY = vPosition.y * fineScanFreq - uTime * uScanLineSpeed * 0.6;
  float fineScan = sin(fineScanY) * 0.5 + 0.5;
  fineScan = smoothstep(0.42, 0.58, fineScan) * 0.2;
  
  // ===== SCAN LINES (HORIZONTAL SWEEP) =====
  float sweepLine = sin(vPosition.x * 15.0 + uTime * 1.2) * 0.5 + 0.5;
  sweepLine = smoothstep(0.6, 0.8, sweepLine) * 0.15;
  
  // ===== HORIZONTAL GLITCH LINES =====
  float glitchSeed = floor(vPosition.y * 35.0) + floor(uTime * 12.0);
  float glitchLine = step(0.96, random(vec2(glitchSeed, 0.0)));
  
  // Voice-triggered glitches
  float voiceGlitch = step(0.85, uVoiceAmplitude) * step(0.9, random(vec2(uTime * 50.0, vPosition.y * 20.0)));
  glitchLine = max(glitchLine, voiceGlitch) * 0.4;
  
  // ===== HOLOGRAPHIC NOISE =====
  vec2 noiseUV = vUv * 25.0 + uTime * 0.4;
  float holoNoise = noise(noiseUV) * 0.12;
  
  // Chromatic aberration amount
  float chromaOffset = sin(vPosition.y * 60.0 + uTime * 4.0) * 0.025;
  chromaOffset += uVoiceAmplitude * 0.02;
  
  // ===== VOICE REACTIVITY =====
  float voicePulse = 1.0 + uVoiceAmplitude * 0.6;
  float voiceGlow = uVoiceAmplitude * uGlowIntensity * 1.2;
  float voiceScanBoost = uVoiceAmplitude * 0.35;
  
  // Pulsing ring effect when speaking
  float voiceRing = 0.0;
  if (uVoiceAmplitude > 0.1) {
    float ringDist = abs(length(vPosition.xy) - 0.5 - uVoiceAmplitude * 0.3);
    voiceRing = (1.0 - smoothstep(0.0, 0.15, ringDist)) * uVoiceAmplitude * 0.3;
  }
  
  // ===== COMBINE SCAN LINES =====
  float totalScanLine = scanLine * 0.55 + fineScan + sweepLine + glitchLine;
  totalScanLine *= (1.0 + voiceScanBoost);
  
  // ===== COLOR CALCULATION =====
  // Apply industry hue shift
  vec3 baseHSV = rgb2hsv(uColor);
  baseHSV.x = fract(baseHSV.x + uIndustryHue);
  vec3 industryColor = hsv2rgb(baseHSV);
  
  // Base with fresnel
  vec3 baseColor = industryColor * (0.25 + fresnel * 0.75 + innerFresnel + coreGlow);
  
  // Scan line color blend
  vec3 scanHSV = rgb2hsv(uScanLineColor);
  scanHSV.x = fract(scanHSV.x + uIndustryHue * 0.5);
  vec3 industryScanColor = hsv2rgb(scanHSV);
  vec3 scanColor = mix(baseColor, industryScanColor, totalScanLine * 0.45);
  
  // Voice glow
  vec3 glowAddition = industryColor * voiceGlow;
  
  // Voice ring
  vec3 ringAddition = vec3(voiceRing);
  
  // Holographic noise
  vec3 noiseAddition = vec3(holoNoise) * 0.4;
  
  // Combine
  vec3 finalColor = scanColor + glowAddition + ringAddition + noiseAddition;
  
  // Chromatic aberration
  finalColor.r += chromaOffset * 0.6;
  finalColor.b -= chromaOffset * 0.6;
  
  // ===== ALPHA CALCULATION =====
  float alpha = fresnel * 0.65 + innerFresnel;
  alpha += totalScanLine * 0.22;
  alpha += voiceGlow * 0.35;
  alpha += voiceRing;
  
  // Base minimum
  alpha = max(alpha, 0.08);
  
  // Apply opacity and voice pulse
  alpha *= uOpacity * voicePulse;
  
  // Clamp
  alpha = clamp(alpha, 0.0, 0.92);
  
  // ===== FINAL OUTPUT =====
  gl_FragColor = vec4(finalColor, alpha);
}`;


  // Log loaded shaders
  var shaderKeys = Object.keys(window).filter(function(k) {
    return k.includes('_VERT') || k.includes('_FRAG');
  });
  console.log('[Shockwave] Shaders loaded:', shaderKeys);
})();
</script>

<!-- ═══════════════════════════════════════════════════════════════════════════
     BLOCK 3: ENHANCEMENT MODULES
     Classes that use THREE.js and shaders.
     Load order: presets → quality → morph → particles → intelligence → collision → emma
     ═══════════════════════════════════════════════════════════════════════════ -->
<script>
(function() {
  'use strict';
  if (window.__SW_THREE_FAILED__) return;

  // Verify THREE.js is available
  if (typeof THREE === 'undefined') {
    console.error('[Shockwave] THREE.js not found - skipping enhancement modules');
    return;
  }


// ═══ ENHANCEMENT MODULES ═══
// Load order: presets → quality → morph → particles → intelligence → collision → emma


// ─── industry-presets.js (Industry color/motion presets) ───
/**
 * industry-presets.js
 * ShockwaveHQ — Industry-Specific Visual Profiles
 * 
 * Defines color palettes, motion patterns, word banks, and psychological triggers
 * for each target vertical. Includes word morphing vocabulary.
 * 
 * Dependencies: THREE.js (for Color objects)
 * 
 * Usage:
 *   const preset = INDUSTRY_PRESETS.dental;
 *   applyIndustryPreset(particleSystem, 'dental');
 *   const words = getIndustryWords('dental');
 */

(function() {
  'use strict';

  // ============================================
  // WAIT FOR THREE.JS
  // ============================================
  
  function waitForThree(callback, maxAttempts = 50) {
    let attempts = 0;
    const check = () => {
      attempts++;
      if (typeof THREE !== 'undefined') {
        callback();
      } else if (attempts < maxAttempts) {
        setTimeout(check, 100);
      } else {
        console.error('[industry-presets] THREE.js not found after 5 seconds');
      }
    };
    check();
  }

  // ============================================
  // WORD BANKS FOR MORPHING
  // ============================================

  const INDUSTRY_WORDS = {
    dental: ['SMILE', 'CARE', 'GLOW', 'TRUST', 'CLEAN', 'HAPPY'],
    hvac: ['COOL', 'WARM', 'HOME', 'COMFORT', 'SAVE', 'RELAX'],
    legal: ['WIN', 'FIGHT', 'JUSTICE', 'HELP', 'TRUST', 'POWER'],
    plumbing: ['FLOW', 'FIX', 'FAST', 'SAFE', 'HOME', 'TRUST'],
    medspa: ['GLOW', 'BEAUTY', 'YOUTH', 'SHINE', 'RELAX', 'RENEW'],
    pest: ['SAFE', 'CLEAN', 'HOME', 'GUARD', 'FREE', 'PEACE']
  };

  // Track current word index per industry
  const wordIndices = {
    dental: 0,
    hvac: 0,
    legal: 0,
    plumbing: 0,
    medspa: 0,
    pest: 0
  };

  /**
   * Get next word for industry (cycles through list)
   */
  function getNextWord(industryKey) {
    const key = normalizeIndustryKey(industryKey);
    const words = INDUSTRY_WORDS[key] || INDUSTRY_WORDS.dental;
    
    const word = words[wordIndices[key] || 0];
    wordIndices[key] = ((wordIndices[key] || 0) + 1) % words.length;
    
    return word;
  }

  /**
   * Get all words for industry
   */
  function getIndustryWords(industryKey) {
    const key = normalizeIndustryKey(industryKey);
    return INDUSTRY_WORDS[key] || INDUSTRY_WORDS.dental;
  }

  /**
   * Reset word index for industry
   */
  function resetWordIndex(industryKey) {
    const key = normalizeIndustryKey(industryKey);
    wordIndices[key] = 0;
  }

  /**
   * Normalize industry key (handle aliases)
   */
  function normalizeIndustryKey(key) {
    if (!key) return 'dental';
    const k = String(key).toLowerCase().trim();
    if (k === 'law') return 'legal';
    if (k === 'med spa' || k === 'med-spa') return 'medspa';
    if (k === 'pest control' || k === 'pestcontrol') return 'pest';
    return k;
  }

  // ============================================
  // INDUSTRY PRESET DEFINITIONS
  // ============================================

  function createPresets() {
    const INDUSTRY_PRESETS = {
      
      // ========================================
      // DENTAL - Calming, Anxiety-Reducing
      // ========================================
      dental: {
        name: 'Dental',
        key: 'dental',
        
        colors: {
          primary: new THREE.Color(0xff6b9b),
          secondary: new THREE.Color(0xffc6e0),
          accent: new THREE.Color(0x7C3AED),
          glow: new THREE.Color(0xff8fb3),
          ring: new THREE.Color(0xd946ef)
        },
        
        motion: {
          type: 'orbital',
          speed: 0.3,
          randomness: 0.5,
          depthOscillation: 1.5,
          waveFrequency: 1.0,
          turbulence: 0.25
        },
        
        morphTargets: ['tooth', 'sparkle'],
        defaultMorph: 'tooth',
        iconShape: 'dental',
        
        words: INDUSTRY_WORDS.dental,
        
        psychology: 'calming',
        
        voiceResponse: {
          amplitudeMultiplier: 0.8,
          expansionRadius: 10,
          zExtrusion: 18,
          pulseSpeed: 0.8
        },
        
        emma: {
          color: new THREE.Color(0xff6b9b),
          glowIntensity: 0.65,
          scanLineSpeed: 4.0,
          orbitSpeed: 0.4,
          hueShift: 0.0
        },
        
        rings: {
          color: new THREE.Color(0xd946ef),
          layerCount: 8,
          maxScale: 20,
          duration: 1400,
          tiltAmount: 0.25
        }
      },

      // ========================================
      // HVAC - Warmth, Comfort
      // ========================================
      hvac: {
        name: 'HVAC',
        key: 'hvac',
        
        colors: {
          primary: new THREE.Color(0xff7a3c),
          secondary: new THREE.Color(0xffb380),
          accent: new THREE.Color(0x00B4D8),
          glow: new THREE.Color(0xff9a5c),
          ring: new THREE.Color(0xf97316)
        },
        
        motion: {
          type: 'radial-wave',
          speed: 0.5,
          randomness: 0.8,
          depthOscillation: 2.5,
          waveFrequency: 2.0,
          turbulence: 0.55
        },
        
        morphTargets: ['thermostat', 'wave-ring'],
        defaultMorph: 'thermostat',
        iconShape: 'hvac',
        
        words: INDUSTRY_WORDS.hvac,
        
        psychology: 'comfort',
        
        voiceResponse: {
          amplitudeMultiplier: 1.0,
          expansionRadius: 14,
          zExtrusion: 22,
          pulseSpeed: 1.0
        },
        
        emma: {
          color: new THREE.Color(0xff7a3c),
          glowIntensity: 0.8,
          scanLineSpeed: 5.0,
          orbitSpeed: 0.5,
          hueShift: 0.08
        },
        
        rings: {
          color: new THREE.Color(0xf97316),
          layerCount: 8,
          maxScale: 22,
          duration: 1200,
          tiltAmount: 0.3
        }
      },

      // ========================================
      // LEGAL - Trust, Authority, Precision
      // ========================================
      legal: {
        name: 'Legal',
        key: 'legal',
        
        colors: {
          primary: new THREE.Color(0x7da8ff),
          secondary: new THREE.Color(0xb3d1ff),
          accent: new THREE.Color(0x1E40AF),
          glow: new THREE.Color(0x93c5fd),
          ring: new THREE.Color(0x3b82f6)
        },
        
        motion: {
          type: 'geometric-grid',
          speed: 0.4,
          randomness: 0.25,
          depthOscillation: 1.0,
          waveFrequency: 1.5,
          turbulence: 0.15
        },
        
        morphTargets: ['gavel', 'scales'],
        defaultMorph: 'gavel',
        iconShape: 'legal',
        
        words: INDUSTRY_WORDS.legal,
        
        psychology: 'authority',
        
        voiceResponse: {
          amplitudeMultiplier: 0.7,
          expansionRadius: 8,
          zExtrusion: 14,
          pulseSpeed: 0.7
        },
        
        emma: {
          color: new THREE.Color(0x7da8ff),
          glowIntensity: 0.55,
          scanLineSpeed: 3.5,
          orbitSpeed: 0.35,
          hueShift: 0.58
        },
        
        rings: {
          color: new THREE.Color(0x3b82f6),
          layerCount: 8,
          maxScale: 18,
          duration: 1500,
          tiltAmount: 0.2
        }
      },

      // ========================================
      // PLUMBING - Flow, Reliability
      // ========================================
      plumbing: {
        name: 'Plumbing',
        key: 'plumbing',
        
        colors: {
          primary: new THREE.Color(0xef5e5e),
          secondary: new THREE.Color(0x00B4D8),
          accent: new THREE.Color(0x7C3AED),
          glow: new THREE.Color(0x22d3ee),
          ring: new THREE.Color(0x06b6d4)
        },
        
        motion: {
          type: 'fluid-vortex',
          speed: 0.6,
          randomness: 1.0,
          depthOscillation: 3.0,
          waveFrequency: 2.5,
          turbulence: 0.8
        },
        
        morphTargets: ['wrench', 'droplet'],
        defaultMorph: 'wrench',
        iconShape: 'plumbing',
        
        words: INDUSTRY_WORDS.plumbing,
        
        psychology: 'flow',
        
        voiceResponse: {
          amplitudeMultiplier: 1.2,
          expansionRadius: 16,
          zExtrusion: 26,
          pulseSpeed: 1.2
        },
        
        emma: {
          color: new THREE.Color(0x00B4D8),
          glowIntensity: 0.9,
          scanLineSpeed: 6.0,
          orbitSpeed: 0.6,
          hueShift: 0.52
        },
        
        rings: {
          color: new THREE.Color(0x06b6d4),
          layerCount: 8,
          maxScale: 24,
          duration: 1100,
          tiltAmount: 0.35
        }
      },

      // ========================================
      // MEDSPA - Luxury, Relaxation
      // ========================================
      medspa: {
        name: 'Medical Spa',
        key: 'medspa',
        
        colors: {
          primary: new THREE.Color(0xff6b9b),
          secondary: new THREE.Color(0xffd4e8),
          accent: new THREE.Color(0xC166D8),
          glow: new THREE.Color(0xf0abfc),
          ring: new THREE.Color(0xe879f9)
        },
        
        motion: {
          type: 'floating-ambient',
          speed: 0.25,
          randomness: 0.4,
          depthOscillation: 1.8,
          waveFrequency: 0.8,
          turbulence: 0.18
        },
        
        morphTargets: ['sparkle', 'lotus'],
        defaultMorph: 'sparkle',
        iconShape: 'medspa',
        
        words: INDUSTRY_WORDS.medspa,
        
        psychology: 'luxury',
        
        voiceResponse: {
          amplitudeMultiplier: 0.6,
          expansionRadius: 10,
          zExtrusion: 12,
          pulseSpeed: 0.6
        },
        
        emma: {
          color: new THREE.Color(0xC166D8),
          glowIntensity: 0.55,
          scanLineSpeed: 3.0,
          orbitSpeed: 0.3,
          hueShift: 0.85
        },
        
        rings: {
          color: new THREE.Color(0xe879f9),
          layerCount: 8,
          maxScale: 18,
          duration: 1600,
          tiltAmount: 0.2
        }
      },

      // ========================================
      // PEST CONTROL - Protection, Transformation
      // ========================================
      pest: {
        name: 'Pest Control',
        key: 'pest',
        
        colors: {
          primary: new THREE.Color(0xff8b8b),
          secondary: new THREE.Color(0x22c55e),
          accent: new THREE.Color(0x7C3AED),
          glow: new THREE.Color(0x4ade80),
          ring: new THREE.Color(0x22c55e)
        },
        
        motion: {
          type: 'dispersing-swarm',
          speed: 0.7,
          randomness: 1.2,
          depthOscillation: 2.0,
          waveFrequency: 3.0,
          turbulence: 0.9
        },
        
        morphTargets: ['shield', 'checkmark'],
        defaultMorph: 'shield',
        iconShape: 'pest',
        
        words: INDUSTRY_WORDS.pest,
        
        psychology: 'transformation',
        
        voiceResponse: {
          amplitudeMultiplier: 1.1,
          expansionRadius: 15,
          zExtrusion: 24,
          pulseSpeed: 1.1
        },
        
        emma: {
          color: new THREE.Color(0x22c55e),
          glowIntensity: 0.85,
          scanLineSpeed: 5.5,
          orbitSpeed: 0.55,
          hueShift: 0.33
        },
        
        rings: {
          color: new THREE.Color(0x22c55e),
          layerCount: 8,
          maxScale: 22,
          duration: 1000,
          tiltAmount: 0.3
        }
      }
    };

    return INDUSTRY_PRESETS;
  }

  // ============================================
  // PRESET APPLICATION
  // ============================================

  /**
   * Apply industry preset to particle system
   */
  function applyIndustryPreset(particleSystem, industryKey) {
    if (!window.INDUSTRY_PRESETS) {
      console.error('[industry-presets] Presets not initialized');
      return false;
    }

    const key = normalizeIndustryKey(industryKey);
    const preset = window.INDUSTRY_PRESETS[key];
    
    if (!preset) {
      console.warn(`[industry-presets] Preset "${key}" not found, using dental`);
      return applyIndustryPreset(particleSystem, 'dental');
    }
    
    if (!particleSystem || !particleSystem.particles) {
      console.error('[industry-presets] Invalid particle system');
      return false;
    }

    const particles = particleSystem.particles;
    const geometry = particles.geometry;
    const material = particles.material;

    // Update particle colors
    if (geometry.attributes.color) {
      const colors = geometry.attributes.color.array;
      const colorPalette = [
        preset.colors.primary,
        preset.colors.secondary,
        preset.colors.accent
      ];
      
      const particleCount = colors.length / 3;
      
      for (let i = 0; i < particleCount; i++) {
        const rand = Math.random();
        let color;
        if (rand < 0.5) {
          color = colorPalette[0];
        } else if (rand < 0.8) {
          color = colorPalette[1];
        } else {
          color = colorPalette[2];
        }
        
        colors[i * 3] = color.r;
        colors[i * 3 + 1] = color.g;
        colors[i * 3 + 2] = color.b;
      }
      geometry.attributes.color.needsUpdate = true;
    }
    
    // Update motion parameters
    if (material.uniforms) {
      if (material.uniforms.uRandom) {
        material.uniforms.uRandom.value = preset.motion.randomness;
      }
      if (material.uniforms.uDepth) {
        material.uniforms.uDepth.value = preset.motion.depthOscillation;
      }
      if (material.uniforms.uMotionSpeed) {
        material.uniforms.uMotionSpeed.value = preset.motion.speed;
      }
      if (material.uniforms.uTurbulence) {
        material.uniforms.uTurbulence.value = preset.motion.turbulence;
      }
      if (material.uniforms.uWaveFrequency) {
        material.uniforms.uWaveFrequency.value = preset.motion.waveFrequency;
      }
    }
    
    // Store config on particle system
    particleSystem.motionType = preset.motion.type;
    particleSystem.motionSpeed = preset.motion.speed;
    particleSystem.motionConfig = Object.assign({}, preset.motion);
    particleSystem.voiceConfig = Object.assign({}, preset.voiceResponse);
    particleSystem.currentPreset = preset;
    particleSystem.currentIndustry = key;
    
    // Reset word index for this industry
    resetWordIndex(key);
    
    // Dispatch event
    window.dispatchEvent(new CustomEvent('sw:industryPresetApplied', {
      detail: { industry: key, preset: preset }
    }));
    
    return true;
  }

  // ============================================
  // INDUSTRY DETECTION
  // ============================================

  function detectIndustry() {
    // URL parameter
    try {
      const urlParams = new URLSearchParams(window.location.search);
      const urlIndustry = urlParams.get('industry');
      if (urlIndustry && window.INDUSTRY_PRESETS) {
        const key = normalizeIndustryKey(urlIndustry);
        if (window.INDUSTRY_PRESETS[key]) {
          return key;
        }
      }
    } catch (e) {}
    
    // Data attribute
    try {
      const demoSection = document.querySelector('[data-sw-industry], [data-industry]');
      if (demoSection) {
        const dataIndustry = demoSection.getAttribute('data-sw-industry') || 
                            demoSection.getAttribute('data-industry');
        if (dataIndustry && window.INDUSTRY_PRESETS) {
          const key = normalizeIndustryKey(dataIndustry);
          if (window.INDUSTRY_PRESETS[key]) {
            return key;
          }
        }
      }
    } catch (e) {}
    
    // Demo state
    try {
      if (window.ShockwaveLiveDemo && window.ShockwaveLiveDemo.currentIndustry) {
        const key = normalizeIndustryKey(window.ShockwaveLiveDemo.currentIndustry);
        if (window.INDUSTRY_PRESETS && window.INDUSTRY_PRESETS[key]) {
          return key;
        }
      }
    } catch (e) {}
    
    return 'dental';
  }

  // ============================================
  // UTILITY FUNCTIONS
  // ============================================

  function getAvailableIndustries() {
    if (!window.INDUSTRY_PRESETS) return [];
    return Object.keys(window.INDUSTRY_PRESETS);
  }

  function getPreset(industryKey) {
    if (!window.INDUSTRY_PRESETS) return null;
    const key = normalizeIndustryKey(industryKey);
    return window.INDUSTRY_PRESETS[key] || window.INDUSTRY_PRESETS.dental || null;
  }

  function mapIndustryToIconShape(industryKey) {
    const key = normalizeIndustryKey(industryKey);
    const preset = window.INDUSTRY_PRESETS ? window.INDUSTRY_PRESETS[key] : null;
    return preset ? preset.iconShape : key;
  }

  // ============================================
  // INITIALIZATION
  // ============================================

  function initialize() {
    window.INDUSTRY_PRESETS = createPresets();
    window.INDUSTRY_WORDS = INDUSTRY_WORDS;
    
    // Export functions
    window.applyIndustryPreset = applyIndustryPreset;
    window.detectIndustry = detectIndustry;
    window.getAvailableIndustries = getAvailableIndustries;
    window.getPreset = getPreset;
    window.getNextWord = getNextWord;
    window.getIndustryWords = getIndustryWords;
    window.resetWordIndex = resetWordIndex;
    window.mapIndustryToIconShape = mapIndustryToIconShape;
    window.normalizeIndustryKey = normalizeIndustryKey;
    
    window.dispatchEvent(new CustomEvent('sw:industryPresetsReady'));
  }

  waitForThree(initialize);

})();

// ─── adaptive-quality.js (FPS monitoring + auto quality adjustment) ───
/**
 * adaptive-quality.js
 * ShockwaveHQ — Adaptive Quality & Performance System
 * 
 * Monitors FPS and automatically adjusts particle count, effects,
 * and render quality to maintain smooth 60fps experience.
 * 
 * Features:
 * - Real-time FPS monitoring with rolling average
 * - Automatic quality tier adjustment (Ultra → High → Medium → Low → Potato)
 * - Particle count scaling
 * - Effect intensity scaling (bloom, shadows, post-processing)
 * - Device capability detection
 * - Battery-aware throttling (mobile)
 * - Memory pressure handling
 * 
 * Dependencies: None (standalone)
 * 
 * Usage:
 *   const quality = new AdaptiveQualitySystem();
 *   quality.start();
 *   const settings = quality.getCurrentSettings();
 */


(function() {
  'use strict';


  // ============================================
  // QUALITY TIER DEFINITIONS
  // ============================================


  const QUALITY_TIERS = {
    ultra: {
      name: 'Ultra',
      particleMultiplier: 1.0,
      bloomEnabled: true,
      bloomStrength: 0.75,
      bloomRadius: 0.4,
      shadowsEnabled: true,
      postProcessing: true,
      textureQuality: 1.0,
      maxParticles: 2000,
      ringLayers: 8,
      emmaEnabled: true,
      emmaDetail: 'high',
      antialias: true,
      pixelRatio: null, // Use device default (capped at 2)
      targetFPS: 60,
      morphQuality: 'high',
      collisionPrecision: 'high'
    },
    high: {
      name: 'High',
      particleMultiplier: 0.85,
      bloomEnabled: true,
      bloomStrength: 0.6,
      bloomRadius: 0.35,
      shadowsEnabled: true,
      postProcessing: true,
      textureQuality: 0.9,
      maxParticles: 1600,
      ringLayers: 7,
      emmaEnabled: true,
      emmaDetail: 'high',
      antialias: true,
      pixelRatio: null,
      targetFPS: 60,
      morphQuality: 'high',
      collisionPrecision: 'high'
    },
    medium: {
      name: 'Medium',
      particleMultiplier: 0.65,
      bloomEnabled: true,
      bloomStrength: 0.45,
      bloomRadius: 0.3,
      shadowsEnabled: false,
      postProcessing: true,
      textureQuality: 0.75,
      maxParticles: 1200,
      ringLayers: 6,
      emmaEnabled: true,
      emmaDetail: 'medium',
      antialias: false,
      pixelRatio: 1.5,
      targetFPS: 55,
      morphQuality: 'medium',
      collisionPrecision: 'medium'
    },
    low: {
      name: 'Low',
      particleMultiplier: 0.45,
      bloomEnabled: false,
      bloomStrength: 0,
      bloomRadius: 0,
      shadowsEnabled: false,
      postProcessing: false,
      textureQuality: 0.5,
      maxParticles: 800,
      ringLayers: 4,
      emmaEnabled: true,
      emmaDetail: 'low',
      antialias: false,
      pixelRatio: 1.0,
      targetFPS: 45,
      morphQuality: 'low',
      collisionPrecision: 'low'
    },
    potato: {
      name: 'Potato',
      particleMultiplier: 0.25,
      bloomEnabled: false,
      bloomStrength: 0,
      bloomRadius: 0,
      shadowsEnabled: false,
      postProcessing: false,
      textureQuality: 0.25,
      maxParticles: 400,
      ringLayers: 2,
      emmaEnabled: false,
      emmaDetail: 'none',
      antialias: false,
      pixelRatio: 1.0,
      targetFPS: 30,
      morphQuality: 'low',
      collisionPrecision: 'low'
    }
  };


  // Tier order for stepping up/down
  const TIER_ORDER = ['potato', 'low', 'medium', 'high', 'ultra'];


  // ============================================
  // CONFIGURATION
  // ============================================


  const CONFIG = {
    // FPS monitoring
    fpsHistoryLength: 60,           // Frames to average
    fpsSampleInterval: 100,         // ms between samples
    fpsUpdateInterval: 500,         // ms between tier checks
    
    // Tier adjustment thresholds
    downgradeThreshold: 45,         // FPS below this triggers downgrade
    upgradeThreshold: 58,           // FPS above this for upgradeDelay triggers upgrade
    criticalThreshold: 25,          // FPS below this triggers immediate downgrade
    
    // Stability requirements
    upgradeDelay: 5000,             // ms of stable high FPS before upgrading
    downgradeDelay: 1500,           // ms of low FPS before downgrading
    criticalDowngradeDelay: 500,    // ms before critical downgrade
    
    // Limits
    minTier: 'potato',
    maxTier: 'ultra',
    
    // Mobile detection
    mobileMaxTier: 'medium',
    lowPowerMaxTier: 'low',
    
    // Debug
    debug: false
  };


  // ============================================
  // ADAPTIVE QUALITY SYSTEM CLASS
  // ============================================


  class AdaptiveQualitySystem {
    constructor(options = {}) {
      // Merge options
      this.config = Object.assign({}, CONFIG, options);
      
      // State
      this.currentTier = 'high';
      this.currentSettings = Object.assign({}, QUALITY_TIERS.high);
      this.isRunning = false;
      this.isLocked = false;
      this.lockReason = null;
      
      // FPS tracking
      this.fpsHistory = [];
      this.lastFrameTime = 0;
      this.frameCount = 0;
      this.currentFPS = 60;
      this.averageFPS = 60;
      
      // Tier change tracking
      this.lastTierChange = 0;
      this.stableHighFPSSince = 0;
      this.stableLowFPSSince = 0;
      this.tierChangeCount = 0;
      
      // Timers
      this.sampleInterval = null;
      this.updateInterval = null;
      this.rafId = null;
      
      // Device info
      this.deviceInfo = this.detectDevice();
      
      // Callbacks
      this.onQualityChange = null;
      this.onFPSUpdate = null;
      
      // Initialize
      this.determineInitialTier();
      
      if (this.config.debug) {
        console.log('[AdaptiveQuality] Initialized', {
          device: this.deviceInfo,
          initialTier: this.currentTier
        });
      }
    }


    // ============================================
    // DEVICE DETECTION
    // ============================================


    detectDevice() {
      const info = {
        isMobile: false,
        isTablet: false,
        isLowPower: false,
        hasBattery: false,
        batteryLevel: 1,
        isCharging: true,
        gpuTier: 'unknown',
        cores: navigator.hardwareConcurrency || 4,
        memory: navigator.deviceMemory || 4,
        connection: 'unknown',
        touchscreen: false,
        reducedMotion: false
      };


      // Mobile/tablet detection
      const ua = navigator.userAgent.toLowerCase();
      info.isMobile = /android|webos|iphone|ipod|blackberry|iemobile|opera mini/i.test(ua);
      info.isTablet = /ipad|android(?!.*mobile)/i.test(ua) || 
                      (navigator.maxTouchPoints > 0 && window.innerWidth >= 768);
      
      // Touch detection
      info.touchscreen = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      
      // Reduced motion preference
      try {
        info.reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      } catch (e) {}
      
      // Low power detection (heuristics)
      info.isLowPower = info.cores <= 2 || info.memory <= 2 || 
                        (info.isMobile && window.innerWidth < 400);
      
      // Battery API (if available)
      if ('getBattery' in navigator) {
        navigator.getBattery().then(battery => {
          info.hasBattery = true;
          info.batteryLevel = battery.level;
          info.isCharging = battery.charging;
          
          // Listen for battery changes
          battery.addEventListener('levelchange', () => {
            info.batteryLevel = battery.level;
            this.handleBatteryChange(battery);
          });
          battery.addEventListener('chargingchange', () => {
            info.isCharging = battery.charging;
            this.handleBatteryChange(battery);
          });
          
          // Adjust for low battery
          if (!info.isCharging && info.batteryLevel < 0.2) {
            info.isLowPower = true;
          }
        }).catch(() => {});
      }
      
      // Connection API (if available)
      if ('connection' in navigator) {
        const conn = navigator.connection;
        info.connection = conn.effectiveType || 'unknown';
        
        // Slow connection = lower quality
        if (conn.effectiveType === '2g' || conn.effectiveType === 'slow-2g') {
          info.isLowPower = true;
        }
      }
      
      // GPU detection (rough estimate via WebGL)
      try {
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (gl) {
          const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
          if (debugInfo) {
            const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL).toLowerCase();
            
            // Tier GPU based on common patterns
            if (renderer.includes('nvidia') || renderer.includes('geforce rtx') || 
                renderer.includes('radeon rx') || renderer.includes('apple m')) {
              info.gpuTier = 'high';
            } else if (renderer.includes('intel') && !renderer.includes('hd')) {
              info.gpuTier = 'high';
            } else if (renderer.includes('intel hd') || renderer.includes('intel uhd') ||
                       renderer.includes('adreno 6') || renderer.includes('mali-g')) {
              info.gpuTier = 'medium';
            } else if (renderer.includes('adreno 5') || renderer.includes('mali-t') ||
                       renderer.includes('powervr')) {
              info.gpuTier = 'low';
            } else {
              info.gpuTier = 'medium'; // Default assumption
            }
          }
        }
      } catch (e) {}
      
      return info;
    }


    // ============================================
    // INITIAL TIER DETERMINATION
    // ============================================


    determineInitialTier() {
      let tier = 'high'; // Default
      
      // Reduced motion = low tier (respect accessibility)
      if (this.deviceInfo.reducedMotion) {
        tier = 'low';
        this.lockTier('reducedMotion');
      }
      // Low power device
      else if (this.deviceInfo.isLowPower) {
        tier = 'low';
      }
      // Mobile
      else if (this.deviceInfo.isMobile) {
        tier = 'medium';
      }
      // Tablet
      else if (this.deviceInfo.isTablet) {
        tier = 'medium';
      }
      // High-end GPU detected
      else if (this.deviceInfo.gpuTier === 'high' && this.deviceInfo.cores >= 4) {
        tier = 'ultra';
      }
      // Medium GPU
      else if (this.deviceInfo.gpuTier === 'medium') {
        tier = 'high';
      }
      // Low GPU
      else if (this.deviceInfo.gpuTier === 'low') {
        tier = 'medium';
      }
      
      // Apply mobile cap
      if (this.deviceInfo.isMobile) {
        const maxIdx = TIER_ORDER.indexOf(this.config.mobileMaxTier);
        const currentIdx = TIER_ORDER.indexOf(tier);
        if (currentIdx > maxIdx) {
          tier = this.config.mobileMaxTier;
        }
      }
      
      // Apply low power cap
      if (this.deviceInfo.isLowPower) {
        const maxIdx = TIER_ORDER.indexOf(this.config.lowPowerMaxTier);
        const currentIdx = TIER_ORDER.indexOf(tier);
        if (currentIdx > maxIdx) {
          tier = this.config.lowPowerMaxTier;
        }
      }
      
      this.setTier(tier, 'initial');
    }


    // ============================================
    // FPS MONITORING
    // ============================================


    start() {
      if (this.isRunning) return;
      this.isRunning = true;
      
      this.lastFrameTime = performance.now();
      this.frameCount = 0;
      
      // Start RAF loop for frame counting
      const countFrame = () => {
        if (!this.isRunning) return;
        this.frameCount++;
        this.rafId = requestAnimationFrame(countFrame);
      };
      this.rafId = requestAnimationFrame(countFrame);
      
      // Sample FPS periodically
      this.sampleInterval = setInterval(() => {
        this.sampleFPS();
      }, this.config.fpsSampleInterval);
      
      // Check for tier changes periodically
      this.updateInterval = setInterval(() => {
        this.evaluateTierChange();
      }, this.config.fpsUpdateInterval);
      
      if (this.config.debug) {
        console.log('[AdaptiveQuality] Started monitoring');
      }
    }


    stop() {
      this.isRunning = false;
      
      if (this.rafId) {
        cancelAnimationFrame(this.rafId);
        this.rafId = null;
      }
      
      if (this.sampleInterval) {
        clearInterval(this.sampleInterval);
        this.sampleInterval = null;
      }
      
      if (this.updateInterval) {
        clearInterval(this.updateInterval);
        this.updateInterval = null;
      }
      
      if (this.config.debug) {
        console.log('[AdaptiveQuality] Stopped monitoring');
      }
    }


    sampleFPS() {
      const now = performance.now();
      const elapsed = now - this.lastFrameTime;
      
      if (elapsed > 0) {
        // Calculate FPS from frame count
        this.currentFPS = Math.round((this.frameCount / elapsed) * 1000);
        this.currentFPS = Math.min(this.currentFPS, 120); // Cap at 120
        
        // Add to history
        this.fpsHistory.push(this.currentFPS);
        if (this.fpsHistory.length > this.config.fpsHistoryLength) {
          this.fpsHistory.shift();
        }
        
        // Calculate rolling average
        const sum = this.fpsHistory.reduce((a, b) => a + b, 0);
        this.averageFPS = Math.round(sum / this.fpsHistory.length);
        
        // Reset counters
        this.lastFrameTime = now;
        this.frameCount = 0;
        
        // Callback
        if (this.onFPSUpdate) {
          this.onFPSUpdate(this.currentFPS, this.averageFPS);
        }
      }
    }


    // NEW: Measure single frame (for external animation loops)
    measureFrame() {
      const now = performance.now();
      if (this.lastFrameTime > 0) {
        const delta = now - this.lastFrameTime;
        this.fpsHistory.push(delta > 0 ? 1000 / delta : 60);
        if (this.fpsHistory.length > this.config.fpsHistoryLength) {
          this.fpsHistory.shift();
        }
      }
      this.lastFrameTime = now;
    }


    // NEW: Alias for spec compatibility
    adjustQuality() {
      this.measureFrame();
      this.evaluateTierChange();
    }


    // ============================================
    // TIER MANAGEMENT
    // ============================================


    evaluateTierChange() {
      if (this.isLocked) return;
      
      const now = performance.now();
      const timeSinceLastChange = now - this.lastTierChange;
      const fps = this.averageFPS;
      const currentIdx = TIER_ORDER.indexOf(this.currentTier);
      
      // Critical low FPS - immediate downgrade
      if (fps < this.config.criticalThreshold && currentIdx > 0) {
        if (this.stableLowFPSSince === 0) {
          this.stableLowFPSSince = now;
        }
        
        if (now - this.stableLowFPSSince > this.config.criticalDowngradeDelay) {
          this.stepDown('critical_fps');
          this.stableLowFPSSince = 0;
          return;
        }
      }
      
      // Low FPS - consider downgrade
      if (fps < this.config.downgradeThreshold && currentIdx > 0) {
        if (this.stableLowFPSSince === 0) {
          this.stableLowFPSSince = now;
        }
        this.stableHighFPSSince = 0;
        
        if (now - this.stableLowFPSSince > this.config.downgradeDelay) {
          this.stepDown('low_fps');
          this.stableLowFPSSince = 0;
        }
      }
      // High FPS - consider upgrade
      else if (fps >= this.config.upgradeThreshold && currentIdx < TIER_ORDER.length - 1) {
        if (this.stableHighFPSSince === 0) {
          this.stableHighFPSSince = now;
        }
        this.stableLowFPSSince = 0;
        
        if (now - this.stableHighFPSSince > this.config.upgradeDelay) {
          this.stepUp('high_fps');
          this.stableHighFPSSince = 0;
        }
      }
      // Normal range - reset timers
      else {
        this.stableHighFPSSince = 0;
        this.stableLowFPSSince = 0;
      }
    }


    stepUp(reason) {
      const currentIdx = TIER_ORDER.indexOf(this.currentTier);
      
      if (currentIdx < TIER_ORDER.length - 1) {
        let newTier = TIER_ORDER[currentIdx + 1];
        
        // Apply caps
        if (this.deviceInfo.isMobile) {
          const maxIdx = TIER_ORDER.indexOf(this.config.mobileMaxTier);
          if (currentIdx + 1 > maxIdx) {
            return; // Can't upgrade past mobile cap
          }
        }
        
        if (this.deviceInfo.isLowPower) {
          const maxIdx = TIER_ORDER.indexOf(this.config.lowPowerMaxTier);
          if (currentIdx + 1 > maxIdx) {
            return; // Can't upgrade past low power cap
          }
        }
        
        this.setTier(newTier, reason);
      }
    }


    stepDown(reason) {
      const currentIdx = TIER_ORDER.indexOf(this.currentTier);
      
      if (currentIdx > 0) {
        const newTier = TIER_ORDER[currentIdx - 1];
        this.setTier(newTier, reason);
      }
    }


    setTier(tier, reason) {
      if (!QUALITY_TIERS[tier]) {
        console.warn('[AdaptiveQuality] Invalid tier:', tier);
        return;
      }
      
      const previousTier = this.currentTier;
      
      if (tier === previousTier) return;
      
      this.currentTier = tier;
      this.currentSettings = Object.assign({}, QUALITY_TIERS[tier]);
      this.lastTierChange = performance.now();
      this.tierChangeCount++;
      
      if (this.config.debug) {
        console.log('[AdaptiveQuality] Tier changed:', previousTier, '→', tier, 
                    '| Reason:', reason, '| FPS:', this.averageFPS);
      }
      
      // Dispatch event (original name)
      window.dispatchEvent(new CustomEvent('sw:qualityChange', {
        detail: {
          previousTier,
          newTier: tier,
          reason,
          settings: this.currentSettings,
          fps: this.averageFPS
        }
      }));
      
      // NEW: Dispatch spec-compatible event name
      window.dispatchEvent(new CustomEvent('quality-change', {
        detail: {
          level: tier,
          previous: previousTier,
          fps: this.averageFPS
        }
      }));
      
      // Callback
      if (this.onQualityChange) {
        this.onQualityChange(tier, this.currentSettings, reason);
      }
    }


    // ============================================
    // TIER LOCKING
    // ============================================


    lockTier(reason) {
      this.isLocked = true;
      this.lockReason = reason;
      
      if (this.config.debug) {
        console.log('[AdaptiveQuality] Tier locked:', reason);
      }
    }


    unlockTier() {
      this.isLocked = false;
      this.lockReason = null;
      
      if (this.config.debug) {
        console.log('[AdaptiveQuality] Tier unlocked');
      }
    }


    forceTier(tier, lock = false) {
      if (!QUALITY_TIERS[tier]) {
        console.warn('[AdaptiveQuality] Invalid tier:', tier);
        return;
      }
      
      this.setTier(tier, 'forced');
      
      if (lock) {
        this.lockTier('forced');
      }
    }


    // NEW: Alias for spec compatibility
    forceQuality(level) {
      // Map spec tier names to our tier names
      const tierMap = {
        'high': 'high',
        'medium': 'medium', 
        'low': 'low'
      };
      const mappedTier = tierMap[level] || level;
      this.forceTier(mappedTier, true);
    }


    // ============================================
    // BATTERY HANDLING
    // ============================================


    handleBatteryChange(battery) {
      // If on battery and low, reduce quality
      if (!battery.charging && battery.level < 0.2) {
        this.deviceInfo.isLowPower = true;
        
        // Cap to low power tier if currently higher
        const maxIdx = TIER_ORDER.indexOf(this.config.lowPowerMaxTier);
        const currentIdx = TIER_ORDER.indexOf(this.currentTier);
        
        if (currentIdx > maxIdx && !this.isLocked) {
          this.setTier(this.config.lowPowerMaxTier, 'low_battery');
        }
        
        if (this.config.debug) {
          console.log('[AdaptiveQuality] Low battery mode activated');
        }
      }
      // If charging or battery recovered
      else if (battery.charging || battery.level >= 0.3) {
        this.deviceInfo.isLowPower = this.deviceInfo.cores <= 2 || this.deviceInfo.memory <= 2;
        
        if (this.config.debug) {
          console.log('[AdaptiveQuality] Battery OK');
        }
      }
    }


    // ============================================
    // PUBLIC API
    // ============================================


    getCurrentSettings() {
      return Object.assign({}, this.currentSettings);
    }


    getCurrentTier() {
      return this.currentTier;
    }


    // NEW: Alias for spec compatibility
    get qualityLevel() {
      return this.currentTier;
    }


    // NEW: Alias for spec compatibility  
    get currentFPSValue() {
      return this.averageFPS;
    }


    getFPS() {
      return {
        current: this.currentFPS,
        average: this.averageFPS,
        history: this.fpsHistory.slice()
      };
    }


    getDeviceInfo() {
      return Object.assign({}, this.deviceInfo);
    }


        getStats() {
        return {
            tier: this.currentTier,
            fps: this.averageFPS,
            tierChanges: this.tierChangeCount,
            isLocked: this.isLocked,
            lockReason: this.lockReason,
            device: this.deviceInfo.isMobile ? 'mobile' : 
                    this.deviceInfo.isTablet ? 'tablet' : 'desktop',
            gpuTier: this.deviceInfo.gpuTier,
            // NEW: Spec-compatible fields
            quality: this.currentTier,
            particles: this.currentSettings.maxParticles,
            history: this.fpsHistory.length
        };
        }


        /**
         * Get particle count adjusted for current quality
         */
        getAdjustedParticleCount(baseCount) {
        return Math.floor(baseCount * this.currentSettings.particleMultiplier);
        }


        /**
         * Check if a feature should be enabled at current quality
         */
        isFeatureEnabled(feature) {
        switch (feature) {
            case 'bloom':
            return this.currentSettings.bloomEnabled;
            case 'shadows':
            return this.currentSettings.shadowsEnabled;
            case 'postProcessing':
            return this.currentSettings.postProcessing;
            case 'emma':
            return this.currentSettings.emmaEnabled;
            case 'antialias':
            return this.currentSettings.antialias;
            default:
            return true;
        }
        }


        // NEW: Reset method for spec compatibility
        reset() {
        this.fpsHistory = [];
        this.lastTierChange = 0;
        this.tierChangeCount = 0;
        this.stableHighFPSSince = 0;
        this.stableLowFPSSince = 0;
        this.determineInitialTier();
        }


        /**
         * Destroy and cleanup
         */
        destroy() {
        this.stop();
        this.fpsHistory = [];
        this.onQualityChange = null;
        this.onFPSUpdate = null;
        }
    }


    // ============================================
    // EXPORT
    // ============================================


    // NEW: Export with both class names for compatibility
    window.AdaptiveQualitySystem = AdaptiveQualitySystem;
    window.AdaptiveQualityManager = AdaptiveQualitySystem; // Spec alias
    window.QUALITY_TIERS = QUALITY_TIERS;
    
    // Create default instance
    window.adaptiveQuality = new AdaptiveQualitySystem({
        debug: window.SW_DEBUG_QUALITY === true
    });


    // Auto-start when DOM ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
        window.adaptiveQuality.start();
        });
    } else {
        window.adaptiveQuality.start();
    }


    // Dispatch ready event
    window.dispatchEvent(new CustomEvent('sw:adaptiveQualityReady'));

    if (window.adaptiveQuality) {
        window.adaptiveQuality.forceTier('ultra', true);
        console.log('[Quality] Locked to ULTRA for demo');
    }
    
    console.log('[AdaptiveQuality] Module loaded');


    })();


// ─── morph-engine.js (Unified shape/word morphing system (35+ shapes)) ───
/**
 * morph-engine.js
 * ShockwaveHQ — Ultimate Fluid Dynamics Morphing System v3.0
 * 
 * GPU-Accelerated SPH (Smoothed Particle Hydrodynamics) Implementation:
 * - WebGL2 Compute Shader simulation (with WebGL1 fallback)
 * - True fluid pressure, viscosity, and surface tension
 * - Density-based particle interactions
 * - Spatial hashing on GPU for O(n) neighbor queries
 * - Transform feedback for position/velocity updates
 * - Multi-stage morphing with physics integration
 * - 35+ shapes including all industry icons
 * - Full A-Z word morphing
 * 
 * Dependencies: THREE.js (r128+)
 * 
 * Usage:
 *   const engine = new MorphEngine({ particleCount: 1500, useGPU: true });
 *   engine.morphToShape(particleSystem, 'dental', { duration: 1800, fluid: true });
 *   engine.morphToWord(particleSystem, 'SMILE', { duration: 1500 });
 */

(function() {
  'use strict';

  // ============================================
  // CONFIGURATION
  // ============================================

  var CONFIG = {
   // CRITICAL: More particles = cleaner shapes
  defaultParticleCount: 2500,    // Was 1500 → 67% more particles
  mobileParticleCount: 1500,     // Was 900 → 67% more
  viewportSize: 28,
  zVariation: 4,
  
  // GPU limits (keep performance safe)
  gpuMaxParticles: 3000,         // Was 2000
  gpuRecommendedParticles: 2500,  // Was 1500
  gpuMinParticlesForBenefit: 500,  // Below this, CPU is actually faster
  
  // === ADD PERFORMANCE MONITORING ===
  performanceMonitoring: true,
  targetFrameTime: 16.67,          // 60fps target (ms)
  performanceWarningThreshold: 25, // Warn if frame exceeds this (ms)
  autoFallbackToCPU: true,         // Auto-switch to CPU if GPU struggling
  
  // Morph timing
  defaultMorphDuration: 1800,
  wordMorphDuration: 1500,
  resetDuration: 1200,
  
  // Morph stages (as percentage of total duration)
  stages: {
    gather: 0.15,
    stream: 0.55,
    settle: 0.30
  },
  
   // Letter dimensions - BIGGER = more visible
  letterWidth: 6,                // Was 5
  letterHeight: 8,               // Was 7
  letterSpacing: 1.5,            // Was 1.2 → more breathing room
  letterThickness: 1.2,          // Was 0.8 → thicker letters

    // Multiplier for particles per pixel
  particlesPerLetterPixel: 4,    // NEW: 4 particles per letter cell
  
  // SPH Parameters (Smoothed Particle Hydrodynamics)
  sph: {
    smoothingRadius: 4.0,
    restDensity: 1000.0,
    stiffness: 200.0,
    nearStiffness: 20.0,
    viscosity: 0.1,
    linearViscosity: 0.5,
    quadraticViscosity: 1.0,
    surfaceTension: 0.0728,
    gravity: { x: 0, y: 0, z: 0 },
    timeStep: 0.016,
    substeps: 2,
    boundaryDamping: 0.3,
    boundarySize: { x: 60, y: 40, z: 50 }
  },
  
  // Flow field
  flowFieldResolution: 24,
  flowFieldScale: 0.08,
  flowFieldStrength: 3.5,
  flowFieldTimeScale: 0.4,
  
  // CPU Fluid simulation (fallback)
  viscosity: 0.94,
  velocityDamping: 0.88,
  maxVelocity: 8.0,
  
  // Turbulence
  turbulenceScale: 0.12,
  turbulenceStrength: 2.5,
  turbulenceOctaves: 3,
  turbulenceLacunarity: 2.0,
  turbulencePersistence: 0.5,
  
  // Fusion / clustering
  fusionEnabled: true,
  fusionRadius: 4.0,
  fusionStrength: 0.35,
  fusionNeighborCount: 6,
  
  // Attraction
  targetAttractionBase: 0.08,
  targetAttractionMax: 0.6,
  gatherCenterStrength: 0.12,
  
  // Performance
  spatialHashCellSize: 8,
  maxParticlesPerCell: 50,
  useGPU: true,
  gpuTextureSize: 512,
  
  // Debug
  debug: false
};

// ============================================
// PERFORMANCE MONITOR
// ============================================

var PerformanceMonitor = (function() {
  function Monitor() {
    this.frameTimes = [];
    this.maxSamples = 60;
    this.lastFrameTime = 0;
    this.isWarning = false;
    this.warningCallback = null;
    this.enabled = CONFIG.performanceMonitoring;
  }
  
  Monitor.prototype.startFrame = function() {
    this.lastFrameTime = performance.now();
  };
  
  Monitor.prototype.endFrame = function() {
    if (!this.enabled) return;
    
    var frameTime = performance.now() - this.lastFrameTime;
    
    this.frameTimes.push(frameTime);
    if (this.frameTimes.length > this.maxSamples) {
      this.frameTimes.shift();
    }
    
    // Check for performance issues
    if (frameTime > CONFIG.performanceWarningThreshold) {
      if (!this.isWarning && this.warningCallback) {
        this.isWarning = true;
        this.warningCallback({
          frameTime: frameTime,
          averageFrameTime: this.getAverageFrameTime(),
          recommendation: frameTime > 33 ? 'switch_to_cpu' : 'reduce_particles'
        });
      }
    } else if (this.isWarning && frameTime < CONFIG.targetFrameTime) {
      this.isWarning = false;
    }
    
    return frameTime;
  };
  
  Monitor.prototype.getAverageFrameTime = function() {
    if (this.frameTimes.length === 0) return 0;
    var sum = this.frameTimes.reduce(function(a, b) { return a + b; }, 0);
    return sum / this.frameTimes.length;
  };
  
  Monitor.prototype.getFPS = function() {
    var avg = this.getAverageFrameTime();
    return avg > 0 ? Math.round(1000 / avg) : 60;
  };
  
  Monitor.prototype.getStats = function() {
    return {
      fps: this.getFPS(),
      averageFrameTime: this.getAverageFrameTime().toFixed(2),
      lastFrameTime: this.frameTimes[this.frameTimes.length - 1] || 0,
      isWarning: this.isWarning,
      samples: this.frameTimes.length
    };
  };
  
  Monitor.prototype.onPerformanceWarning = function(callback) {
    this.warningCallback = callback;
  };
  
  Monitor.prototype.reset = function() {
    this.frameTimes = [];
    this.isWarning = false;
  };
  
  return Monitor;
})();

  // ============================================
  // EASING FUNCTIONS
  // ============================================

  var EASING = {
    linear: function(t) { return t; },
    
    easeInQuad: function(t) { return t * t; },
    easeOutQuad: function(t) { return t * (2 - t); },
    easeInOutQuad: function(t) { 
      return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t; 
    },
    
    easeInCubic: function(t) { return t * t * t; },
    easeOutCubic: function(t) { return (--t) * t * t + 1; },
    easeInOutCubic: function(t) { 
      return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1; 
    },
    
    easeInQuart: function(t) { return t * t * t * t; },
    easeOutQuart: function(t) { return 1 - (--t) * t * t * t; },
    easeInOutQuart: function(t) {
      return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t;
    },
    
    easeInQuint: function(t) { return t * t * t * t * t; },
    easeOutQuint: function(t) { return 1 + (--t) * t * t * t * t; },
    easeInOutQuint: function(t) {
      return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t;
    },
    
    easeOutElastic: function(t) {
      if (t === 0 || t === 1) return t;
      return Math.pow(2, -10 * t) * Math.sin((t - 0.1) * 5 * Math.PI) + 1;
    },
    
    easeOutBack: function(t) {
      var c1 = 1.70158;
      var c3 = c1 + 1;
      return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
    },
    
    easeInOutBack: function(t) {
      var c1 = 1.70158;
      var c2 = c1 * 1.525;
      return t < 0.5
        ? (Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2)) / 2
        : (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2;
    },
    
    easeOutBounce: function(t) {
      var n1 = 7.5625;
      var d1 = 2.75;
      if (t < 1 / d1) {
        return n1 * t * t;
      } else if (t < 2 / d1) {
        return n1 * (t -= 1.5 / d1) * t + 0.75;
      } else if (t < 2.5 / d1) {
        return n1 * (t -= 2.25 / d1) * t + 0.9375;
      } else {
        return n1 * (t -= 2.625 / d1) * t + 0.984375;
      }
    },
    
    fluidEase: function(t) {
      if (t < 0.2) {
        return 2.5 * t * t;
      } else if (t < 0.8) {
        var mid = (t - 0.2) / 0.6;
        return 0.1 + 0.8 * mid;
      } else {
        var end = (t - 0.8) / 0.2;
        return 0.9 + 0.1 * (1 - Math.pow(1 - end, 2));
      }
    },
    
    organicEase: function(t) {
      var overshoot = 1.05;
      if (t < 0.7) {
        return overshoot * EASING.easeOutCubic(t / 0.7);
      } else {
        var settle = (t - 0.7) / 0.3;
        return overshoot - (overshoot - 1) * EASING.easeInOutQuad(settle);
      }
    }
  };

  // ============================================
  // SIMPLEX NOISE
  // ============================================

  var SimplexNoise = (function() {
    var F3 = 1.0 / 3.0;
    var G3 = 1.0 / 6.0;
    
    var grad3 = [
      [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
      [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
      [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
    ];
    
    function Noise(seed) {
      this.perm = new Uint8Array(512);
      this.permMod12 = new Uint8Array(512);
      
      var p = new Uint8Array(256);
      for (var i = 0; i < 256; i++) {
        p[i] = i;
      }
      
      seed = seed || Math.random() * 65536;
      for (var i = 255; i > 0; i--) {
        seed = (seed * 16807) % 2147483647;
        var j = seed % (i + 1);
        var tmp = p[i];
        p[i] = p[j];
        p[j] = tmp;
      }
      
      for (var i = 0; i < 512; i++) {
        this.perm[i] = p[i & 255];
        this.permMod12[i] = this.perm[i] % 12;
      }
    }
    
    Noise.prototype.noise3D = function(x, y, z) {
      var s = (x + y + z) * F3;
      var i = Math.floor(x + s);
      var j = Math.floor(y + s);
      var k = Math.floor(z + s);
      
      var t = (i + j + k) * G3;
      var X0 = i - t;
      var Y0 = j - t;
      var Z0 = k - t;
      var x0 = x - X0;
      var y0 = y - Y0;
      var z0 = z - Z0;
      
      var i1, j1, k1, i2, j2, k2;
      
      if (x0 >= y0) {
        if (y0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
        else if (x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
        else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
      } else {
        if (y0 < z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
        else if (x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
        else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
      }
      
      var x1 = x0 - i1 + G3;
      var y1 = y0 - j1 + G3;
      var z1 = z0 - k1 + G3;
      var x2 = x0 - i2 + 2.0 * G3;
      var y2 = y0 - j2 + 2.0 * G3;
      var z2 = z0 - k2 + 2.0 * G3;
      var x3 = x0 - 1.0 + 3.0 * G3;
      var y3 = y0 - 1.0 + 3.0 * G3;
      var z3 = z0 - 1.0 + 3.0 * G3;
      
      var ii = i & 255;
      var jj = j & 255;
      var kk = k & 255;
      
      var n = 0;
      
      var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
      if (t0 >= 0) {
        var gi0 = this.permMod12[ii + this.perm[jj + this.perm[kk]]];
        t0 *= t0;
        n += t0 * t0 * (grad3[gi0][0]*x0 + grad3[gi0][1]*y0 + grad3[gi0][2]*z0);
      }
      
      var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
      if (t1 >= 0) {
        var gi1 = this.permMod12[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]];
        t1 *= t1;
        n += t1 * t1 * (grad3[gi1][0]*x1 + grad3[gi1][1]*y1 + grad3[gi1][2]*z1);
      }
      
      var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
      if (t2 >= 0) {
        var gi2 = this.permMod12[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]];
        t2 *= t2;
        n += t2 * t2 * (grad3[gi2][0]*x2 + grad3[gi2][1]*y2 + grad3[gi2][2]*z2);
      }
      
      var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
      if (t3 >= 0) {
        var gi3 = this.permMod12[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]];
        t3 *= t3;
        n += t3 * t3 * (grad3[gi3][0]*x3 + grad3[gi3][1]*y3 + grad3[gi3][2]*z3);
      }
      
      return 32.0 * n;
    };
    
    return Noise;
  })();

  // ============================================
  // LETTER PATTERNS
  // ============================================

  var LETTER_PATTERNS = {
    'A': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]],
    'B': [[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0]],
    'C': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,1],[0,1,1,1,0]],
    'D': [[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0]],
    'E': [[1,1,1,1,1],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,1]],
    'F': [[1,1,1,1,1],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0]],
    'G': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,0],[1,0,1,1,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
    'H': [[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]],
    'I': [[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[1,1,1,1,1]],
    'J': [[0,0,1,1,1],[0,0,0,1,0],[0,0,0,1,0],[0,0,0,1,0],[1,0,0,1,0],[1,0,0,1,0],[0,1,1,0,0]],
    'K': [[1,0,0,0,1],[1,0,0,1,0],[1,0,1,0,0],[1,1,0,0,0],[1,0,1,0,0],[1,0,0,1,0],[1,0,0,0,1]],
    'L': [[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,1]],
    'M': [[1,0,0,0,1],[1,1,0,1,1],[1,0,1,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]],
    'N': [[1,0,0,0,1],[1,1,0,0,1],[1,0,1,0,1],[1,0,0,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]],
    'O': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
    'P': [[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0]],
    'Q': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,1,0],[0,1,1,0,1]],
    'R': [[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0],[1,0,1,0,0],[1,0,0,1,0],[1,0,0,0,1]],
    'S': [[0,1,1,1,1],[1,0,0,0,0],[1,0,0,0,0],[0,1,1,1,0],[0,0,0,0,1],[0,0,0,0,1],[1,1,1,1,0]],
    'T': [[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]],
    'U': [[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
    'V': [[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,0,1,0],[0,1,0,1,0],[0,0,1,0,0]],
    'W': [[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,1,0,1],[1,1,0,1,1],[1,0,0,0,1]],
    'X': [[1,0,0,0,1],[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0],[0,1,0,1,0],[1,0,0,0,1],[1,0,0,0,1]],
    'Y': [[1,0,0,0,1],[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]],
    'Z': [[1,1,1,1,1],[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0],[1,0,0,0,0],[1,1,1,1,1]],
    '0': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,1,1],[1,0,1,0,1],[1,1,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
    '1': [[0,0,1,0,0],[0,1,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,1,1,1,0]],
    '2': [[0,1,1,1,0],[1,0,0,0,1],[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0],[1,1,1,1,1]],
    '3': [[0,1,1,1,0],[1,0,0,0,1],[0,0,0,0,1],[0,0,1,1,0],[0,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
    '4': [[0,0,0,1,0],[0,0,1,1,0],[0,1,0,1,0],[1,0,0,1,0],[1,1,1,1,1],[0,0,0,1,0],[0,0,0,1,0]],
    '5': [[1,1,1,1,1],[1,0,0,0,0],[1,1,1,1,0],[0,0,0,0,1],[0,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
    '6': [[0,1,1,1,0],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
    '7': [[1,1,1,1,1],[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]],
    '8': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
    '9': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,1],[0,0,0,0,1],[0,0,0,0,1],[0,1,1,1,0]],
    ' ': [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]],
    '!': [[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,1,0,0]],
    '?': [[0,1,1,1,0],[1,0,0,0,1],[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,1,0,0]],
    '.': [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,1,0,0]],
    '+': [[0,0,0,0,0],[0,0,1,0,0],[0,0,1,0,0],[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,0,0,0]],
    '-': [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[1,1,1,1,1],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]],
    '$': [[0,0,1,0,0],[0,1,1,1,1],[1,0,1,0,0],[0,1,1,1,0],[0,0,1,0,1],[1,1,1,1,0],[0,0,1,0,0]],
    '%': [[1,1,0,0,1],[1,1,0,1,0],[0,0,1,0,0],[0,0,1,0,0],[0,1,0,1,1],[1,0,0,1,1],[0,0,0,0,0]],
    '&': [[0,1,1,0,0],[1,0,0,1,0],[1,0,0,1,0],[0,1,1,0,0],[1,0,0,1,1],[1,0,0,0,1],[0,1,1,1,1]],
    '*': [[0,0,0,0,0],[0,0,1,0,0],[1,0,1,0,1],[0,1,1,1,0],[1,0,1,0,1],[0,0,1,0,0],[0,0,0,0,0]]
  };

  // ============================================
  // WAIT FOR THREE.JS
  // ============================================

  function waitForThree(callback, maxAttempts) {
    maxAttempts = maxAttempts || 100;
    var attempts = 0;
    var check = function() {
      attempts++;
      if (typeof THREE !== 'undefined') {
        callback();
      } else if (attempts < maxAttempts) {
        setTimeout(check, 50);
      } else {
        console.error('[MorphEngine] THREE.js not found after', maxAttempts, 'attempts');
      }
    };
    check();
  }

  // ============================================
  // SPATIAL HASH (CPU Fallback)
  // ============================================

  function SpatialHash(cellSize) {
    this.cellSize = cellSize || CONFIG.spatialHashCellSize;
    this.cells = {};
  }

  SpatialHash.prototype.clear = function() {
    this.cells = {};
  };

  SpatialHash.prototype.getKey = function(x, y, z) {
    var cx = Math.floor(x / this.cellSize);
    var cy = Math.floor(y / this.cellSize);
    var cz = Math.floor(z / this.cellSize);
    return cx + ',' + cy + ',' + cz;
  };

  SpatialHash.prototype.insert = function(index, x, y, z) {
    var key = this.getKey(x, y, z);
    if (!this.cells[key]) {
      this.cells[key] = [];
    }
    if (this.cells[key].length < CONFIG.maxParticlesPerCell) {
      this.cells[key].push({ index: index, x: x, y: y, z: z });
    }
  };

  SpatialHash.prototype.getNeighbors = function(x, y, z, radius) {
    var neighbors = [];
    var cellRadius = Math.ceil(radius / this.cellSize);
    var cx = Math.floor(x / this.cellSize);
    var cy = Math.floor(y / this.cellSize);
    var cz = Math.floor(z / this.cellSize);
    var radiusSq = radius * radius;
    
    for (var dx = -cellRadius; dx <= cellRadius; dx++) {
      for (var dy = -cellRadius; dy <= cellRadius; dy++) {
        for (var dz = -cellRadius; dz <= cellRadius; dz++) {
          var key = (cx + dx) + ',' + (cy + dy) + ',' + (cz + dz);
          var cell = this.cells[key];
          if (cell) {
            for (var i = 0; i < cell.length; i++) {
              var p = cell[i];
              var distSq = (p.x - x) * (p.x - x) + (p.y - y) * (p.y - y) + (p.z - z) * (p.z - z);
              if (distSq < radiusSq && distSq > 0) {
                neighbors.push({ index: p.index, distSq: distSq, x: p.x, y: p.y, z: p.z });
              }
            }
          }
        }
      }
    }
    
    return neighbors;
  };

  // ============================================
// GPU SPH SIMULATOR
// ============================================

function GPUSPHSimulator(renderer, particleCount, options) {
  this.renderer = renderer;
  this.particleCount = particleCount;
  this.options = Object.assign({}, CONFIG.sph, options || {});
  
  this.isInitialized = false;
  this.isWebGL2 = false;
  this.useTransformFeedback = false;
  
  // Texture dimensions (square for simplicity)
  this.textureSize = Math.ceil(Math.sqrt(particleCount));
  
  // Render targets for ping-pong
  this.positionRT = [null, null];
  this.velocityRT = [null, null];
  this.densityRT = null;
  this.pressureRT = null;
  this.forceRT = null; 
  
  this.currentRT = 0;
  
  // Shader materials
  this.densityMaterial = null;
  this.pressureMaterial = null;
  this.forceMaterial = null;
  this.integrateMaterial = null;
  
  // Scene/camera for rendering to texture
  this.scene = null;
  this.camera = null;
  this.quad = null;
  
  // Target positions texture
  this.targetPositionRT = null;
  this.morphProgress = 0;
  
  // Max particles supported
  this.maxTextureSize = 0;
  this.maxParticlesSupported = 0;
  
  this.checkWebGL2Support();
}

GPUSPHSimulator.prototype.checkWebGL2Support = function() {
  if (!this.renderer) return;
  
  var gl = this.renderer.getContext();
  this.isWebGL2 = gl instanceof WebGL2RenderingContext;
  
  // Check for float texture support
  var floatExt = gl.getExtension('OES_texture_float');
  var floatLinearExt = gl.getExtension('OES_texture_float_linear');
  
  // Check max texture size for loop limit
  this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  this.maxParticlesSupported = Math.min(
    this.maxTextureSize * this.maxTextureSize,
    CONFIG.gpuMaxParticles
  );
  
  if (this.isWebGL2) {
    this.useTransformFeedback = false; // Disabled until properly implemented
    if (CONFIG.debug) {
      console.log('[GPUSPHSimulator] WebGL2 detected');
      console.log('[GPUSPHSimulator] Max texture size:', this.maxTextureSize);
      console.log('[GPUSPHSimulator] Max particles supported:', this.maxParticlesSupported);
    }
  } else if (floatExt) {
    if (CONFIG.debug) {
      console.log('[GPUSPHSimulator] WebGL1 with float textures');
    }
  } else {
    console.warn('[GPUSPHSimulator] Float textures not supported, falling back to CPU');
    return;
  }
  
  // Validate particle count
  if (this.particleCount > this.maxParticlesSupported) {
    console.warn('[GPUSPHSimulator] Particle count', this.particleCount, 
      'exceeds recommended max', this.maxParticlesSupported, '- may impact performance');
  }
  
  this.isInitialized = true;
};

GPUSPHSimulator.prototype.init = function(positions, velocities) {
  if (!this.isInitialized || !this.renderer) return false;
  
  var size = this.textureSize;
  
  // Create scene for GPGPU
  this.scene = new THREE.Scene();
  this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
  
  // Full-screen quad
  var geometry = new THREE.PlaneGeometry(2, 2);
  this.quad = new THREE.Mesh(geometry, null);
  this.scene.add(this.quad);
  
  // Create position textures
  var posData = new Float32Array(size * size * 4);
  for (var i = 0; i < this.particleCount; i++) {
    var i4 = i * 4;
    var i3 = i * 3;
    posData[i4] = positions[i3] || 0;
    posData[i4 + 1] = positions[i3 + 1] || 0;
    posData[i4 + 2] = positions[i3 + 2] || 0;
    posData[i4 + 3] = 1.0; // Active flag
  }
  
  var posTex0 = this.createDataTexture(posData, size);
  var posTex1 = this.createDataTexture(new Float32Array(posData), size);
  
  this.positionRT[0] = this.createRenderTarget(size);
  this.positionRT[1] = this.createRenderTarget(size);
  
  // Copy initial data to render targets
  this.positionRT[0].texture = posTex0;
  this.positionRT[1].texture = posTex1;
  
  // Create velocity textures
  var velData = new Float32Array(size * size * 4);
  if (velocities) {
    for (var j = 0; j < this.particleCount; j++) {
      var j4 = j * 4;
      var j3 = j * 3;
      velData[j4] = velocities[j3] || 0;
      velData[j4 + 1] = velocities[j3 + 1] || 0;
      velData[j4 + 2] = velocities[j3 + 2] || 0;
      velData[j4 + 3] = 0;
    }
  }
  
  var velTex0 = this.createDataTexture(velData, size);
  var velTex1 = this.createDataTexture(new Float32Array(velData), size);
  
  this.velocityRT[0] = this.createRenderTarget(size);
  this.velocityRT[1] = this.createRenderTarget(size);
  this.velocityRT[0].texture = velTex0;
  this.velocityRT[1].texture = velTex1;
  
  // Density and pressure textures
  this.densityRT = this.createRenderTarget(size);
  this.pressureRT = this.createRenderTarget(size);
  this.forceRT = this.createRenderTarget(size);
  
  // Target position texture
  this.targetPositionRT = this.createRenderTarget(size);
  
  // Create shader materials
  this.createShaderMaterials();
  
  if (CONFIG.debug) {
    console.log('[GPUSPHSimulator] Initialized with texture size:', size);
  }
  
  return true;
};

GPUSPHSimulator.prototype.createDataTexture = function(data, size) {
  var texture = new THREE.DataTexture(
    data,
    size,
    size,
    THREE.RGBAFormat,
    THREE.FloatType
  );
  texture.minFilter = THREE.NearestFilter;
  texture.magFilter = THREE.NearestFilter;
  texture.needsUpdate = true;
  return texture;
};

GPUSPHSimulator.prototype.createRenderTarget = function(size) {
  return new THREE.WebGLRenderTarget(size, size, {
    minFilter: THREE.NearestFilter,
    magFilter: THREE.NearestFilter,
    format: THREE.RGBAFormat,
    type: THREE.FloatType,
    depthBuffer: false,
    stencilBuffer: false
  });
};

GPUSPHSimulator.prototype.createShaderMaterials = function() {
  var size = this.textureSize;
  
  // Common uniforms
  var commonUniforms = {
    uResolution: { value: new THREE.Vector2(size, size) },
    uParticleCount: { value: this.particleCount },
    uSmoothingRadius: { value: this.options.smoothingRadius },
    uRestDensity: { value: this.options.restDensity },
    uStiffness: { value: this.options.stiffness },
    uNearStiffness: { value: this.options.nearStiffness },
    uViscosity: { value: this.options.viscosity },
    uLinearViscosity: { value: this.options.linearViscosity },
    uQuadraticViscosity: { value: this.options.quadraticViscosity },
    uSurfaceTension: { value: this.options.surfaceTension },
    uGravity: { value: new THREE.Vector3(
      this.options.gravity.x,
      this.options.gravity.y,
      this.options.gravity.z
    )},
    uDeltaTime: { value: this.options.timeStep },
    uBoundary: { value: new THREE.Vector3(
      this.options.boundarySize.x,
      this.options.boundarySize.y,
      this.options.boundarySize.z
    )},
    uBoundaryDamping: { value: this.options.boundaryDamping }
  };
  
  // Density calculation shader
  this.densityMaterial = new THREE.ShaderMaterial({
    uniforms: Object.assign({}, commonUniforms, {
      tPosition: { value: null }
    }),
    vertexShader: this.getPassthroughVertexShader(),
    fragmentShader: this.getDensityFragmentShader()
  });
  
  // Pressure calculation shader
  this.pressureMaterial = new THREE.ShaderMaterial({
    uniforms: Object.assign({}, commonUniforms, {
      tPosition: { value: null },
      tDensity: { value: null }
    }),
    vertexShader: this.getPassthroughVertexShader(),
    fragmentShader: this.getPressureFragmentShader()
  });
  
  // Force calculation shader
  this.forceMaterial = new THREE.ShaderMaterial({
    uniforms: Object.assign({}, commonUniforms, {
      tPosition: { value: null },
      tVelocity: { value: null },
      tDensity: { value: null },
      tPressure: { value: null },
      tTargetPosition: { value: null },
      uMorphProgress: { value: 0 },
      uTargetAttraction: { value: 0.1 },
      uTime: { value: 0 }
    }),
    vertexShader: this.getPassthroughVertexShader(),
    fragmentShader: this.getForceFragmentShader()
  });
  
  // Integration shader
  this.integrateMaterial = new THREE.ShaderMaterial({
    uniforms: Object.assign({}, commonUniforms, {
      tPosition: { value: null },
      tVelocity: { value: null },
      tForce: { value: null },
      uIntegratePosition: { value: true }
    }),
    vertexShader: this.getPassthroughVertexShader(),
    fragmentShader: this.getIntegrateFragmentShader()
  });
};

GPUSPHSimulator.prototype.getPassthroughVertexShader = function() {
  return [
    'varying vec2 vUv;',
    '',
    'void main() {',
    '  vUv = uv;',
    '  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
    '}'
  ].join('\n');
};

GPUSPHSimulator.prototype.getDensityFragmentShader = function() {
  var loopLimit = Math.min(Math.ceil(this.particleCount / 100) * 100 + 100, 8192);
  
  return [
    'precision highp float;',
    '',
    'uniform sampler2D tPosition;',
    'uniform vec2 uResolution;',
    'uniform float uParticleCount;',
    'uniform float uSmoothingRadius;',
    '',
    'varying vec2 vUv;',
    '',
    'float poly6(float r, float h) {',
    '  if (r > h) return 0.0;',
    '  float h2 = h * h;',
    '  float h9 = h2 * h2 * h2 * h2 * h;',
    '  float diff = h2 - r * r;',
    '  return 315.0 / (64.0 * 3.14159265 * h9) * diff * diff * diff;',
    '}',
    '',
    'void main() {',
    '  vec4 posData = texture2D(tPosition, vUv);',
    '  vec3 pos = posData.xyz;',
    '  float isActive = posData.w;',
    '  ',
    '  if (isActive < 0.5) {',
    '    gl_FragColor = vec4(0.0);',
    '    return;',
    '  }',
    '  ',
    '  float density = 0.0;',
    '  float nearDensity = 0.0;',
    '  float h = uSmoothingRadius;',
    '  ',
    '  for (float i = 0.0; i < ' + loopLimit.toFixed(1) + '; i += 1.0) {',
    '    if (i >= uParticleCount) break;',
    '    ',
    '    vec2 neighborUV = vec2(',
    '      mod(i, uResolution.x) / uResolution.x,',
    '      floor(i / uResolution.x) / uResolution.y',
    '    ) + 0.5 / uResolution;',
    '    ',
    '    vec4 neighborData = texture2D(tPosition, neighborUV);',
    '    vec3 neighborPos = neighborData.xyz;',
    '    float neighborActive = neighborData.w;',
    '    ',
    '    if (neighborActive < 0.5) continue;',
    '    ',
    '    vec3 diff = pos - neighborPos;',
    '    float r = length(diff);',
    '    ',
    '    if (r < h) {',
    '      density += poly6(r, h);',
    '      nearDensity += poly6(r, h * 0.5);',
    '    }',
    '  }',
    '  ',
    '  gl_FragColor = vec4(density, nearDensity, 0.0, 1.0);',
    '}'
  ].join('\n');
};

GPUSPHSimulator.prototype.getPressureFragmentShader = function() {
  return [
    'precision highp float;',
    '',
    'uniform sampler2D tDensity;',
    'uniform float uRestDensity;',
    'uniform float uStiffness;',
    'uniform float uNearStiffness;',
    '',
    'varying vec2 vUv;',
    '',
    'void main() {',
    '  vec4 densityData = texture2D(tDensity, vUv);',
    '  float density = densityData.x;',
    '  float nearDensity = densityData.y;',
    '  ',
    '  float pressure = uStiffness * (density - uRestDensity);',
    '  float nearPressure = uNearStiffness * nearDensity;',
    '  ',
    '  gl_FragColor = vec4(pressure, nearPressure, density, 1.0);',
    '}'
  ].join('\n');
};

GPUSPHSimulator.prototype.getForceFragmentShader = function() {
  var loopLimit = Math.min(Math.ceil(this.particleCount / 100) * 100 + 100, 8192);
  
  return [
    'precision highp float;',
    '',
    'uniform sampler2D tPosition;',
    'uniform sampler2D tVelocity;',
    'uniform sampler2D tDensity;',
    'uniform sampler2D tPressure;',
    'uniform sampler2D tTargetPosition;',
    '',
    'uniform vec2 uResolution;',
    'uniform float uParticleCount;',
    'uniform float uSmoothingRadius;',
    'uniform float uViscosity;',
    'uniform float uSurfaceTension;',
    'uniform vec3 uGravity;',
    'uniform float uMorphProgress;',
    'uniform float uTargetAttraction;',
    'uniform float uTime;',
    '',
    'varying vec2 vUv;',
    '',
    'vec3 spikyGrad(vec3 r, float dist, float h) {',
    '  if (dist > h || dist < 0.0001) return vec3(0.0);',
    '  float h6 = h * h * h * h * h * h;',
    '  float coeff = -45.0 / (3.14159265 * h6);',
    '  float diff = h - dist;',
    '  return coeff * diff * diff * normalize(r);',
    '}',
    '',
    'float viscLaplacian(float r, float h) {',
    '  if (r > h) return 0.0;',
    '  float h6 = h * h * h * h * h * h;',
    '  return 45.0 / (3.14159265 * h6) * (h - r);',
    '}',
    '',
    'void main() {',
    '  vec4 posData = texture2D(tPosition, vUv);',
    '  vec3 pos = posData.xyz;',
    '  float isActive = posData.w;',
    '  ',
    '  if (isActive < 0.5) {',
    '    gl_FragColor = vec4(0.0);',
    '    return;',
    '  }',
    '  ',
    '  vec3 vel = texture2D(tVelocity, vUv).xyz;',
    '  vec4 pressureData = texture2D(tPressure, vUv);',
    '  float pressure = pressureData.x;',
    '  float nearPressure = pressureData.y;',
    '  float density = pressureData.z;',
    '  ',
    '  vec3 force = uGravity;',
    '  vec3 pressureForce = vec3(0.0);',
    '  vec3 viscosityForce = vec3(0.0);',
    '  vec3 surfaceForce = vec3(0.0);',
    '  ',
    '  float h = uSmoothingRadius;',
    '  ',
    '  for (float i = 0.0; i < ' + loopLimit.toFixed(1) + '; i += 1.0) {',
    '    if (i >= uParticleCount) break;',
    '    ',
    '    vec2 neighborUV = vec2(',
    '      mod(i, uResolution.x) / uResolution.x,',
    '      floor(i / uResolution.x) / uResolution.y',
    '    ) + 0.5 / uResolution;',
    '    ',
    '    vec4 neighborPosData = texture2D(tPosition, neighborUV);',
    '    if (neighborPosData.w < 0.5) continue;',
    '    ',
    '    vec3 neighborPos = neighborPosData.xyz;',
    '    vec3 neighborVel = texture2D(tVelocity, neighborUV).xyz;',
    '    vec4 neighborPressure = texture2D(tPressure, neighborUV);',
    '    ',
    '    vec3 diff = pos - neighborPos;',
    '    float dist = length(diff);',
    '    ',
    '    if (dist < h && dist > 0.0001) {',
    '      float avgPressure = (pressure + neighborPressure.x) * 0.5;',
    '      float avgNearPressure = (nearPressure + neighborPressure.y) * 0.5;',
    '      pressureForce += spikyGrad(diff, dist, h) * (avgPressure + avgNearPressure);',
    '      ',
    '      vec3 velDiff = neighborVel - vel;',
    '      float visc = viscLaplacian(dist, h);',
    '      viscosityForce += velDiff * visc * uViscosity;',
    '      ',
    '      float q = dist / h;',
    '      if (q < 1.0) {',
    '        vec3 D = (1.0 - q) * (avgPressure * (1.0 - q) + avgNearPressure * (1.0 - q) * (1.0 - q)) * normalize(diff);',
    '        surfaceForce -= D * uSurfaceTension;',
    '      }',
    '    }',
    '  }',
    '  ',
    '  vec3 targetPos = texture2D(tTargetPosition, vUv).xyz;',
    '  vec3 toTarget = targetPos - pos;',
    '  float targetDist = length(toTarget);',
    '  ',
    '  float attractionStrength = uTargetAttraction * uMorphProgress;',
    '  attractionStrength *= (1.0 + (1.0 - min(targetDist / 20.0, 1.0)) * 2.0);',
    '  ',
    '  vec3 targetForce = toTarget * attractionStrength;',
    '  ',
    '  float turbulence = sin(pos.x * 0.1 + uTime) * cos(pos.y * 0.1 + uTime * 0.7) * 0.5;',
    '  targetForce += vec3(turbulence, turbulence * 0.5, turbulence * 0.3) * (1.0 - uMorphProgress);',
    '  ',
    '  force += pressureForce / max(density, 0.0001);',
    '  force += viscosityForce;',
    '  force += surfaceForce;',
    '  force += targetForce;',
    '  ',
    '  gl_FragColor = vec4(force, 1.0);',
    '}'
  ].join('\n');
};

GPUSPHSimulator.prototype.getIntegrateFragmentShader = function() {
  return [
    'precision highp float;',
    '',
    'uniform sampler2D tPosition;',
    'uniform sampler2D tVelocity;',
    'uniform sampler2D tForce;',
    '',
    'uniform float uDeltaTime;',
    'uniform vec3 uBoundary;',
    'uniform float uBoundaryDamping;',
    'uniform bool uIntegratePosition;',
    '',
    'varying vec2 vUv;',
    '',
    'void main() {',
    '  vec4 posData = texture2D(tPosition, vUv);',
    '  vec3 pos = posData.xyz;',
    '  float isActive = posData.w;',
    '  ',
    '  vec3 vel = texture2D(tVelocity, vUv).xyz;',
    '  vec3 force = texture2D(tForce, vUv).xyz;',
    '  ',
    '  if (isActive < 0.5) {',
    '    if (uIntegratePosition) {',
    '      gl_FragColor = posData;',
    '    } else {',
    '      gl_FragColor = vec4(vel, 0.0);',
    '    }',
    '    return;',
    '  }',
    '  ',
    '  vec3 newVel = vel + force * uDeltaTime;',
    '  newVel *= 0.99;',
    '  ',
    '  float maxVel = 50.0;',
    '  float velMag = length(newVel);',
    '  if (velMag > maxVel) {',
    '    newVel = normalize(newVel) * maxVel;',
    '  }',
    '  ',
    '  if (uIntegratePosition) {',
    '    vec3 newPos = pos + newVel * uDeltaTime;',
    '    ',
    '    if (abs(newPos.x) > uBoundary.x) {',
    '      newPos.x = sign(newPos.x) * uBoundary.x;',
    '      newVel.x *= -uBoundaryDamping;',
    '    }',
    '    if (abs(newPos.y) > uBoundary.y) {',
    '      newPos.y = sign(newPos.y) * uBoundary.y;',
    '      newVel.y *= -uBoundaryDamping;',
    '    }',
    '    if (abs(newPos.z) > uBoundary.z) {',
    '      newPos.z = sign(newPos.z) * uBoundary.z;',
    '      newVel.z *= -uBoundaryDamping;',
    '    }',
    '    ',
    '    gl_FragColor = vec4(newPos, isActive);',
    '  } else {',
    '    gl_FragColor = vec4(newVel, 0.0);',
    '  }',
    '}'
  ].join('\n');
};

GPUSPHSimulator.prototype.setTargetPositions = function(positions) {
  if (!this.isInitialized) return;
  
  var size = this.textureSize;
  var data = new Float32Array(size * size * 4);
  
  for (var i = 0; i < this.particleCount; i++) {
    var i4 = i * 4;
    if (positions[i]) {
      data[i4] = positions[i].x;
      data[i4 + 1] = positions[i].y;
      data[i4 + 2] = positions[i].z;
      data[i4 + 3] = 1.0;
    }
  }
  
  var texture = this.createDataTexture(data, size);
  if (this.targetPositionRT) {
    this.targetPositionRT.texture.dispose();
  }
  this.targetPositionRT.texture = texture;
};

GPUSPHSimulator.prototype.step = function(deltaTime, morphProgress, targetAttraction, time) {
  if (!this.isInitialized || !this.renderer) return;
  
  var current = this.currentRT;
  var next = 1 - current;
  
  var dt = deltaTime / this.options.substeps;
  
  for (var substep = 0; substep < this.options.substeps; substep++) {
    // 1. Calculate density
    this.densityMaterial.uniforms.tPosition.value = this.positionRT[current].texture;
    this.quad.material = this.densityMaterial;
    this.renderer.setRenderTarget(this.densityRT);
    this.renderer.render(this.scene, this.camera);
    
    // 2. Calculate pressure
    this.pressureMaterial.uniforms.tDensity.value = this.densityRT.texture;
    this.quad.material = this.pressureMaterial;
    this.renderer.setRenderTarget(this.pressureRT);
    this.renderer.render(this.scene, this.camera);
    
    // 3. Calculate forces
    this.forceMaterial.uniforms.tPosition.value = this.positionRT[current].texture;
    this.forceMaterial.uniforms.tVelocity.value = this.velocityRT[current].texture;
    this.forceMaterial.uniforms.tDensity.value = this.densityRT.texture;
    this.forceMaterial.uniforms.tPressure.value = this.pressureRT.texture;
    this.forceMaterial.uniforms.tTargetPosition.value = this.targetPositionRT ? this.targetPositionRT.texture : null;
    this.forceMaterial.uniforms.uMorphProgress.value = morphProgress || 0;
    this.forceMaterial.uniforms.uTargetAttraction.value = targetAttraction || 0.1;
    this.forceMaterial.uniforms.uTime.value = time || 0;
    this.quad.material = this.forceMaterial;
    
    // Store forces in separate forceRT
this.renderer.setRenderTarget(this.forceRT);
this.renderer.render(this.scene, this.camera);
    
    // 4. Integrate velocity
    this.integrateMaterial.uniforms.tPosition.value = this.positionRT[current].texture;
    this.integrateMaterial.uniforms.tVelocity.value = this.velocityRT[current].texture;
this.integrateMaterial.uniforms.tForce.value = this.forceRT.texture;
    this.integrateMaterial.uniforms.uDeltaTime.value = dt;
    this.integrateMaterial.uniforms.uIntegratePosition.value = false;
    this.quad.material = this.integrateMaterial;
    this.renderer.setRenderTarget(this.velocityRT[next]);
    this.renderer.render(this.scene, this.camera);
    
    // 5. Integrate position
    this.integrateMaterial.uniforms.tVelocity.value = this.velocityRT[next].texture;
    this.integrateMaterial.uniforms.uIntegratePosition.value = true;
    this.renderer.setRenderTarget(this.positionRT[next]);
    this.renderer.render(this.scene, this.camera);
    
    // Swap buffers
    this.currentRT = next;
    current = next;
    next = 1 - current;
  }
  
  this.renderer.setRenderTarget(null);
};

GPUSPHSimulator.prototype.readPositions = function(targetArray) {
  if (!this.isInitialized || !this.renderer) return;
  
  var size = this.textureSize;
  var buffer = new Float32Array(size * size * 4);
  
  this.renderer.readRenderTargetPixels(
    this.positionRT[this.currentRT],
    0, 0, size, size,
    buffer
  );
  
  for (var i = 0; i < this.particleCount; i++) {
    var i4 = i * 4;
    var i3 = i * 3;
    targetArray[i3] = buffer[i4];
    targetArray[i3 + 1] = buffer[i4 + 1];
    targetArray[i3 + 2] = buffer[i4 + 2];
  }
};

GPUSPHSimulator.prototype.dispose = function() {
  if (this.positionRT[0]) this.positionRT[0].dispose();
  if (this.positionRT[1]) this.positionRT[1].dispose();
  if (this.velocityRT[0]) this.velocityRT[0].dispose();
  if (this.velocityRT[1]) this.velocityRT[1].dispose();
  if (this.densityRT) this.densityRT.dispose();
  if (this.pressureRT) this.pressureRT.dispose();
  if (this.targetPositionRT) this.targetPositionRT.dispose();
  
  if (this.densityMaterial) this.densityMaterial.dispose();
  if (this.pressureMaterial) this.pressureMaterial.dispose();
  if (this.forceMaterial) this.forceMaterial.dispose();
  if (this.integrateMaterial) this.integrateMaterial.dispose();
  
  if (this.quad && this.quad.geometry) this.quad.geometry.dispose();
  
  this.isInitialized = false;
};

  // ============================================
  // FLOW FIELD CLASS
  // ============================================

  function FlowField(resolution, scale) {
    this.resolution = resolution || CONFIG.flowFieldResolution;
    this.scale = scale || CONFIG.flowFieldScale;
    this.field = null;
    this.noise = new SimplexNoise(Math.random() * 65536);
    this.time = 0;
    this.targetInfluence = 0;
    this.targetPositions = null;
    
    this.init();
  }

  FlowField.prototype.init = function() {
    var res = this.resolution;
    var size = res * res * res * 3;
    this.field = new Float32Array(size);
    this.regenerate(0);
  };

  FlowField.prototype.regenerate = function(time) {
    var res = this.resolution;
    var scale = this.scale;
    var noise = this.noise;
    
    for (var x = 0; x < res; x++) {
      for (var y = 0; y < res; y++) {
        for (var z = 0; z < res; z++) {
          var idx = (x + y * res + z * res * res) * 3;
          
          var nx = x * scale + time * CONFIG.flowFieldTimeScale;
          var ny = y * scale + time * CONFIG.flowFieldTimeScale * 0.7;
          var nz = z * scale + time * CONFIG.flowFieldTimeScale * 0.5;
          
          var vx = noise.noise3D(nx, ny, nz);
          var vy = noise.noise3D(nx + 100, ny + 100, nz + 100);
          var vz = noise.noise3D(nx + 200, ny + 200, nz + 200);
          
          var curl = noise.noise3D(nx * 0.5 + 300, ny * 0.5, nz * 0.5);
          var curlStrength = 0.3;
          
          this.field[idx] = vx + curl * curlStrength * vy;
          this.field[idx + 1] = vy + curl * curlStrength * vz;
          this.field[idx + 2] = vz + curl * curlStrength * vx;
        }
      }
    }
  };

  FlowField.prototype.setTargets = function(positions, influence) {
    this.targetPositions = positions;
    this.targetInfluence = influence || 0;
  };

  FlowField.prototype.update = function(deltaTime) {
    this.time += deltaTime;
    
    if (Math.floor(this.time * 10) !== Math.floor((this.time - deltaTime) * 10)) {
      this.regenerate(this.time);
    }
  };

  FlowField.prototype.sample = function(x, y, z, targetX, targetY, targetZ) {
    var res = this.resolution;
    
    var fx = ((x / 50) + 1) * 0.5 * (res - 1);
    var fy = ((y / 30) + 1) * 0.5 * (res - 1);
    var fz = ((z / 40) + 1) * 0.5 * (res - 1);
    
    fx = Math.max(0, Math.min(res - 1.001, fx));
    fy = Math.max(0, Math.min(res - 1.001, fy));
    fz = Math.max(0, Math.min(res - 1.001, fz));
    
    var x0 = Math.floor(fx);
    var y0 = Math.floor(fy);
    var z0 = Math.floor(fz);
    var x1 = x0 + 1;
    var y1 = y0 + 1;
    var z1 = z0 + 1;
    
    var xd = fx - x0;
    var yd = fy - y0;
    var zd = fz - z0;
    
    var self = this;
    var getIdx = function(xi, yi, zi) {
      return (xi + yi * res + zi * res * res) * 3;
    };
    
    var result = { x: 0, y: 0, z: 0 };
    
    for (var c = 0; c < 3; c++) {
      var c000 = this.field[getIdx(x0, y0, z0) + c];
      var c100 = this.field[getIdx(x1, y0, z0) + c];
      var c010 = this.field[getIdx(x0, y1, z0) + c];
      var c110 = this.field[getIdx(x1, y1, z0) + c];
      var c001 = this.field[getIdx(x0, y0, z1) + c];
      var c101 = this.field[getIdx(x1, y0, z1) + c];
      var c011 = this.field[getIdx(x0, y1, z1) + c];
      var c111 = this.field[getIdx(x1, y1, z1) + c];
      
      var c00 = c000 * (1 - xd) + c100 * xd;
      var c01 = c001 * (1 - xd) + c101 * xd;
      var c10 = c010 * (1 - xd) + c110 * xd;
      var c11 = c011 * (1 - xd) + c111 * xd;
      var c0val = c00 * (1 - yd) + c10 * yd;
      var c1val = c01 * (1 - yd) + c11 * yd;
      var val = c0val * (1 - zd) + c1val * zd;
      
      if (c === 0) result.x = val;
      else if (c === 1) result.y = val;
      else result.z = val;
    }
    
    if (this.targetInfluence > 0 && targetX !== undefined) {
      var toTargetX = targetX - x;
      var toTargetY = targetY - y;
      var toTargetZ = targetZ - z;
      var dist = Math.sqrt(toTargetX * toTargetX + toTargetY * toTargetY + toTargetZ * toTargetZ);
      
      if (dist > 0.1) {
        toTargetX /= dist;
        toTargetY /= dist;
        toTargetZ /= dist;
        
        var inf = this.targetInfluence;
        result.x = result.x * (1 - inf) + toTargetX * inf;
        result.y = result.y * (1 - inf) + toTargetY * inf;
        result.z = result.z * (1 - inf) + toTargetZ * inf;
      }
    }
    
    return result;
  };

  // ============================================
  // MORPH ENGINE CLASS
  // ============================================

  function MorphEngine(options) {
    options = options || {};
    
    this.particleCount = options.particleCount || CONFIG.defaultParticleCount;
    this.viewportSize = options.viewportSize || CONFIG.viewportSize;
    this.zVariation = options.zVariation || CONFIG.zVariation;
    this.debug = options.debug !== undefined ? options.debug : CONFIG.debug;
    this.useGPU = options.useGPU !== undefined ? options.useGPU : CONFIG.useGPU;
    
    // Shape caches
    this.shapes = {};
    this.wordShapes = {};
    this.shapeMetadata = {};
    
    // Animation state
    this.isAnimating = false;
    this.isMorphing = false;
    this.currentAnimation = null;
    this.currentShape = null;
    this.morphProgress = 0;
    this.morphStage = 'idle';
    
    // Fluid simulation components
    this.flowField = new FlowField(
      CONFIG.flowFieldResolution,
      CONFIG.flowFieldScale
    );
    this.spatialHash = new SpatialHash(CONFIG.spatialHashCellSize);
    this.noise = new SimplexNoise(Math.random() * 65536);
    
    // GPU SPH simulator (initialized later with renderer)
    this.gpuSimulator = null;
    this.renderer = null;
    
    // Particle physics state
    this.velocities = null;
    this.accelerations = null;
    this.densities = null;
    this.pressures = null;
    this.startPositions = null;
    this.targetPositions = null;
    
    // Morph parameters
    this.morphStartTime = 0;
    this.morphDuration = 0;
    this.morphOptions = {};
    
    // Animation storage
    this.greetingOrigins = null;
    this.reformOrigins = null;
    this.reformTargets = null;
    
    // Callbacks
    this.onMorphStart = null;
    this.onMorphProgress = null;
    this.onMorphComplete = null;
    this.onStageChange = null;
    
    // Pest control cycling
    this._pestControlCycle = 0;
    
    // Frame counter
    this._frameCount = 0;
    this._lastTime = 0;
    
    // Generate all shapes
    this.generateAllShapes();
    
    if (this.debug) {
      console.log('[MorphEngine] Initialized with', this.particleCount, 'particles');
      console.log('[MorphEngine] GPU mode:', this.useGPU);
      console.log('[MorphEngine] Available shapes:', this.getAvailableShapes());
    }
  }

  // ============================================
// DIRECT GPU PIPELINE MATERIAL
// ============================================

MorphEngine.prototype.createDirectGPUMaterial = function(particleCount, options) {
  options = options || {};
  
  if (!this.gpuSimulator || !this.gpuSimulator.isInitialized) {
    console.warn('[MorphEngine] GPU simulator not initialized, cannot create direct GPU material');
    return null;
  }
  
  var self = this;
  var size = this.gpuSimulator.textureSize;
  
  // Vertex shader for direct GPU sampling
  var vertexShader = [
    'precision highp float;',
    '',
    'attribute float pindex;',
    'attribute vec3 color;',
    'attribute float angle;',
    '',
    'uniform sampler2D tPosition;',
    'uniform sampler2D tVelocity;',
    'uniform sampler2D tPressure;',
    'uniform vec2 uDataResolution;',
    '',
    'uniform float uTime;',
    'uniform float uSize;',
    'uniform float uVoiceAmplitude;',
    'uniform float uMorphProgress;',
    'uniform float uRestDensity;',
    '',
    'uniform float uExplosionActive;',
    'uniform float uExplosionProgress;',
    'uniform vec3 uExplosionOrigin;',
    'uniform float uExplosionRadius;',
    '',
    'varying vec3 vColor;',
    'varying float vAlpha;',
    'varying float vSpeed;',
    'varying float vDensity;',
    'varying float vPressure;',
    'varying float vVoiceGlow;',
    'varying float vMorphProgress;',
    '',
    'float random(float seed) {',
    '  return fract(sin(seed * 12.9898) * 43758.5453123);',
    '}',
    '',
    'void main() {',
    '  float idx = pindex;',
    '  vec2 dataUV = vec2(',
    '    mod(idx, uDataResolution.x) / uDataResolution.x,',
    '    floor(idx / uDataResolution.x) / uDataResolution.y',
    '  ) + 0.5 / uDataResolution;',
    '  ',
    '  vec4 posData = texture2D(tPosition, dataUV);',
    '  vec4 velData = texture2D(tVelocity, dataUV);',
    '  vec4 pressureData = texture2D(tPressure, dataUV);',
    '  ',
    '  vec3 pos = posData.xyz;',
    '  float isActive = posData.w;',
    '  vec3 vel = velData.xyz;',
    '  float density = pressureData.z;',
    '  float pressure = pressureData.x;',
    '  ',
    '  float rnd = random(pindex * 0.01);',
    '  float rnd2 = random(pindex * 0.01 + 42.0);',
    '  ',
    '  vSpeed = length(vel);',
    '  vDensity = density;',
    '  vPressure = pressure;',
    '  vMorphProgress = uMorphProgress;',
    '  ',
    '  // Explosion',
    '  if (uExplosionActive > 0.5) {',
    '    vec3 toParticle = pos - uExplosionOrigin;',
    '    float distFromOrigin = length(toParticle);',
    '    if (distFromOrigin > 0.01) {',
    '      vec3 explosionDir = normalize(toParticle);',
    '      float expandPhase = smoothstep(0.0, 0.4, uExplosionProgress);',
    '      float contractPhase = smoothstep(0.6, 1.0, uExplosionProgress);',
    '      float distanceFactor = 1.0 - smoothstep(0.0, uExplosionRadius * 2.0, distFromOrigin);',
    '      float explosionForce = uExplosionRadius * distanceFactor;',
    '      float displacement = explosionForce * (expandPhase - contractPhase * 0.95);',
    '      float chaos = (rnd - 0.5) * 8.0 * expandPhase * (1.0 - contractPhase);',
    '      pos += explosionDir * displacement;',
    '      pos.x += chaos * rnd2;',
    '      pos.y += chaos * rnd;',
    '    }',
    '  }',
    '  ',
    '  // Voice',
    '  float voiceIntensity = uVoiceAmplitude;',
    '  vVoiceGlow = voiceIntensity;',
    '  pos.z += voiceIntensity * 20.0 * (rnd * 0.6 + 0.4);',
    '  pos.x += cos(angle) * voiceIntensity * 10.0 * rnd;',
    '  pos.y += sin(angle) * voiceIntensity * 10.0 * rnd;',
    '  ',
    '  vColor = color;',
    '  ',
    '  float speedAlpha = 0.6 + vSpeed * 0.03;',
    '  float densityAlpha = 0.8 + (density / max(uRestDensity, 1.0)) * 0.2;',
    '  vAlpha = min(speedAlpha * densityAlpha, 1.0) * isActive;',
    '  ',
    '  if (uExplosionActive > 0.5) {',
    '    vAlpha *= 0.7 + 0.3 * (1.0 - uExplosionProgress);',
    '  }',
    '  ',
    '  vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);',
    '  gl_Position = projectionMatrix * mvPosition;',
    '  ',
    '  float size = uSize;',
    '  float densitySize = clamp(1.0 + (density / max(uRestDensity, 1.0) - 1.0) * 0.3, 0.7, 1.5);',
    '  float speedSize = clamp(1.0 + vSpeed * 0.02, 1.0, 1.4);',
    '  size *= densitySize * speedSize;',
    '  size *= 1.0 + voiceIntensity * 0.5;',
    '  size *= 0.94 + 0.06 * sin(uTime * 2.0 + pindex * 0.1);',
    '  ',
    '  gl_PointSize = clamp(size * (350.0 / -mvPosition.z), 1.5, 70.0);',
    '}'
  ].join('\n');
  
  // Fragment shader
  var fragmentShader = [
    'precision highp float;',
    '',
    'varying vec3 vColor;',
    'varying float vAlpha;',
    'varying float vSpeed;',
    'varying float vDensity;',
    'varying float vPressure;',
    'varying float vVoiceGlow;',
    'varying float vMorphProgress;',
    '',
    'uniform float uTime;',
    'uniform float uRestDensity;',
    'uniform float uExplosionActive;',
    'uniform float uExplosionProgress;',
    'uniform vec3 uIndustryColor;',
    'uniform float uIndustryBlend;',
    '',
    'void main() {',
    '  vec2 uv = gl_PointCoord;',
    '  float dist = length(uv - 0.5);',
    '  if (dist > 0.5) discard;',
    '  ',
    '  float softEdge = 1.0 - smoothstep(0.15, 0.5, dist);',
    '  ',
    '  float densityRatio = vDensity / max(uRestDensity, 1.0);',
    '  vec3 densityShift = vec3(0.15, -0.05, -0.1) * clamp(densityRatio - 1.0, 0.0, 1.0);',
    '  vec3 surfaceShift = vec3(-0.05, 0.0, 0.1) * clamp(1.0 - densityRatio, 0.0, 0.5);',
    '  vec3 fluidColor = vColor + densityShift + surfaceShift;',
    '  ',
    '  float pressureNorm = clamp(vPressure * 0.0008, 0.0, 1.0);',
    '  float coreGlow = (1.0 - smoothstep(0.0, 0.3, dist)) * pressureNorm * 0.6;',
    '  vec3 coreColor = mix(fluidColor, vec3(1.0), coreGlow * 0.5);',
    '  ',
    '  float speedFactor = clamp(vSpeed * 0.04, 0.0, 0.4);',
    '  float trailAlpha = softEdge * (1.0 + speedFactor);',
    '  ',
    '  vec3 industryBlended = mix(coreColor, uIndustryColor, uIndustryBlend * 0.3);',
    '  ',
    '  vec3 voiceBoost = vec3(vVoiceGlow * 0.35);',
    '  float voiceCoreBoost = max(vVoiceGlow * (1.0 - dist * 2.0) * 0.2, 0.0);',
    '  ',
    '  float morphEnergy = sin(uTime * 4.0 + dist * 10.0) * 0.03 * (1.0 - vMorphProgress);',
    '  ',
    '  vec3 explosionShift = vec3(0.0);',
    '  if (uExplosionActive > 0.5) {',
    '    float warmth = uExplosionProgress * (1.0 - uExplosionProgress) * 0.4;',
    '    explosionShift = vec3(warmth, warmth * 0.4, -warmth * 0.2);',
    '  }',
    '  ',
    '  float shimmer = sin(uTime * 3.5 + dist * 15.0 + vSpeed * 2.0) * 0.02;',
    '  ',
    '  vec3 finalColor = industryBlended + voiceBoost + explosionShift;',
    '  finalColor += coreGlow * 0.3 + voiceCoreBoost + morphEnergy + shimmer;',
    '  finalColor = clamp(finalColor, 0.0, 1.2);',
    '  ',
    '  float alpha = trailAlpha * vAlpha + coreGlow * 0.4 + vVoiceGlow * 0.15;',
    '  alpha = clamp(alpha, 0.0, 1.0);',
    '  ',
    '  gl_FragColor = vec4(finalColor, alpha);',
    '}'
  ].join('\n');
  
  // Create material with uniforms that reference GPU render targets
  var material = new THREE.ShaderMaterial({
    uniforms: {
      // SPH data textures - these get updated each frame
      tPosition: { value: null },
      tVelocity: { value: null },
      tPressure: { value: null },
      uDataResolution: { value: new THREE.Vector2(size, size) },
      
      // Standard uniforms
      uTime: { value: 0 },
      uSize: { value: options.size || 4.5 },
      uVoiceAmplitude: { value: 0 },
      uMorphProgress: { value: 0 },
      uRestDensity: { value: CONFIG.sph.restDensity },
      
      // Explosion
      uExplosionActive: { value: 0 },
      uExplosionProgress: { value: 0 },
      uExplosionOrigin: { value: new THREE.Vector3(0, 0, 0) },
      uExplosionRadius: { value: 30 },
      
      // Industry styling
      uIndustryColor: { value: new THREE.Color(options.industryColor || 0x00d4ff) },
      uIndustryBlend: { value: options.industryBlend || 0.2 }
    },
    vertexShader: vertexShader,
    fragmentShader: fragmentShader,
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending
  });
  
  // Store reference for updates
  material._morphEngine = this;
  material._isDirectGPU = true;
  
  return material;
};


// Method to update the direct GPU material each frame
MorphEngine.prototype.updateDirectGPUMaterial = function(material, deltaTime) {
  if (!material || !material._isDirectGPU) return;
  if (!this.gpuSimulator || !this.gpuSimulator.isInitialized) return;
  
  var sim = this.gpuSimulator;
  var uniforms = material.uniforms;
  
  // Update texture references to current render targets
  uniforms.tPosition.value = sim.positionRT[sim.currentRT].texture;
  uniforms.tVelocity.value = sim.velocityRT[sim.currentRT].texture;
  uniforms.tPressure.value = sim.pressureRT ? sim.pressureRT.texture : null;
  
  // Update time
  uniforms.uTime.value += deltaTime;
};


// Helper to check if direct GPU mode is available and beneficial
MorphEngine.prototype.shouldUseDirectGPU = function() {
  if (!this.gpuSimulator || !this.gpuSimulator.isInitialized) return false;
  if (this._contextLost) return false;
  if (this.particleCount < CONFIG.gpuMinParticlesForBenefit) return false;
  if (this.particleCount > CONFIG.gpuMaxParticles) return false;
  
  return true;
};

  // ============================================
// CONTEXT LOSS HANDLING
// ============================================

MorphEngine.prototype._setupContextLossHandling = function() {
  if (!this.renderer || !this.renderer.domElement) {
    if (this.debug) {
      console.warn('[MorphEngine] Cannot setup context loss handling - no renderer');
    }
    return;
  }
  
  var self = this;
  var canvas = this.renderer.domElement;
  
  // Prevent duplicate listeners
  if (this._contextHandlersAttached) return;
  this._contextHandlersAttached = true;
  
  canvas.addEventListener('webglcontextlost', function(event) {
    event.preventDefault();
    
    console.warn('[MorphEngine] WebGL context lost');
    self._contextLost = true;
    self.isAnimating = false;
    self.isMorphing = false;
    
    // Cancel any running animations
    if (self.currentAnimation) {
      cancelAnimationFrame(self.currentAnimation);
      self.currentAnimation = null;
    }
    
    // Dispatch event for external handling
    window.dispatchEvent(new CustomEvent('sw:webglContextLost', {
      detail: { engine: 'morph' }
    }));
    
  }, false);
  
  canvas.addEventListener('webglcontextrestored', function() {
    console.log('[MorphEngine] WebGL context restored, reinitializing...');
    self._contextLost = false;
    
    // Dispose old GPU resources
    if (self.gpuSimulator) {
      try {
        self.gpuSimulator.dispose();
      } catch (e) {
        console.warn('[MorphEngine] Error disposing old GPU simulator:', e);
      }
      self.gpuSimulator = null;
    }
    
    // Reinitialize GPU if it was enabled
    if (self.useGPU && self.renderer) {
      setTimeout(function() {
        self.initGPU(self.renderer);
        
        window.dispatchEvent(new CustomEvent('sw:webglContextRestored', {
          detail: { engine: 'morph', gpuEnabled: self.isGPUEnabled() }
        }));
      }, 100); // Small delay for context stability
    }
    
  }, false);
  
  if (this.debug) {
    console.log('[MorphEngine] Context loss handlers attached');
  }
};


// ============================================
// ENHANCED INIT GPU (with context handling)
// ============================================

// Replace your existing initGPU method with this:
MorphEngine.prototype.initGPU = function(renderer) {
  if (!this.useGPU || !renderer) return false;
  
  // Check for context loss state
  if (this._contextLost) {
    console.warn('[MorphEngine] Cannot init GPU - context lost');
    return false;
  }
  
  this.renderer = renderer;
  
  // Setup context loss handling
  this._setupContextLossHandling();
  
  try {
    this.gpuSimulator = new GPUSPHSimulator(renderer, this.particleCount, CONFIG.sph);
    
    if (this.gpuSimulator.isInitialized) {
      if (this.debug) {
        console.log('[MorphEngine] GPU SPH simulator initialized');
      }
      return true;
    }
  } catch (e) {
    console.warn('[MorphEngine] GPU initialization failed:', e);
  }
  
  this.gpuSimulator = null;
  return false;
};

// ============================================
// ENHANCED DESTROY (with memory leak fix)
// ============================================

// Replace your existing destroy method with this:
MorphEngine.prototype.destroy = function() {
  // Cancel animations
  if (this.currentAnimation) {
    cancelAnimationFrame(this.currentAnimation);
    this.currentAnimation = null;
  }
  
  // Dispose GPU simulator
  if (this.gpuSimulator) {
    try {
      this.gpuSimulator.dispose();
    } catch (e) {
      console.warn('[MorphEngine] Error disposing GPU simulator:', e);
    }
    this.gpuSimulator = null;
  }
  
  // Clear caches
  this.shapes = {};
  this.wordShapes = {};
  this.shapeMetadata = {};
  
  // Clear physics arrays
  this.velocities = null;
  this.accelerations = null;
  this.densities = null;
  this.pressures = null;
  this.startPositions = null;
  this.targetPositions = null;
  this.greetingOrigins = null;
  this.reformOrigins = null;
  this.reformTargets = null;
  
  // Clear references
  this.flowField = null;
  this.spatialHash = null;
  this.noise = null;
  this.renderer = null;
  
  // Clear callbacks
  this.onMorphStart = null;
  this.onMorphProgress = null;
  this.onMorphComplete = null;
  this.onStageChange = null;
  
  // Clear context handling flag
  this._contextHandlersAttached = false;
  this._contextLost = false;
  
  if (this.debug) {
    console.log('[MorphEngine] Destroyed and cleaned up');
  }
};

  MorphEngine.prototype.initGPUWithPositions = function(positions) {
    if (!this.gpuSimulator || !this.gpuSimulator.isInitialized) return false;
    
    var velocities = new Float32Array(this.particleCount * 3);
    return this.gpuSimulator.init(positions, velocities);
  };

  // ============================================
  // SHAPE GENERATION
  // ============================================

  MorphEngine.prototype.generateAllShapes = function() {
    // Geometric shapes
    this.shapes.grid = this.createGridShape();
    this.shapes.sphere = this.createSphereShape();
    this.shapes.ellipsoid = this.createEllipsoidShape();
    this.shapes.torus = this.createTorusShape();
    this.shapes.helix = this.createHelixShape();
    this.shapes.dna = this.createDNAShape();
    this.shapes.wave = this.createWaveShape();
    this.shapes.vortex = this.createVortexShape();
    this.shapes.heart = this.createHeartShape();
    this.shapes.infinity = this.createInfinityShape();
    this.shapes.cube = this.createCubeShape();
    this.shapes.pyramid = this.createPyramidShape();
    this.shapes.ring = this.createRingShape();
    this.shapes.blob = this.createBlobShape();
    this.shapes.fusion_core = this.createFusionCoreShape();
    this.shapes.star = this.createStarShape();
    this.shapes.spiral = this.createSpiralShape();
        // Flagship (NEW)
    this.shapes.flagship = this.createFlagshipShape();
    this.shapes.shockwave_flagship = this.shapes.flagship;

    
    // Industry shapes
    this.shapes.dental = this.createDentalShape();
    this.shapes.tooth = this.shapes.dental;
    
    this.shapes.hvac = this.createHVACShape();
    this.shapes.thermostat = this.shapes.hvac;
    this.shapes.snowflake = this.shapes.hvac;
    
    this.shapes.legal = this.createLegalShape();
    this.shapes.scales = this.shapes.legal;
    this.shapes.gavel = this.createGavelShape();
    
    this.shapes.plumbing = this.createPlumbingShape();
    this.shapes.droplet = this.shapes.plumbing;
    this.shapes.wrench = this.createWrenchShape();
    
    this.shapes.medspa = this.createMedSpaShape();
    this.shapes.sparkle = this.shapes.medspa;
    this.shapes.lotus = this.shapes.medspa;
    this.shapes.face = this.createFaceShape();
    
    this.shapes.pest = this.createPestShape();
    this.shapes.pestcontrol = this.shapes.pest;
    this.shapes.shield = this.createShieldShape();
    this.shapes.ant = this.createAntShape();
    this.shapes.bee = this.createBeeShape();
    
    // Additional shapes
    this.shapes.smile = this.createSmileShape();
    this.shapes.flame = this.createFlameShape();
    this.shapes.checkmark = this.createCheckmarkShape();
    this.shapes.lightning = this.createLightningShape();
    this.shapes.crown = this.createCrownShape();
    this.shapes.diamond = this.createDiamondShape();
    
    if (this.debug) {
      console.log('[MorphEngine] Generated', Object.keys(this.shapes).length, 'shapes');
    }
  };

  // ============================================
  // SHAPE GENERATORS (Abbreviated - same as v2.0)
  // ============================================

  MorphEngine.prototype.createGridShape = function() {
    var points = [];
    var gridSize = 35;
    var spacing = 2;
    var count = Math.floor(gridSize / spacing);
    
    for (var x = 0; x < count; x++) {
      for (var y = 0; y < count; y++) {
        points.push(new THREE.Vector3(
          (x - count / 2) * spacing,
          (y - count / 2) * spacing,
          (Math.random() - 0.5) * this.zVariation * 0.25
        ));
      }
    }
    
    return this.normalizeToParticleCount(points);
  };

  MorphEngine.prototype.createSphereShape = function(radius) {
    radius = radius || 30;
    var points = [];
    var goldenRatio = (1 + Math.sqrt(5)) / 2;
    var angleIncrement = Math.PI * 2 * goldenRatio;
    
    for (var i = 0; i < this.particleCount; i++) {
      var t = i / this.particleCount;
      var inclination = Math.acos(1 - 2 * t);
      var azimuth = angleIncrement * i;
      var r = radius * (0.7 + Math.random() * 0.3);
      
      points.push(new THREE.Vector3(
        r * Math.sin(inclination) * Math.cos(azimuth),
        r * Math.sin(inclination) * Math.sin(azimuth),
        r * Math.cos(inclination)
      ));
    }
    
    return points;
  };

  MorphEngine.prototype.createEllipsoidShape = function(sx, sy, sz) {
    sx = sx || 45;
    sy = sy || 25;
    sz = sz || 40;
    var points = [];
    
    for (var i = 0; i < this.particleCount; i++) {
      var r = Math.cbrt(Math.random());
      var theta = Math.random() * Math.PI * 2;
      var phi = Math.acos(2 * Math.random() - 1);
      
      points.push(new THREE.Vector3(
        r * Math.sin(phi) * Math.cos(theta) * sx,
        r * Math.sin(phi) * Math.sin(theta) * sy,
        r * Math.cos(phi) * sz
      ));
    }
    
    return points;
  };

  MorphEngine.prototype.createTorusShape = function(majorR, minorR) {
    majorR = majorR || 28;
    minorR = minorR || 10;
    var points = [];
    
    for (var i = 0; i < this.particleCount; i++) {
      var u = Math.random() * Math.PI * 2;
      var v = Math.random() * Math.PI * 2;
      var r = minorR * (0.7 + Math.random() * 0.3);
      
      points.push(new THREE.Vector3(
        (majorR + r * Math.cos(v)) * Math.cos(u),
        r * Math.sin(v),
        (majorR + r * Math.cos(v)) * Math.sin(u)
      ));
    }
    
    return this.normalizeToParticleCount(points);
  };

  MorphEngine.prototype.createHelixShape = function() {
    var radius = 20, height = 60, turns = 3;
    var points = [];
    
    for (var i = 0; i < this.particleCount; i++) {
      var t = i / this.particleCount;
      var angle = t * Math.PI * 2 * turns;
      var y = (t - 0.5) * height;
      var thickness = 4;
      var offsetAngle = Math.random() * Math.PI * 2;
      var offsetR = Math.random() * thickness;
      
      points.push(new THREE.Vector3(
        Math.cos(angle) * radius + Math.cos(offsetAngle) * offsetR,
        y + Math.sin(offsetAngle) * offsetR * 0.5,
        Math.sin(angle) * radius + Math.sin(offsetAngle) * offsetR
      ));
    }
    
    return points;
  };

  MorphEngine.prototype.createDNAShape = function() {
    var radius = 18, height = 60, turns = 2.5;
    var points = [];
    
    var strandCount = Math.floor(this.particleCount * 0.4);
    var connectorCount = this.particleCount - strandCount * 2;
    
    for (var i = 0; i < strandCount; i++) {
      var t = i / strandCount;
      var angle = t * Math.PI * 2 * turns;
      var y = (t - 0.5) * height;
      
      points.push(new THREE.Vector3(
        Math.cos(angle) * radius + (Math.random() - 0.5) * 2,
        y + (Math.random() - 0.5) * 2,
        Math.sin(angle) * radius + (Math.random() - 0.5) * 2
      ));
    }
    
    for (var j = 0; j < strandCount; j++) {
      var t2 = j / strandCount;
      var angle2 = t2 * Math.PI * 2 * turns + Math.PI;
      var y2 = (t2 - 0.5) * height;
      
      points.push(new THREE.Vector3(
        Math.cos(angle2) * radius + (Math.random() - 0.5) * 2,
        y2 + (Math.random() - 0.5) * 2,
        Math.sin(angle2) * radius + (Math.random() - 0.5) * 2
      ));
    }
    
    for (var k = 0; k < connectorCount; k++) {
      var t3 = k / connectorCount;
      var angle3 = t3 * Math.PI * 2 * turns;
      var y3 = (t3 - 0.5) * height;
      var rungPos = Math.random();
      
      var x1 = Math.cos(angle3) * radius;
      var z1 = Math.sin(angle3) * radius;
      var x2 = Math.cos(angle3 + Math.PI) * radius;
      var z2 = Math.sin(angle3 + Math.PI) * radius;
      
      points.push(new THREE.Vector3(
        x1 + (x2 - x1) * rungPos,
        y3,
        z1 + (z2 - z1) * rungPos
      ));
    }
    
    return this.normalizeToParticleCount(points);
  };

  MorphEngine.prototype.createWaveShape = function() {
    var width = 80, depth = 40, amp = 15;
    var points = [];
    
    for (var i = 0; i < this.particleCount; i++) {
      var x = (Math.random() - 0.5) * width;
      var z = (Math.random() - 0.5) * depth;
      var wave1 = Math.sin(x * 0.15) * amp;
      var wave2 = Math.sin(z * 0.12 + x * 0.08) * amp * 0.5;
      
      points.push(new THREE.Vector3(
        x,
        wave1 + wave2 + (Math.random() - 0.5) * 3,
        z
      ));
    }
    
    return points;
  };

  MorphEngine.prototype.createVortexShape = function() {
    var maxR = 35, height = 50, spirals = 4;
    var points = [];
    
    for (var i = 0; i < this.particleCount; i++) {
      var t = i / this.particleCount;
      var y = (t - 0.5) * height;
      var heightFactor = Math.abs(y / (height * 0.5));
      var radius = maxR * (0.2 + heightFactor * 0.8);
      var angle = t * Math.PI * 2 * spirals + heightFactor * Math.PI;
      
      points.push(new THREE.Vector3(
        Math.cos(angle) * radius * (0.8 + Math.random() * 0.4),
        y,
        Math.sin(angle) * radius * (0.8 + Math.random() * 0.4)
      ));
    }
    
    return points;
  };

  MorphEngine.prototype.createHeartShape = function() {
    var scale = 1.5;
    var points = [];
    
    for (var i = 0; i < this.particleCount; i++) {
      var t = (i / this.particleCount) * Math.PI * 2;
      var r = Math.cbrt(Math.random());
      
      var x = 16 * Math.pow(Math.sin(t), 3);
      var y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
      var z = (Math.random() - 0.5) * 8;
      
      points.push(new THREE.Vector3(x * scale * r, y * scale * r, z * r));
    }
    
    return this.normalizeToParticleCount(points);
  };

  MorphEngine.prototype.createInfinityShape = function() {
    var scale = 25;
    var points = [];
    
    for (var i = 0; i < this.particleCount; i++) {
      var t = (i / this.particleCount) * Math.PI * 2;
      var thickness = 4;
      
      var denom = 1 + Math.sin(t) * Math.sin(t);
      var x = (scale * Math.cos(t)) / denom;
      var y = (scale * Math.sin(t) * Math.cos(t)) / denom;
      
      points.push(new THREE.Vector3(
        x + (Math.random() - 0.5) * thickness,
        y + (Math.random() - 0.5) * thickness,
        (Math.random() - 0.5) * thickness * 1.5
      ));
    }
    
    return this.normalizeToParticleCount(points);
  };

  MorphEngine.prototype.createCubeShape = function() {
    var size = 35;
    var points = [];
    var half = size / 2;
    
    for (var i = 0; i < this.particleCount; i++) {
      var face = Math.floor(Math.random() * 6);
      var u = (Math.random() - 0.5) * size;
      var v = (Math.random() - 0.5) * size;
      var point = new THREE.Vector3();
      
      switch (face) {
        case 0: point.set(half, u, v); break;
        case 1: point.set(-half, u, v); break;
        case 2: point.set(u, half, v); break;
        case 3: point.set(u, -half, v); break;
        case 4: point.set(u, v, half); break;
        case 5: point.set(u, v, -half); break;
      }
      
      points.push(point);
    }
    
    return this.normalizeToParticleCount(points);
  };

  MorphEngine.prototype.createPyramidShape = function() {
    var base = 40, height = 45;
    var points = [];
    
    for (var i = 0; i < this.particleCount; i++) {
      var t = Math.random();
      var y = -height / 2 + t * height;
      var levelSize = base * (1 - t);
      
      points.push(new THREE.Vector3(
        (Math.random() - 0.5) * levelSize,
        y,
        (Math.random() - 0.5) * levelSize
      ));
    }
    
    return this.normalizeToParticleCount(points);
  };

  MorphEngine.prototype.createRingShape = function() {
    var radius = 30, thickness = 6;
    var points = [];
    
    for (var i = 0; i < this.particleCount; i++) {
      var angle = Math.random() * Math.PI * 2;
      var r = radius + (Math.random() - 0.5) * thickness;
      var y = (Math.random() - 0.5) * thickness;
      
      points.push(new THREE.Vector3(
        Math.cos(angle) * r,
        y,
        Math.sin(angle) * r
      ));
    }
    
    return this.normalizeToParticleCount(points);
  };

  MorphEngine.prototype.createBlobShape = function() {
    var baseRadius = 35;
    var points = [];
    var noise = this.noise;
    
    for (var i = 0; i < this.particleCount; i++) {
      var u = Math.random();
      var v = Math.random();
      var theta = 2 * Math.PI * u;
      var phi = Math.acos(2 * v - 1);
      
      var r = baseRadius;
      var noiseVal = noise.noise3D(
        Math.sin(phi) * Math.cos(theta) * 2,
        Math.sin(phi) * Math.sin(theta) * 2,
        Math.cos(phi) * 2
      );
      r *= 1 + noiseVal * 0.25;
      
      points.push(new THREE.Vector3(
        r * Math.sin(phi) * Math.cos(theta),
        r * Math.sin(phi) * Math.sin(theta),
        r * Math.cos(phi) * 0.7
      ));
    }
    
    return this.normalizeToParticleCount(points);
  };

  MorphEngine.prototype.createFusionCoreShape = function() {
    var innerR = 18, outerR = 33, outerr = 8;
    var points = [];
    
    var innerCount = Math.floor(this.particleCount * 0.65);
    var outerCount = this.particleCount - innerCount;
    
    for (var i = 0; i < innerCount; i++) {
      var u = Math.random();
      var v = Math.random();
      var theta = 2 * Math.PI * u;
      var phi = Math.acos(2 * v - 1);
      var r = innerR * Math.cbrt(Math.random());
      
      points.push(new THREE.Vector3(
        r * Math.sin(phi) * Math.cos(theta),
        r * Math.sin(phi) * Math.sin(theta),
        r * Math.cos(phi) * 0.9
      ));
    }
    
    for (var j = 0; j < outerCount; j++) {
      var u2 = Math.random() * Math.PI * 2;
      var v2 = Math.random() * Math.PI * 2;
      
      points.push(new THREE.Vector3(
        (outerR + outerr * Math.cos(v2)) * Math.cos(u2),
        (outerR + outerr * Math.cos(v2)) * Math.sin(u2),
        outerr * Math.sin(v2) * 1.1
      ));
    }
    
    return this.normalizeToParticleCount(points);
  };

  MorphEngine.prototype.createFlagshipShape = function() {
  var points = [];

  // Ship oriented along +X (forward). Tail is -X.
  var length = 70;
  var halfL = length / 2;

  var maxWidth = 18;
  var maxHeight = 10;

  // Density budget
  var spineCount   = Math.floor(this.particleCount * 0.45);
  var hullCount    = Math.floor(this.particleCount * 0.35);
  var engineCount  = Math.floor(this.particleCount * 0.15);
  var bridgeCount  = this.particleCount - spineCount - hullCount - engineCount;

  // Helper: wedge width taper (wide at tail, tight at nose)
  function widthAt(x) {
    var t = (x + halfL) / length;         // 0 at tail, 1 at nose
    var w = maxWidth * (1.0 - 0.82 * t);  // strong taper
    return Math.max(1.2, w);
  }

  function heightAt(x) {
    var t = (x + halfL) / length;
    var h = maxHeight * (1.0 - 0.65 * t);
    return Math.max(1.0, h);
  }

  // 1) Dense spine (centerline “command ship keel”)
  for (var i = 0; i < spineCount; i++) {
    var t = i / Math.max(1, spineCount - 1);
    var x = -halfL + t * length;

    var w = widthAt(x) * 0.18;   // spine is narrow
    var h = heightAt(x) * 0.22;

    // Slight ridge bump near the front third
    var ridge = Math.exp(-Math.pow((t - 0.72) / 0.12, 2)) * 1.8;

    points.push(new THREE.Vector3(
      x + (Math.random() - 0.5) * 0.9,
      (Math.random() - 0.5) * h + ridge * (Math.random() * 0.35),
      (Math.random() - 0.5) * w
    ));
  }

  // 2) Hull plates (upper/lower decks + side walls)
  for (var j = 0; j < hullCount; j++) {
    var tx = Math.random();
    var x2 = -halfL + tx * length;

    var w2 = widthAt(x2);
    var h2 = heightAt(x2);

    // Choose surface: top, bottom, left, right
    var face = Math.floor(Math.random() * 4);

    var y2, z2;

    if (face === 0) { // top deck
      y2 = h2 * (0.35 + Math.random() * 0.65);
      z2 = (Math.random() - 0.5) * w2 * 0.85;
    } else if (face === 1) { // bottom deck
      y2 = -h2 * (0.35 + Math.random() * 0.65);
      z2 = (Math.random() - 0.5) * w2 * 0.85;
    } else if (face === 2) { // left wall
      z2 = -w2 * (0.35 + Math.random() * 0.65);
      y2 = (Math.random() - 0.5) * h2 * 0.8;
    } else { // right wall
      z2 = w2 * (0.35 + Math.random() * 0.65);
      y2 = (Math.random() - 0.5) * h2 * 0.8;
    }

    // Plate jitter (keeps “panels” look without becoming noise)
    var plateJitter = 0.9;
    points.push(new THREE.Vector3(
      x2 + (Math.random() - 0.5) * 1.4,
      y2 + (Math.random() - 0.5) * plateJitter,
      z2 + (Math.random() - 0.5) * plateJitter
    ));
  }

  // 3) Engine cluster at tail (-X)
  for (var k = 0; k < engineCount; k++) {
    // Cluster around tail quarter
    var x3 = -halfL + Math.random() * (length * 0.18);

    // 3–5 “nozzles” implied by rings in YZ
    var nozzle = k % 4;
    var ringR = 3.0 + nozzle * 1.1;

    var a = Math.random() * Math.PI * 2;
    var y3 = Math.cos(a) * ringR + (Math.random() - 0.5) * 0.8;
    var z3 = Math.sin(a) * ringR + (Math.random() - 0.5) * 0.8;

    points.push(new THREE.Vector3(
      x3 + (Math.random() - 0.5) * 1.4,
      y3,
      z3
    ));
  }

  // 4) Bridge ridge bump (small raised area near front)
  for (var b = 0; b < bridgeCount; b++) {
    var t4 = 0.62 + Math.random() * 0.25; // front third
    var x4 = -halfL + t4 * length;

    var w4 = widthAt(x4) * 0.35;
    var h4 = heightAt(x4) * 0.35;

    points.push(new THREE.Vector3(
      x4 + (Math.random() - 0.5) * 1.0,
      h4 * (0.45 + Math.random() * 0.55),
      (Math.random() - 0.5) * w4
    ));
  }

  // Normalize to exact particleCount, center, scale
  return this.normalizeToParticleCount(points);
};

  MorphEngine.prototype.createStarShape = function() {
    var numPoints = 5, outerR = 30, innerR = 15;
    var points = [];
    
    for (var i = 0; i < this.particleCount; i++) {
      var t = i / this.particleCount;
      var angle = t * Math.PI * 2;
      var starAngle = angle * numPoints;
      var starFactor = Math.pow(Math.abs(Math.sin(starAngle)), 0.45);
      var r = innerR + (outerR - innerR) * starFactor;
      r *= 0.7 + Math.random() * 0.6;
      
      points.push(new THREE.Vector3(
        Math.cos(angle) * r,
        Math.sin(angle) * r,
        (Math.random() - 0.5) * 8
      ));
    }
    
    return this.normalizeToParticleCount(points);
  };

  MorphEngine.prototype.createSpiralShape = function() {
    var turns = 5, radius = 25, height = 50;
    var points = [];
    
    for (var i = 0; i < this.particleCount; i++) {
      var t = i / this.particleCount;
      var angle = t * Math.PI * 2 * turns;
      var y = (t - 0.5) * height;
      var r = radius * (0.5 + t * 0.5);
      
      points.push(new THREE.Vector3(
        Math.cos(angle) * r + (Math.random() - 0.5) * 3,
        y + (Math.random() - 0.5) * 2,
        Math.sin(angle) * r + (Math.random() - 0.5) * 3
      ));
    }
    
    return this.normalizeToParticleCount(points);
  };

  // ============================================
  // INDUSTRY SHAPES
  // ============================================

  MorphEngine.prototype.createDentalShape = function() {
    var points = [];
    var segments = 80;
    
    for (var i = 0; i < segments; i++) {
      var t = (i / segments) * Math.PI * 2;
      var baseRadiusX = 8;
      var baseRadiusY = 10;
      
      var cuspWave = Math.sin(t * 3) * 2.5;
      var isTopHalf = Math.sin(t) > 0;
      var cuspEffect = isTopHalf ? cuspWave : 0;
      
      var r = baseRadiusX + cuspEffect;
      var x = r * Math.cos(t);
      var y = baseRadiusY * Math.sin(t) * 1.2;
      var z = (Math.random() - 0.5) * this.zVariation;
      
      points.push(new THREE.Vector3(x, y, z));
    }
    
    var rootPoints = [
      { x: -3.5, yStart: -8, yEnd: -15 },
      { x: 3.5, yStart: -8, yEnd: -15 }
    ];
    
    var self = this;
    rootPoints.forEach(function(root) {
      for (var y = root.yStart; y >= root.yEnd; y -= 0.4) {
        var progress = (root.yStart - y) / (root.yStart - root.yEnd);
        var taper = 1 - progress * 0.65;
        var width = 2.2 * taper;
        
        points.push(new THREE.Vector3(root.x - width / 2, y, Math.random() * 0.6));
        points.push(new THREE.Vector3(root.x + width / 2, y, Math.random() * 0.6));
        points.push(new THREE.Vector3(root.x, y, Math.random() * 0.9));
      }
    });
    
    for (var j = 0; j < 250; j++) {
      var angle = Math.random() * Math.PI * 2;
      var radius = Math.random() * 6.5;
      var x2 = radius * Math.cos(angle);
      var y2 = radius * Math.sin(angle) * 1.2;
      
      if (y2 > -8) {
        points.push(new THREE.Vector3(x2, y2, (Math.random() - 0.5) * this.zVariation * 0.5));
      }
    }
    
    this.shapeMetadata.dental = { name: 'Tooth', industry: 'dental' };
    return this.normalizeToParticleCount(points);
  };

  MorphEngine.prototype.createSmileShape = function() {
    var points = [];
    var teethCount = 8;
    var particlesPerTooth = Math.floor(this.particleCount / teethCount);
    
    for (var tooth = 0; tooth < teethCount; tooth++) {
      var arcAngle = (tooth / (teethCount - 1) - 0.5) * Math.PI * 0.8;
      var arcRadius = 30;
      
      var toothCenterX = Math.sin(arcAngle) * arcRadius;
      var toothCenterY = Math.cos(arcAngle) * arcRadius * 0.3 - 5;
      
      for (var p = 0; p < particlesPerTooth; p++) {
        var localX = (Math.random() - 0.5) * 5;
        var localY = Math.random() * 12;
        var localZ = (Math.random() - 0.5) * 3;
        
        points.push(new THREE.Vector3(
          toothCenterX + localX,
          toothCenterY + localY,
          localZ
        ));
      }
    }
    
    while (points.length < this.particleCount) {
      var angle = (Math.random() - 0.5) * Math.PI * 0.8;
      points.push(new THREE.Vector3(
        Math.sin(angle) * 30 + (Math.random() - 0.5) * 3,
        Math.cos(angle) * 10 + Math.random() * 10,
        (Math.random() - 0.5) * 3
      ));
    }
    
    return this.normalizeToParticleCount(points);
  };

  MorphEngine.prototype.createHVACShape = function() {
    var points = [];
    var arms = 6;
    var particlesPerArm = Math.floor(this.particleCount / arms);
    
    for (var arm = 0; arm < arms; arm++) {
      var armAngle = (arm / arms) * Math.PI * 2;
      
      for (var p = 0; p < particlesPerArm; p++) {
        var t = p / particlesPerArm;
        
        var armLength = 25 * t;
        var x = Math.cos(armAngle) * armLength;
        var y = Math.sin(armAngle) * armLength;
        
        var branchChance = Math.random();
        if (branchChance > 0.6 && t > 0.2) {
          var branchAngle = armAngle + (Math.random() > 0.5 ? 1 : -1) * Math.PI / 3;
          var branchLength = (1 - t) * 12 * Math.random();
          x += Math.cos(branchAngle) * branchLength;
          y += Math.sin(branchAngle) * branchLength;
        }
        
        x += (Math.random() - 0.5) * 2;
        y += (Math.random() - 0.5) * 2;
        var z = (Math.random() - 0.5) * 4;
        
        points.push(new THREE.Vector3(x, y, z));
      }
    }
    
    while (points.length < this.particleCount) {
      var r = Math.random() * 5;
      var angle = Math.random() * Math.PI * 2;
      points.push(new THREE.Vector3(
        Math.cos(angle) * r,
        Math.sin(angle) * r,
        (Math.random() - 0.5) * 3
      ));
    }
    
    this.shapeMetadata.hvac = { name: 'Snowflake', industry: 'hvac' };
    return this.normalizeToParticleCount(points);
  };

  MorphEngine.prototype.createFlameShape = function() {
    var points = [];
    
    for (var i = 0; i < this.particleCount; i++) {
      var t = Math.random();
      
      var height = t * 40;
      var widthAtHeight = 15 * (1 - t * 0.7) * (0.3 + Math.sin(t * Math.PI) * 0.7);
      
      var flicker = Math.sin(t * Math.PI * 3 + Math.random() * Math.PI) * 3;
      
      var angle = Math.random() * Math.PI * 2;
      var r = Math.sqrt(Math.random()) * widthAtHeight;
      
      points.push(new THREE.Vector3(
        Math.cos(angle) * r + flicker * (1 - t),
        height - 15,
        Math.sin(angle) * r * 0.6 + (Math.random() - 0.5) * 2
      ));
    }
    
    this.shapeMetadata.flame = { name: 'Flame', industry: 'hvac' };
    return this.normalizeToParticleCount(points);
  };

  MorphEngine.prototype.createLegalShape = function() {
    var points = [];
    
    var postCount = Math.floor(this.particleCount * 0.15);
    var beamCount = Math.floor(this.particleCount * 0.15);
    var leftPanCount = Math.floor(this.particleCount * 0.3);
    var rightPanCount = Math.floor(this.particleCount * 0.3);
    var chainCount = this.particleCount - postCount - beamCount - leftPanCount - rightPanCount;
    
    for (var i = 0; i < postCount; i++) {
      points.push(new THREE.Vector3(
        (Math.random() - 0.5) * 3,
        (Math.random() - 0.5) * 50 - 5,
        (Math.random() - 0.5) * 3
      ));
    }
    
    for (var j = 0; j < beamCount; j++) {
      points.push(new THREE.Vector3(
        (Math.random() - 0.5) * 50,
        18 + (Math.random() - 0.5) * 3,
        (Math.random() - 0.5) * 3
      ));
    }
    
    for (var k = 0; k < leftPanCount; k++) {
      var angle = Math.random() * Math.PI * 2;
      var r = Math.sqrt(Math.random()) * 10;
      var depth = r * 0.3;
      
      points.push(new THREE.Vector3(
        -20 + Math.cos(angle) * r,
        -5 - depth + (Math.random() - 0.5) * 2,
        Math.sin(angle) * r
      ));
    }
    
    for (var l = 0; l < rightPanCount; l++) {
      var angle2 = Math.random() * Math.PI * 2;
      var r2 = Math.sqrt(Math.random()) * 10;
      var depth2 = r2 * 0.3;
      
      points.push(new THREE.Vector3(
        20 + Math.cos(angle2) * r2,
        -5 - depth2 + (Math.random() - 0.5) * 2,
        Math.sin(angle2) * r2
      ));
    }
    
    for (var m = 0; m < chainCount; m++) {
      var side = m % 2 === 0 ? -1 : 1;
      var chainT = Math.random();
      
      points.push(new THREE.Vector3(
        side * 20 + (Math.random() - 0.5) * 2,
        18 - chainT * 23 + (Math.random() - 0.5) * 1,
        (Math.random() - 0.5) * 2
      ));
    }
    
    this.shapeMetadata.legal = { name: 'Scales', industry: 'legal' };
    return this.normalizeToParticleCount(points);
  };

  MorphEngine.prototype.createGavelShape = function() {
    var points = [];
    
    var headCount = Math.floor(this.particleCount * 0.5);
    var handleCount = this.particleCount - headCount;
    
    for (var i = 0; i < headCount; i++) {
      var angle = Math.random() * Math.PI * 2;
      var r = Math.sqrt(Math.random()) * 8;
      var length = (Math.random() - 0.5) * 25;
      
      points.push(new THREE.Vector3(
        length,
        10 + Math.cos(angle) * r,
        Math.sin(angle) * r
      ));
    }
    
    for (var j = 0; j < handleCount; j++) {
      var handleT = Math.random();
      var handleAngle = Math.random() * Math.PI * 2;
      var handleR = Math.sqrt(Math.random()) * 3;
      
      points.push(new THREE.Vector3(
        -5 + handleT * 10,
        5 - handleT * 30 + Math.cos(handleAngle) * handleR,
        Math.sin(handleAngle) * handleR
      ));
    }
    
    this.shapeMetadata.gavel = { name: 'Gavel', industry: 'legal' };
    return this.normalizeToParticleCount(points);
  };

  MorphEngine.prototype.createPlumbingShape = function() {
    var points = [];
    
    for (var i = 0; i < this.particleCount; i++) {
      var t = Math.random();
      
      var y = (t - 0.5) * 40;
      var normalizedY = (y + 20) / 40;
      var radius;
      
      if (normalizedY < 0.6) {
        radius = 15 * Math.sin(normalizedY / 0.6 * Math.PI);
      } else {
        radius = 15 * Math.sin(Math.PI) * (1 - (normalizedY - 0.6) / 0.4);
        radius = Math.max(radius, 0.5);
      }
      
      var angle = Math.random() * Math.PI * 2;
      var r = Math.sqrt(Math.random()) * radius;
      
      points.push(new THREE.Vector3(
        Math.cos(angle) * r,
        y,
        Math.sin(angle) * r * 0.8
      ));
    }
    
    this.shapeMetadata.plumbing = { name: 'Droplet', industry: 'plumbing' };
    return this.normalizeToParticleCount(points);
  };

  MorphEngine.prototype.createWrenchShape = function() {
    var points = [];
    
    var handleCount = Math.floor(this.particleCount * 0.5);
    var jawCount = this.particleCount - handleCount;
    
    for (var i = 0; i < handleCount; i++) {
      var handleT = Math.random();
      var angle = Math.random() * Math.PI * 2;
      var r = Math.sqrt(Math.random()) * 3;
      
      points.push(new THREE.Vector3(
        -25 + handleT * 35,
        Math.cos(angle) * r,
        Math.sin(angle) * r
      ));
    }
    
    for (var j = 0; j < jawCount; j++) {
      var jawT = Math.random();
      var jawAngle = Math.random() * Math.PI * 2;
      var jawR = Math.sqrt(Math.random()) * 4;
      
      if (j % 2 === 0) {
        points.push(new THREE.Vector3(
          10 + jawT * 12,
          5 + jawT * 8 + Math.cos(jawAngle) * jawR * 0.5,
          Math.sin(jawAngle) * jawR
        ));
      } else {
        points.push(new THREE.Vector3(
          10 + jawT * 15,
          -2 - jawT * 5 + Math.cos(jawAngle) * jawR * 0.5,
          Math.sin(jawAngle) * jawR
        ));
      }
    }
    
    this.shapeMetadata.wrench = { name: 'Wrench', industry: 'plumbing' };
    return this.normalizeToParticleCount(points);
  };

  MorphEngine.prototype.createMedSpaShape = function() {
    var points = [];
    var numRays = 4;
    var innerRadius = 2.5;
    var outerRadius = 13;
    
    for (var i = 0; i < 120; i++) {
      var angle = (i / 120) * Math.PI * 2;
      var rayAngle = angle * numRays;
      var starFactor = Math.pow(Math.abs(Math.sin(rayAngle)), 0.45);
      var r = innerRadius + (outerRadius - innerRadius) * starFactor;
      
      var x = r * Math.cos(angle);
      var y = r * Math.sin(angle);
      var z = Math.sin(angle * 8) * 1.8;
      
      points.push(new THREE.Vector3(x, y, z));
    }
    
    for (var ray = 0; ray < numRays; ray++) {
      var rayAngle2 = (ray / numRays) * Math.PI * 2 + Math.PI / 4;
      
      for (var t = 0.65; t <= 1.25; t += 0.08) {
        var r2 = outerRadius * t;
        var spread = (1.25 - t) * 1.8;
        
        points.push(new THREE.Vector3(
          r2 * Math.cos(rayAngle2),
          r2 * Math.sin(rayAngle2),
          Math.sin(t * Math.PI) * 2.5
        ));
        
        var perpAngle = rayAngle2 + Math.PI / 2;
        points.push(new THREE.Vector3(
          r2 * Math.cos(rayAngle2) + spread * Math.cos(perpAngle),
          r2 * Math.sin(rayAngle2) + spread * Math.sin(perpAngle),
          Math.sin(t * Math.PI) * 1.8
        ));
        points.push(new THREE.Vector3(
          r2 * Math.cos(rayAngle2) - spread * Math.cos(perpAngle),
          r2 * Math.sin(rayAngle2) - spread * Math.sin(perpAngle),
          Math.sin(t * Math.PI) * 1.8
        ));
      }
    }
    
    for (var j = 0; j < 60; j++) {
      var angle3 = (j / 60) * Math.PI * 2;
      var r3 = Math.pow(Math.random(), 0.5) * innerRadius;
      points.push(new THREE.Vector3(
        r3 * Math.cos(angle3),
        r3 * Math.sin(angle3),
        (Math.random() - 0.5) * 2.5
      ));
    }
    
    for (var spark = 0; spark < 8; spark++) {
      var sparkAngle = (spark / 8) * Math.PI * 2;
      var sparkDist = 9 + Math.random() * 3.5;
      var sparkX = sparkDist * Math.cos(sparkAngle);
      var sparkY = sparkDist * Math.sin(sparkAngle);
      
      for (var k = 0; k < 10; k++) {
        var miniAngle = (k / 10) * Math.PI * 2;
        var miniR = 0.6 + Math.abs(Math.sin(miniAngle * 2)) * 1.2;
        points.push(new THREE.Vector3(
          sparkX + miniR * Math.cos(miniAngle),
          sparkY + miniR * Math.sin(miniAngle),
          2.5 + Math.random()
        ));
      }
    }
    
    this.shapeMetadata.medspa = { name: 'Sparkle', industry: 'medspa' };
    return this.normalizeToParticleCount(points);
  };

  MorphEngine.prototype.createFaceShape = function() {
    var points = [];
    
    for (var i = 0; i < this.particleCount; i++) {
      var t = i / this.particleCount;
      var angle = t * Math.PI * 2;
      
      var baseRadius = 18;
      var radiusX = baseRadius;
      var radiusY = baseRadius * 1.3;
      
      if (angle > Math.PI * 0.8 && angle < Math.PI * 1.2) {
        radiusY *= 0.85;
      }
      
      if (angle > Math.PI * 1.6 || angle < Math.PI * 0.4) {
        radiusY *= 1.05;
      }
      
      var r = 0.85 + Math.random() * 0.3;
      
      points.push(new THREE.Vector3(
        Math.cos(angle) * radiusX * r,
        Math.sin(angle) * radiusY * r,
        (Math.random() - 0.5) * 12
      ));
    }
    
    return this.normalizeToParticleCount(points);
  };

  MorphEngine.prototype.createPestShape = function() {
    var choice = this._pestControlCycle % 2;
    this._pestControlCycle++;
    
    if (choice === 0) {
      return this.createAntShape();
    } else {
      return this.createBeeShape();
    }
  };

  MorphEngine.prototype.createShieldShape = function() {
    var points = [];
    var shieldWidth = 11;
    var shieldHeight = 15;
    
    for (var i = 0; i < 35; i++) {
      var t = i / 35;
      var angle = Math.PI * t;
      var x = shieldWidth * Math.cos(angle);
      var y = shieldHeight * 0.28 + Math.sin(angle) * 2.5;
      points.push(new THREE.Vector3(x, y, 0));
    }
    
    for (var j = 0; j < 30; j++) {
      var t2 = j / 30;
      var y2 = shieldHeight * 0.28 - t2 * shieldHeight * 1.15;
      var x2 = -shieldWidth * (1 - Math.pow(t2, 1.45));
      points.push(new THREE.Vector3(x2, y2, 0));
    }
    
    for (var k = 0; k < 30; k++) {
      var t3 = k / 30;
      var y3 = shieldHeight * 0.28 - t3 * shieldHeight * 1.15;
      var x3 = shieldWidth * (1 - Math.pow(t3, 1.45));
      points.push(new THREE.Vector3(x3, y3, 0));
    }
    
    for (var n = 0; n < 120; n++) {
      var t6 = Math.random();
      var y6 = shieldHeight * 0.18 - t6 * shieldHeight * 0.95;
      var maxX = shieldWidth * 0.68 * (1 - Math.pow(t6, 1.15));
      var x6 = (Math.random() - 0.5) * 2 * maxX;
      
      var distToCheck = Math.abs(x6) + Math.abs(y6);
      if (distToCheck > 5) {
        points.push(new THREE.Vector3(x6, y6, (Math.random() - 0.5) * 0.6));
      }
    }
    
    this.shapeMetadata.shield = { name: 'Shield', industry: 'pest' };
    return this.normalizeToParticleCount(points);
  };

  MorphEngine.prototype.createAntShape = function() {
    var points = [];
    
    var headCount = Math.floor(this.particleCount * 0.2);
    var thoraxCount = Math.floor(this.particleCount * 0.25);
    var abdomenCount = Math.floor(this.particleCount * 0.3);
    var legCount = Math.floor(this.particleCount * 0.2);
    var antennaCount = this.particleCount - headCount - thoraxCount - abdomenCount - legCount;
    
    for (var i = 0; i < headCount; i++) {
      var u = Math.random();
      var v = Math.random();
      var theta = 2 * Math.PI * u;
      var phi = Math.acos(2 * v - 1);
      var r = 5 * Math.cbrt(Math.random());
      
      points.push(new THREE.Vector3(
        18 + r * Math.sin(phi) * Math.cos(theta),
        r * Math.sin(phi) * Math.sin(theta),
        r * Math.cos(phi)
      ));
    }
    
    for (var j = 0; j < thoraxCount; j++) {
      var u2 = Math.random();
      var v2 = Math.random();
      var theta2 = 2 * Math.PI * u2;
      var phi2 = Math.acos(2 * v2 - 1);
      var r2 = 4 * Math.cbrt(Math.random());
      
      points.push(new THREE.Vector3(
        8 + r2 * Math.sin(phi2) * Math.cos(theta2) * 1.2,
        r2 * Math.sin(phi2) * Math.sin(theta2),
        r2 * Math.cos(phi2)
      ));
    }
    
    for (var k = 0; k < abdomenCount; k++) {
      var u3 = Math.random();
      var v3 = Math.random();
      var theta3 = 2 * Math.PI * u3;
      var phi3 = Math.acos(2 * v3 - 1);
      var r3 = Math.cbrt(Math.random());
      
      points.push(new THREE.Vector3(
        -8 + r3 * Math.sin(phi3) * Math.cos(theta3) * 10,
        r3 * Math.sin(phi3) * Math.sin(theta3) * 6,
        r3 * Math.cos(phi3) * 6
      ));
    }
    
    var particlesPerLeg = Math.floor(legCount / 6);
    for (var leg = 0; leg < 6; leg++) {
      var side = leg < 3 ? 1 : -1;
      var legPosition = (leg % 3) / 2 - 0.5;
      var legBaseX = 8 + legPosition * 12;
      
      for (var lp = 0; lp < particlesPerLeg; lp++) {
        var legT = lp / particlesPerLeg;
        var segmentT = legT * 3;
        var legX, legY, legZ;
        
                if (segmentT < 1) {
          legX = legBaseX;
          legY = segmentT * -3;
          legZ = side * (segmentT * 6);
        } else if (segmentT < 2) {
          var t2 = segmentT - 1;
          legX = legBaseX;
          legY = -3 - t2 * 8;
          legZ = side * (6 + t2 * 2);
        } else {
          var t3 = segmentT - 2;
          legX = legBaseX + (Math.random() - 0.5) * 2;
          legY = -11 + t3 * 2;
          legZ = side * (8 + t3 * 4);
        }
        
        points.push(new THREE.Vector3(
          legX + (Math.random() - 0.5),
          legY + (Math.random() - 0.5),
          legZ + (Math.random() - 0.5)
        ));
      }
    }
    
    for (var a = 0; a < antennaCount; a++) {
      var antSide = a % 2 === 0 ? 1 : -1;
      var antT = (a / 2) / (antennaCount / 2);
      
      points.push(new THREE.Vector3(
        22 + antT * 8,
        2 + antT * 6 + Math.sin(antT * Math.PI) * 3,
        antSide * (1 + antT * 4)
      ));
    }
    
    return this.normalizeToParticleCount(points);
  };

  MorphEngine.prototype.createBeeShape = function() {
    var points = [];
    
    var headCount = Math.floor(this.particleCount * 0.15);
    var thoraxCount = Math.floor(this.particleCount * 0.2);
    var abdomenCount = Math.floor(this.particleCount * 0.35);
    var wingCount = Math.floor(this.particleCount * 0.2);
    var legCount = Math.floor(this.particleCount * 0.07);
    var antennaCount = this.particleCount - headCount - thoraxCount - abdomenCount - wingCount - legCount;
    
    // Head
    for (var i = 0; i < headCount; i++) {
      var u = Math.random();
      var v = Math.random();
      var theta = 2 * Math.PI * u;
      var phi = Math.acos(2 * v - 1);
      var r = 5 * Math.cbrt(Math.random());
      
      points.push(new THREE.Vector3(
        15 + r * Math.sin(phi) * Math.cos(theta),
        r * Math.sin(phi) * Math.sin(theta),
        r * Math.cos(phi)
      ));
    }
    
    // Thorax
    for (var j = 0; j < thoraxCount; j++) {
      var u2 = Math.random();
      var v2 = Math.random();
      var theta2 = 2 * Math.PI * u2;
      var phi2 = Math.acos(2 * v2 - 1);
      var r2 = 6 * Math.cbrt(Math.random());
      
      points.push(new THREE.Vector3(
        5 + r2 * Math.sin(phi2) * Math.cos(theta2),
        r2 * Math.sin(phi2) * Math.sin(theta2),
        r2 * Math.cos(phi2)
      ));
    }
    
    // Abdomen
    for (var k = 0; k < abdomenCount; k++) {
      var u3 = Math.random();
      var v3 = Math.random();
      var theta3 = 2 * Math.PI * u3;
      var phi3 = Math.acos(2 * v3 - 1);
      var r3 = Math.cbrt(Math.random());
      
      points.push(new THREE.Vector3(
        -10 + r3 * Math.sin(phi3) * Math.cos(theta3) * 12,
        r3 * Math.sin(phi3) * Math.sin(theta3) * 6,
        r3 * Math.cos(phi3) * 6
      ));
    }
    
    // Wings
    var particlesPerWing = Math.floor(wingCount / 4);
    for (var wing = 0; wing < 4; wing++) {
      var side = wing < 2 ? 1 : -1;
      var isForewing = wing % 2 === 0;
      var wingLength = isForewing ? 18 : 14;
      var wingWidth = isForewing ? 8 : 6;
      var wingAngle = isForewing ? 0.3 : 0.6;
      
      for (var wp = 0; wp < particlesPerWing; wp++) {
        var wingT = wp / particlesPerWing;
        
        var localX = wingT * wingLength;
        var localY = Math.sin(wingT * Math.PI) * wingWidth;
        
        var cosW = Math.cos(wingAngle);
        var sinW = Math.sin(wingAngle);
        
        points.push(new THREE.Vector3(
          5 + localX * cosW,
          5 + localX * sinW + (Math.random() - 0.5) * 2,
          side * (3 + localY)
        ));
      }
    }
    
    // Legs
    for (var leg = 0; leg < legCount; leg++) {
      var legSide = leg % 2 === 0 ? 1 : -1;
      var legPos = Math.floor(leg / 2) / 3;
      
      points.push(new THREE.Vector3(
        5 + legPos * 6 - 3,
        -5 - Math.random() * 5,
        legSide * (4 + Math.random() * 3)
      ));
    }
    
    // Antennae
    for (var ant = 0; ant < antennaCount; ant++) {
      var antSide = ant % 2 === 0 ? 1 : -1;
      var antT = Math.random();
      
      points.push(new THREE.Vector3(
        18 + antT * 5,
        3 + antT * 4,
        antSide * (1 + antT * 2)
      ));
    }
    
    return this.normalizeToParticleCount(points);
  };

  // Additional shapes
  MorphEngine.prototype.createCheckmarkShape = function() {
    var points = [];
    
    var checkPoints = [
      { x: -15, y: -5 }, { x: -10, y: -10 }, { x: -5, y: -15 },
      { x: 0, y: -10 }, { x: 5, y: -5 }, { x: 10, y: 0 },
      { x: 15, y: 5 }, { x: 20, y: 10 }, { x: 25, y: 15 }
    ];
    
    var particlesPerSegment = Math.floor(this.particleCount / (checkPoints.length - 1));
    
    for (var i = 0; i < checkPoints.length - 1; i++) {
      var p1 = checkPoints[i];
      var p2 = checkPoints[i + 1];
      
      for (var p = 0; p < particlesPerSegment; p++) {
        var t = p / particlesPerSegment;
        var x = p1.x + (p2.x - p1.x) * t;
        var y = p1.y + (p2.y - p1.y) * t;
        
        var thickness = 3;
        points.push(new THREE.Vector3(
          x + (Math.random() - 0.5) * thickness,
          y + (Math.random() - 0.5) * thickness,
          (Math.random() - 0.5) * thickness
        ));
      }
    }
    
    return this.normalizeToParticleCount(points);
  };

  MorphEngine.prototype.createLightningShape = function() {
    var points = [];
    var segments = 7;
    var segmentHeight = 10;
    var zigzagAmount = 8;
    
    var currentX = 0;
    var currentY = 30;
    
    for (var seg = 0; seg < segments; seg++) {
      var nextX = currentX + (seg % 2 === 0 ? zigzagAmount : -zigzagAmount);
      var nextY = currentY - segmentHeight;
      
      var particlesPerSegment = Math.floor(this.particleCount / segments);
      
      for (var p = 0; p < particlesPerSegment; p++) {
        var t = p / particlesPerSegment;
        var x = currentX + (nextX - currentX) * t;
        var y = currentY + (nextY - currentY) * t;
        
        var thickness = 4 - seg * 0.3;
        points.push(new THREE.Vector3(
          x + (Math.random() - 0.5) * thickness,
          y + (Math.random() - 0.5) * thickness * 0.5,
          (Math.random() - 0.5) * thickness
        ));
      }
      
      currentX = nextX;
      currentY = nextY;
    }
    
    return this.normalizeToParticleCount(points);
  };

  MorphEngine.prototype.createCrownShape = function() {
    var points = [];
    var numPoints = 5;
    var baseRadius = 20;
    var baseHeight = -8;
    var pointHeight = 15;
    
    for (var i = 0; i < this.particleCount * 0.4; i++) {
      var angle = Math.random() * Math.PI * 2;
      var r = baseRadius + (Math.random() - 0.5) * 3;
      var y = baseHeight + Math.random() * 5;
      
      points.push(new THREE.Vector3(
        Math.cos(angle) * r,
        y,
        Math.sin(angle) * r
      ));
    }
    
    for (var p = 0; p < numPoints; p++) {
      var pointAngle = (p / numPoints) * Math.PI * 2;
      var pointX = Math.cos(pointAngle) * baseRadius;
      var pointZ = Math.sin(pointAngle) * baseRadius;
      
      var particlesPerPoint = Math.floor(this.particleCount * 0.12);
      for (var j = 0; j < particlesPerPoint; j++) {
        var t = j / particlesPerPoint;
        var y2 = baseHeight + 5 + t * pointHeight;
        var taper = 1 - t * 0.7;
        
        points.push(new THREE.Vector3(
          pointX * taper + (Math.random() - 0.5) * 3,
          y2,
          pointZ * taper + (Math.random() - 0.5) * 3
        ));
      }
    }
    
    return this.normalizeToParticleCount(points);
  };

  MorphEngine.prototype.createDiamondShape = function() {
    var points = [];
    var width = 20;
    var topHeight = 25;
    var bottomHeight = 15;
    
    for (var i = 0; i < this.particleCount * 0.6; i++) {
      var t = Math.random();
      var y = t * topHeight;
      var levelSize = width * (1 - t);
      
      points.push(new THREE.Vector3(
        (Math.random() - 0.5) * levelSize,
        y,
        (Math.random() - 0.5) * levelSize
      ));
    }
    
    for (var j = 0; j < this.particleCount * 0.4; j++) {
      var t2 = Math.random();
      var y2 = -t2 * bottomHeight;
      var levelSize2 = width * (1 - t2);
      
      points.push(new THREE.Vector3(
        (Math.random() - 0.5) * levelSize2,
        y2,
        (Math.random() - 0.5) * levelSize2
      ));
    }
    
    return this.normalizeToParticleCount(points);
  };

  // ============================================
  // NORMALIZATION
  // ============================================

  MorphEngine.prototype.normalizeToParticleCount = function(shape, targetCount) {
    var self = this;
    var count = targetCount || this.particleCount;
    
    if (!shape || shape.length === 0) {
      return this.createEllipsoidShape();
    }
    
    var result = [];
    var shapeLen = shape.length;
    
    if (shapeLen >= count) {
      var step = shapeLen / count;
      for (var i = 0; i < count; i++) {
        var idx = Math.floor(i * step);
        var sourcePoint = shape[idx];
        
        var point = sourcePoint.clone();
        point.x += (Math.random() - 0.5) * 0.35;
        point.y += (Math.random() - 0.5) * 0.35;
        point.z += (Math.random() - 0.5) * 0.25;
        
        result.push(point);
      }
    } else {
      for (var j = 0; j < count; j++) {
        var sourceIdx = j % shapeLen;
        var duplicateNum = Math.floor(j / shapeLen);
        var sourcePoint2 = shape[sourceIdx];
        
        var point2 = sourcePoint2.clone();
        
        var spreadFactor = 0.35 + (duplicateNum * 0.15);
        spreadFactor = Math.min(spreadFactor, 1.2);
        
        point2.x += (Math.random() - 0.5) * spreadFactor;
        point2.y += (Math.random() - 0.5) * spreadFactor;
        point2.z += (Math.random() - 0.5) * spreadFactor * 0.7;
        
        result.push(point2);
      }
    }
    
    this.centerAndScale(result);
    return result;
  };

  MorphEngine.prototype.centerAndScale = function(points) {
    if (!points || points.length === 0) return;
    
    var box = new THREE.Box3();
    points.forEach(function(p) { box.expandByPoint(p); });
    
    var center = new THREE.Vector3();
    box.getCenter(center);
    
    var size = new THREE.Vector3();
    box.getSize(size);
    
    var maxDim = Math.max(size.x, size.y, size.z);
    var scale = maxDim > 0 ? this.viewportSize / maxDim : 1;
    
    points.forEach(function(p) {
      p.sub(center);
      p.multiplyScalar(scale);
    });
  };

  // ============================================
  // WORD SHAPE GENERATION
  // ============================================

  MorphEngine.prototype.generateWordShape = function(word) {
  var upperWord = word.toUpperCase();
  
  if (this.wordShapes[upperWord]) {
    return this.wordShapes[upperWord];
  }
  
  var points = [];
  var letterW = CONFIG.letterWidth;
  var letterH = CONFIG.letterHeight;
  var spacing = CONFIG.letterSpacing;
  var thickness = CONFIG.letterThickness;
  
  // CRITICAL FIX: 4 particles per filled cell instead of 3
  var particlesPerCell = CONFIG.particlesPerLetterPixel || 4;
  
  var totalWidth = upperWord.length * (letterW + spacing) - spacing;
  var startX = -totalWidth / 2;
  
  var scale = this.viewportSize / Math.max(totalWidth, letterH * 1.5);
  
  for (var letterIdx = 0; letterIdx < upperWord.length; letterIdx++) {
    var char = upperWord[letterIdx];
    var pattern = LETTER_PATTERNS[char] || LETTER_PATTERNS[' '];
    
    var letterX = startX + letterIdx * (letterW + spacing);
    
    for (var row = 0; row < 7; row++) {
      for (var col = 0; col < 5; col++) {
        if (pattern[row][col] === 1) {
          // ✅ DENSE FILL: 4 particles per cell
          for (var p = 0; p < particlesPerCell; p++) {
            var x = (letterX + col + Math.random() * 0.6) * scale;  // More spread
            var y = ((letterH / 2) - row + Math.random() * 0.6) * scale;
            var z = (Math.random() - 0.5) * thickness * scale;
            
            points.push(new THREE.Vector3(x, y, z));
          }
        }
      }
    }
  }
  
  var normalized = this.normalizeToParticleCount(points);
  this.wordShapes[upperWord] = normalized;
  
  return normalized;
};

  // ============================================
  // MORPHING - MAIN API
  // ============================================

  MorphEngine.prototype.morphToShape = function(particleSystem, shapeName, options) {
    var self = this;
    options = options || {};
    
    return new Promise(function(resolve, reject) {
      if (!particleSystem || !particleSystem.particles) {
        reject(new Error('Invalid particle system'));
        return;
      }
      
      var targetShape = self.shapes[shapeName];
      if (!targetShape) {
        reject(new Error('Shape "' + shapeName + '" not found'));
        return;
      }
      
      var duration = options.duration || CONFIG.defaultMorphDuration;
      var fluid = options.fluid !== false;
      var useSPH = options.sph !== false && self.gpuSimulator && self.gpuSimulator.isInitialized;
      var easing = options.easing || 'fluidEase';
      var turbulence = options.turbulence !== undefined ? options.turbulence : CONFIG.turbulenceStrength;
      
      if (useSPH) {
        self._executeSPHMorph(particleSystem, targetShape, shapeName, duration, easing, turbulence, resolve);
      } else if (fluid) {
        self._executeFluidMorph(particleSystem, targetShape, shapeName, duration, easing, turbulence, resolve);
      } else {
        self._executeSimpleMorph(particleSystem, targetShape, shapeName, duration, easing, resolve);
      }
    });
  };

  MorphEngine.prototype.morphToWord = function(particleSystem, word, options) {
    var self = this;
    options = options || {};
    
    return new Promise(function(resolve, reject) {
      if (!particleSystem || !particleSystem.particles) {
        reject(new Error('Invalid particle system'));
        return;
      }
      
      var targetShape = self.generateWordShape(word);
      var duration = options.duration || CONFIG.wordMorphDuration;
      var fluid = options.fluid !== false;
      var useSPH = options.sph !== false && self.gpuSimulator && self.gpuSimulator.isInitialized;
      var easing = options.easing || 'fluidEase';
      var turbulence = options.turbulence !== undefined ? options.turbulence : CONFIG.turbulenceStrength * 0.7;
      
      var shapeName = 'word:' + word;
      
      if (useSPH) {
        self._executeSPHMorph(particleSystem, targetShape, shapeName, duration, easing, turbulence, resolve);
      } else if (fluid) {
        self._executeFluidMorph(particleSystem, targetShape, shapeName, duration, easing, turbulence, resolve);
      } else {
        self._executeSimpleMorph(particleSystem, targetShape, shapeName, duration, easing, resolve);
      }
    });
  };

  // ============================================
  // SPH MORPH EXECUTION (GPU-Accelerated)
  // ============================================

  MorphEngine.prototype._executeSPHMorph = function(particleSystem, targetShape, shapeName, duration, easingName, turbulenceStrength, onComplete) {
  var self = this;
  
  // Cancel existing animation
  if (this.currentAnimation) {
    cancelAnimationFrame(this.currentAnimation);
    this.currentAnimation = null;
  }
  
  // Check for context loss
  if (this._contextLost) {
    console.warn('[MorphEngine] Cannot execute SPH morph - WebGL context lost');
    if (onComplete) onComplete();
    return;
  }
  
  var particles = particleSystem.particles;
  var geometry = particles.geometry;
  var material = particles.material;
  
  var positions = geometry.attributes.offset || geometry.attributes.position;
  if (!positions) {
    console.error('[MorphEngine] No position attribute found');
    return;
  }
  
  var actualParticleCount = positions.count;
  
  // Normalize target shape
  if (targetShape.length !== actualParticleCount) {
    targetShape = this.normalizeToParticleCount(targetShape, actualParticleCount);
  }
  
  // Initialize GPU simulator with current positions if needed
  if (!this.gpuSimulator.positionRT[0]) {
    this.gpuSimulator.init(positions.array, null);
  }
  
  // Set target positions in GPU
  this.gpuSimulator.setTargetPositions(targetShape);
  
  // Check if we're using direct GPU material (no CPU round-trip needed)
  var useDirectPipeline = material._isDirectGPU === true;
  
  // If not using direct pipeline, setup target attribute for fallback
  if (!useDirectPipeline) {
    var targetAttr = geometry.attributes.targetPosition;
    if (!targetAttr) {
      targetAttr = new THREE.BufferAttribute(new Float32Array(actualParticleCount * 3), 3);
      geometry.setAttribute('targetPosition', targetAttr);
    }
    
    for (var i = 0; i < actualParticleCount; i++) {
      var i3 = i * 3;
      targetAttr.array[i3] = targetShape[i].x;
      targetAttr.array[i3 + 1] = targetShape[i].y;
      targetAttr.array[i3 + 2] = targetShape[i].z;
    }
    targetAttr.needsUpdate = true;
  }
  
  // Setup morph progress uniform
  if (material.uniforms && !material.uniforms.uMorphProgress) {
    material.uniforms.uMorphProgress = { value: 0 };
  }
  
  var easingFn = EASING[easingName] || EASING.fluidEase;
  
  var gatherEnd = CONFIG.stages.gather;
  var streamEnd = gatherEnd + CONFIG.stages.stream;
  
  var startTime = performance.now();
  this.isAnimating = true;
  this.isMorphing = true;
  this.morphStage = 'gather';
  
  // Performance monitoring
  var perfMonitor = new PerformanceMonitor();
  var frameCount = 0;
  var cpuFallbackTriggered = false;
  
  if (this.onMorphStart) {
    this.onMorphStart(shapeName);
  }
  
  var lastFrameTime = startTime;
  
  var animate = function(currentTime) {
    // Check for context loss
    if (self._contextLost) {
      console.warn('[MorphEngine] Animation interrupted - context lost');
      self.isAnimating = false;
      self.isMorphing = false;
      if (onComplete) onComplete();
      return;
    }
    
    perfMonitor.startFrame();
    
    var elapsed = currentTime - startTime;
    var deltaTime = Math.min((currentTime - lastFrameTime) / 1000, 0.033);
    lastFrameTime = currentTime;
    
    var rawProgress = Math.min(elapsed / duration, 1);
    
    // Determine stage
    var prevStage = self.morphStage;
    if (rawProgress < gatherEnd) {
      self.morphStage = 'gather';
    } else if (rawProgress < streamEnd) {
      self.morphStage = 'stream';
    } else {
      self.morphStage = 'settle';
    }
    
    if (prevStage !== self.morphStage && self.onStageChange) {
      self.onStageChange(self.morphStage, rawProgress);
    }
    
    // Calculate target attraction based on stage
    var targetAttraction;
    if (self.morphStage === 'gather') {
      targetAttraction = 0.05;
    } else if (self.morphStage === 'stream') {
      var streamProgress = (rawProgress - gatherEnd) / (streamEnd - gatherEnd);
      targetAttraction = 0.1 + streamProgress * 0.4;
    } else {
      var settleProgress = (rawProgress - streamEnd) / (1 - streamEnd);
      targetAttraction = 0.5 + settleProgress * 0.5;
    }
    
    // Step SPH simulation
    self.gpuSimulator.step(deltaTime, rawProgress, targetAttraction, elapsed / 1000);
    
    // Update rendering based on pipeline mode
    if (useDirectPipeline) {
      // Direct GPU pipeline - just update material uniforms
      self.updateDirectGPUMaterial(material, deltaTime);
      
      if (material.uniforms.uMorphProgress) {
        material.uniforms.uMorphProgress.value = rawProgress;
      }
      
      // Update pressure texture reference if available
      if (material.uniforms.tPressure && self.gpuSimulator.pressureRT) {
        material.uniforms.tPressure.value = self.gpuSimulator.pressureRT.texture;
      }
    } else {
      // Fallback: Read positions back from GPU (the slow path)
      self.gpuSimulator.readPositions(positions.array);
      positions.needsUpdate = true;
      
      var visualProgress = easingFn(rawProgress);
      if (material.uniforms && material.uniforms.uMorphProgress) {
        material.uniforms.uMorphProgress.value = visualProgress;
      }
    }
    
    self.morphProgress = rawProgress;
    
    if (self.onMorphProgress) {
      self.onMorphProgress(rawProgress, self.morphStage, shapeName);
    }
    
    // Performance monitoring
    var frameTime = perfMonitor.endFrame();
    frameCount++;
    
    // Check for performance issues every 30 frames
    if (CONFIG.autoFallbackToCPU && frameCount % 30 === 0 && !cpuFallbackTriggered) {
      var avgFrameTime = perfMonitor.getAverageFrameTime();
      if (avgFrameTime > CONFIG.performanceWarningThreshold * 1.5) {
        console.warn('[MorphEngine] GPU performance degraded, consider reducing particles');
        cpuFallbackTriggered = true;
      }
    }
    
    if (rawProgress < 1) {
      self.currentAnimation = requestAnimationFrame(animate);
    } else {
      // Snap to final positions
      if (!useDirectPipeline) {
        for (var i = 0; i < actualParticleCount; i++) {
          var i3 = i * 3;
          positions.array[i3] = targetShape[i].x;
          positions.array[i3 + 1] = targetShape[i].y;
          positions.array[i3 + 2] = targetShape[i].z;
        }
        positions.needsUpdate = true;
      }
      
      self.isAnimating = false;
      self.isMorphing = false;
      self.currentAnimation = null;
      self.currentShape = shapeName;
      self.morphStage = 'idle';
      
      // Log performance stats
      if (CONFIG.debug) {
        var stats = perfMonitor.getStats();
        console.log('[MorphEngine] Morph complete. Avg FPS:', stats.fps, 
          'Avg frame time:', stats.averageFrameTime + 'ms',
          'Direct GPU:', useDirectPipeline);
      }
      
      if (self.onMorphComplete) {
        self.onMorphComplete(shapeName);
      }
      
      window.dispatchEvent(new CustomEvent('sw:morphComplete', {
        detail: { 
          shape: shapeName, 
          duration: duration, 
          sph: true,
          directGPU: useDirectPipeline,
          avgFPS: perfMonitor.getFPS()
        }
      }));
      
      if (onComplete) onComplete();
    }
  };
  
  this.currentAnimation = requestAnimationFrame(animate);
};

  // ============================================
  // FLUID MORPH EXECUTION (CPU Fallback)
  // ============================================

  MorphEngine.prototype._executeFluidMorph = function(particleSystem, targetShape, shapeName, duration, easingName, turbulenceStrength, onComplete) {
    var self = this;
    
    if (this.currentAnimation) {
      cancelAnimationFrame(this.currentAnimation);
      this.currentAnimation = null;
    }
    
    var particles = particleSystem.particles;
    var geometry = particles.geometry;
    var material = particles.material;
    
    var positions = geometry.attributes.offset || geometry.attributes.position;
    if (!positions) {
      console.error('[MorphEngine] No position attribute found');
      return;
    }
    
    var actualParticleCount = positions.count;
    
    if (targetShape.length !== actualParticleCount) {
      targetShape = this.normalizeToParticleCount(targetShape, actualParticleCount);
    }
    
    // Initialize physics arrays
    if (!this.velocities || this.velocities.length !== actualParticleCount * 3) {
      this.velocities = new Float32Array(actualParticleCount * 3);
    }
    if (!this.startPositions || this.startPositions.length !== actualParticleCount * 3) {
      this.startPositions = new Float32Array(actualParticleCount * 3);
    }
    if (!this.targetPositions || this.targetPositions.length !== actualParticleCount * 3) {
      this.targetPositions = new Float32Array(actualParticleCount * 3);
    }
    
    // Store positions
    for (var i = 0; i < actualParticleCount; i++) {
      var i3 = i * 3;
      this.startPositions[i3] = positions.array[i3];
      this.startPositions[i3 + 1] = positions.array[i3 + 1];
      this.startPositions[i3 + 2] = positions.array[i3 + 2];
      
      this.targetPositions[i3] = targetShape[i].x;
      this.targetPositions[i3 + 1] = targetShape[i].y;
      this.targetPositions[i3 + 2] = targetShape[i].z;
      
      var toTargetX = targetShape[i].x - positions.array[i3];
      var toTargetY = targetShape[i].y - positions.array[i3 + 1];
      var toTargetZ = targetShape[i].z - positions.array[i3 + 2];
      
      this.velocities[i3] = toTargetX * 0.01 + (Math.random() - 0.5) * 2;
      this.velocities[i3 + 1] = toTargetY * 0.01 + (Math.random() - 0.5) * 2;
      this.velocities[i3 + 2] = toTargetZ * 0.01 + (Math.random() - 0.5) * 2;
    }
    
    var targetAttr = geometry.attributes.targetPosition;
    if (!targetAttr) {
      targetAttr = new THREE.BufferAttribute(new Float32Array(actualParticleCount * 3), 3);
      geometry.setAttribute('targetPosition', targetAttr);
    }
    targetAttr.array.set(this.targetPositions);
    targetAttr.needsUpdate = true;
    
    if (material.uniforms && !material.uniforms.uMorphProgress) {
      material.uniforms.uMorphProgress = { value: 0 };
    }
    
    var easingFn = EASING[easingName] || EASING.fluidEase;
    
    var gatherEnd = CONFIG.stages.gather;
    var streamEnd = gatherEnd + CONFIG.stages.stream;
    
    var startTime = performance.now();
    this.isAnimating = true;
    this.isMorphing = true;
    this.morphStage = 'gather';
    
    if (this.onMorphStart) {
      this.onMorphStart(shapeName);
    }
    
    var animate = function(currentTime) {
      var elapsed = currentTime - startTime;
      var rawProgress = Math.min(elapsed / duration, 1);
      
      var prevStage = self.morphStage;
      if (rawProgress < gatherEnd) {
        self.morphStage = 'gather';
      } else if (rawProgress < streamEnd) {
        self.morphStage = 'stream';
      } else {
        self.morphStage = 'settle';
      }
      
      if (prevStage !== self.morphStage && self.onStageChange) {
        self.onStageChange(self.morphStage, rawProgress);
      }
      
      var stageProgress, attractionStrength, flowStrength, turbulence;
      
      if (self.morphStage === 'gather') {
        stageProgress = rawProgress / gatherEnd;
        attractionStrength = CONFIG.gatherCenterStrength * EASING.easeInQuad(stageProgress);
        flowStrength = CONFIG.flowFieldStrength * 0.3;
        turbulence = turbulenceStrength * (1 - stageProgress * 0.5);
        
        self._applyGatherPhysics(positions.array, actualParticleCount, attractionStrength, flowStrength, turbulence);
        
      } else if (self.morphStage === 'stream') {
        stageProgress = (rawProgress - gatherEnd) / (streamEnd - gatherEnd);
        attractionStrength = CONFIG.targetAttractionBase + (CONFIG.targetAttractionMax - CONFIG.targetAttractionBase) * EASING.easeInOutCubic(stageProgress);
        flowStrength = CONFIG.flowFieldStrength * (1 - stageProgress * 0.5);
        turbulence = turbulenceStrength * (1 - stageProgress);
        
        self.flowField.targetInfluence = stageProgress * 0.8;
        
        self._applyStreamPhysics(positions.array, actualParticleCount, attractionStrength, flowStrength, turbulence, stageProgress);
        
      } else {
        stageProgress = (rawProgress - streamEnd) / (1 - streamEnd);
        var settleEased = EASING.easeOutCubic(stageProgress);
        
        self._applySettlePhysics(positions.array, actualParticleCount, settleEased);
      }
      
      if (CONFIG.fusionEnabled && self.morphStage === 'stream') {
        self._applyFusionEffect(positions.array, actualParticleCount);
      }
      
      positions.needsUpdate = true;
      
      var visualProgress = easingFn(rawProgress);
      if (material.uniforms && material.uniforms.uMorphProgress) {
        material.uniforms.uMorphProgress.value = visualProgress;
      }
      
      self.morphProgress = rawProgress;
      
      if (self.onMorphProgress) {
        self.onMorphProgress(rawProgress, self.morphStage, shapeName);
      }
      
      if (rawProgress < 1) {
        self.currentAnimation = requestAnimationFrame(animate);
      } else {
        for (var i = 0; i < actualParticleCount; i++) {
          var i3 = i * 3;
          positions.array[i3] = self.targetPositions[i3];
          positions.array[i3 + 1] = self.targetPositions[i3 + 1];
          positions.array[i3 + 2] = self.targetPositions[i3 + 2];
        }
        positions.needsUpdate = true;
        
        self.isAnimating = false;
        self.isMorphing = false;
        self.currentAnimation = null;
        self.currentShape = shapeName;
        self.morphStage = 'idle';
        
        if (self.onMorphComplete) {
          self.onMorphComplete(shapeName);
        }
        
        window.dispatchEvent(new CustomEvent('sw:morphComplete', {
          detail: { shape: shapeName, duration: duration, fluid: true }
        }));
        
        if (onComplete) onComplete();
      }
    };
    
    this.currentAnimation = requestAnimationFrame(animate);
  };

  // ============================================
  // PHYSICS PHASES (CPU)
  // ============================================

  MorphEngine.prototype._applyGatherPhysics = function(posArray, count, attractionStrength, flowStrength, turbulence) {
    var noise = this.noise;
    var time = performance.now() * 0.001;
    var velocities = this.velocities;
    var damping = CONFIG.velocityDamping;
    var maxVel = CONFIG.maxVelocity;
    
    var centerX = 0, centerY = 0, centerZ = 0;
    for (var i = 0; i < count; i++) {
      var i3 = i * 3;
      centerX += posArray[i3];
      centerY += posArray[i3 + 1];
      centerZ += posArray[i3 + 2];
    }
    centerX /= count;
    centerY /= count;
    centerZ /= count;
    
    for (var j = 0; j < count; j++) {
      var j3 = j * 3;
      
      var px = posArray[j3];
      var py = posArray[j3 + 1];
      var pz = posArray[j3 + 2];
      
      var toCenterX = centerX - px;
      var toCenterY = centerY - py;
      var toCenterZ = centerZ - pz;
      var distToCenter = Math.sqrt(toCenterX * toCenterX + toCenterY * toCenterY + toCenterZ * toCenterZ) || 1;
      
      var attractX = (toCenterX / distToCenter) * attractionStrength;
      var attractY = (toCenterY / distToCenter) * attractionStrength;
      var attractZ = (toCenterZ / distToCenter) * attractionStrength;
      
      var flow = this.flowField.sample(px, py, pz);
      var flowX = flow.x * flowStrength;
      var flowY = flow.y * flowStrength;
      var flowZ = flow.z * flowStrength;
      
      var turbX = 0, turbY = 0, turbZ = 0;
      var freq = CONFIG.turbulenceScale;
      var amp = turbulence;
      
      for (var oct = 0; oct < CONFIG.turbulenceOctaves; oct++) {
        turbX += noise.noise3D(px * freq + time, py * freq, pz * freq) * amp;
        turbY += noise.noise3D(px * freq + 100, py * freq + time, pz * freq) * amp;
        turbZ += noise.noise3D(px * freq + 200, py * freq, pz * freq + time) * amp;
        
        freq *= CONFIG.turbulenceLacunarity;
        amp *= CONFIG.turbulencePersistence;
      }
      
      velocities[j3] += attractX + flowX + turbX;
      velocities[j3 + 1] += attractY + flowY + turbY;
      velocities[j3 + 2] += attractZ + flowZ + turbZ;
      
      velocities[j3] *= damping;
      velocities[j3 + 1] *= damping;
      velocities[j3 + 2] *= damping;
      
      var velMag = Math.sqrt(velocities[j3] * velocities[j3] + velocities[j3 + 1] * velocities[j3 + 1] + velocities[j3 + 2] * velocities[j3 + 2]);
      if (velMag > maxVel) {
        var velScale = maxVel / velMag;
        velocities[j3] *= velScale;
        velocities[j3 + 1] *= velScale;
        velocities[j3 + 2] *= velScale;
      }
      
      posArray[j3] += velocities[j3];
      posArray[j3 + 1] += velocities[j3 + 1];
      posArray[j3 + 2] += velocities[j3 + 2];
    }
  };

  MorphEngine.prototype._applyStreamPhysics = function(posArray, count, attractionStrength, flowStrength, turbulence, stageProgress) {
    var noise = this.noise;
    var time = performance.now() * 0.001;
    var velocities = this.velocities;
    var targetPositions = this.targetPositions;
    var damping = CONFIG.velocityDamping;
    var maxVel = CONFIG.maxVelocity * (1 + stageProgress);
    
    for (var i = 0; i < count; i++) {
      var i3 = i * 3;
      
      var px = posArray[i3];
      var py = posArray[i3 + 1];
      var pz = posArray[i3 + 2];
      
      var tx = targetPositions[i3];
      var ty = targetPositions[i3 + 1];
      var tz = targetPositions[i3 + 2];
      
      var toTargetX = tx - px;
      var toTargetY = ty - py;
      var toTargetZ = tz - pz;
      var distToTarget = Math.sqrt(toTargetX * toTargetX + toTargetY * toTargetY + toTargetZ * toTargetZ) || 0.001;
      
      toTargetX /= distToTarget;
      toTargetY /= distToTarget;
      toTargetZ /= distToTarget;
      
      var distFactor = Math.min(distToTarget / 30, 1);
      var effectiveAttraction = attractionStrength * (1 + (1 - distFactor) * 2);
      
      var attractX = toTargetX * effectiveAttraction;
      var attractY = toTargetY * effectiveAttraction;
      var attractZ = toTargetZ * effectiveAttraction;
      
      var flow = this.flowField.sample(px, py, pz, tx, ty, tz);
      var flowX = flow.x * flowStrength;
      var flowY = flow.y * flowStrength;
      var flowZ = flow.z * flowStrength;
      
      var turbScale = turbulence * distFactor;
      var turbX = 0, turbY = 0, turbZ = 0;
      
      if (turbScale > 0.01) {
        var freq = CONFIG.turbulenceScale;
        var amp = turbScale;
        
        for (var oct = 0; oct < CONFIG.turbulenceOctaves; oct++) {
          turbX += noise.noise3D(px * freq + time * 0.5, py * freq, pz * freq) * amp;
          turbY += noise.noise3D(px * freq + 100, py * freq + time * 0.5, pz * freq) * amp;
          turbZ += noise.noise3D(px * freq + 200, py * freq, pz * freq + time * 0.5) * amp;
          
          freq *= CONFIG.turbulenceLacunarity;
          amp *= CONFIG.turbulencePersistence;
        }
      }
      
      var spiralStrength = flowStrength * 0.3 * (1 - stageProgress);
      var spiralAngle = time * 2 + i * 0.01;
      var spiralX = Math.cos(spiralAngle) * spiralStrength * toTargetY;
      var spiralY = Math.sin(spiralAngle) * spiralStrength * toTargetZ;
      var spiralZ = Math.cos(spiralAngle + Math.PI * 0.5) * spiralStrength * toTargetX;
      
      velocities[i3] += attractX + flowX + turbX + spiralX;
      velocities[i3 + 1] += attractY + flowY + turbY + spiralY;
      velocities[i3 + 2] += attractZ + flowZ + turbZ + spiralZ;
      
      var progressiveDamping = damping - (1 - distFactor) * 0.1;
      velocities[i3] *= progressiveDamping;
      velocities[i3 + 1] *= progressiveDamping;
      velocities[i3 + 2] *= progressiveDamping;
      
      var velMag = Math.sqrt(velocities[i3] * velocities[i3] + velocities[i3 + 1] * velocities[i3 + 1] + velocities[i3 + 2] * velocities[i3 + 2]);
      if (velMag > maxVel) {
        var velScale = maxVel / velMag;
        velocities[i3] *= velScale;
        velocities[i3 + 1] *= velScale;
        velocities[i3 + 2] *= velScale;
      }
      
      posArray[i3] += velocities[i3];
      posArray[i3 + 1] += velocities[i3 + 1];
      posArray[i3 + 2] += velocities[i3 + 2];
    }
    
    if (Math.random() < 0.1) {
      this.flowField.update(0.016);
    }
  };

  MorphEngine.prototype._applySettlePhysics = function(posArray, count, settleProgress) {
    var targetPositions = this.targetPositions;
    var velocities = this.velocities;
    
    var settleStrength = 0.1 + settleProgress * 0.4;
    var damping = 0.7 + settleProgress * 0.25;
    
    for (var i = 0; i < count; i++) {
      var i3 = i * 3;
      
      var px = posArray[i3];
      var py = posArray[i3 + 1];
      var pz = posArray[i3 + 2];
      
      var tx = targetPositions[i3];
      var ty = targetPositions[i3 + 1];
      var tz = targetPositions[i3 + 2];
      
      var toTargetX = tx - px;
      var toTargetY = ty - py;
      var toTargetZ = tz - pz;
      
      velocities[i3] += toTargetX * settleStrength;
      velocities[i3 + 1] += toTargetY * settleStrength;
      velocities[i3 + 2] += toTargetZ * settleStrength;
      
      velocities[i3] *= damping;
      velocities[i3 + 1] *= damping;
      velocities[i3 + 2] *= damping;
      
      posArray[i3] += velocities[i3];
      posArray[i3 + 1] += velocities[i3 + 1];
      posArray[i3 + 2] += velocities[i3 + 2];
      
      var dist = Math.sqrt(toTargetX * toTargetX + toTargetY * toTargetY + toTargetZ * toTargetZ);
      if (dist < 0.1 && settleProgress > 0.8) {
        posArray[i3] = tx;
        posArray[i3 + 1] = ty;
        posArray[i3 + 2] = tz;
        velocities[i3] = 0;
        velocities[i3 + 1] = 0;
        velocities[i3 + 2] = 0;
      }
    }
  };

  MorphEngine.prototype._applyFusionEffect = function(posArray, count) {
    var spatialHash = this.spatialHash;
    var fusionRadius = CONFIG.fusionRadius;
    var fusionStrength = CONFIG.fusionStrength;
    var maxNeighbors = CONFIG.fusionNeighborCount;
    
    spatialHash.clear();
    for (var i = 0; i < count; i++) {
      var i3 = i * 3;
      spatialHash.insert(i, posArray[i3], posArray[i3 + 1], posArray[i3 + 2]);
    }
    
    var sampleRate = Math.min(1, 500 / count);
    
    for (var j = 0; j < count; j++) {
      if (Math.random() > sampleRate) continue;
      
      var j3 = j * 3;
      var px = posArray[j3];
      var py = posArray[j3 + 1];
      var pz = posArray[j3 + 2];
      
      var neighbors = spatialHash.getNeighbors(px, py, pz, fusionRadius);
      
      if (neighbors.length === 0) continue;
      
      neighbors.sort(function(a, b) { return a.distSq - b.distSq; });
      var closeNeighbors = neighbors.slice(0, maxNeighbors);
      
      var avgX = 0, avgY = 0, avgZ = 0;
      var totalWeight = 0;
      
      for (var k = 0; k < closeNeighbors.length; k++) {
        var n = closeNeighbors[k];
        var dist = Math.sqrt(n.distSq);
        var weight = 1 - (dist / fusionRadius);
        weight = weight * weight;
        
        avgX += n.x * weight;
        avgY += n.y * weight;
        avgZ += n.z * weight;
        totalWeight += weight;
      }
      
      if (totalWeight > 0) {
        avgX /= totalWeight;
        avgY /= totalWeight;
        avgZ /= totalWeight;
        
        var pullStrength = fusionStrength * (totalWeight / closeNeighbors.length);
        posArray[j3] += (avgX - px) * pullStrength;
        posArray[j3 + 1] += (avgY - py) * pullStrength;
        posArray[j3 + 2] += (avgZ - pz) * pullStrength;
      }
    }
  };

  // ============================================
  // SIMPLE MORPH (No physics)
  // ============================================

  MorphEngine.prototype._executeSimpleMorph = function(particleSystem, targetShape, shapeName, duration, easingName, onComplete) {
    var self = this;
    
    if (this.currentAnimation) {
      cancelAnimationFrame(this.currentAnimation);
      this.currentAnimation = null;
    }
    
    var particles = particleSystem.particles;
    var geometry = particles.geometry;
    var material = particles.material;
    
    var actualParticleCount = geometry.attributes.offset
      ? geometry.attributes.offset.count
      : (geometry.attributes.position ? geometry.attributes.position.count : this.particleCount);
    
    if (targetShape.length !== actualParticleCount) {
      targetShape = this.normalizeToParticleCount(targetShape, actualParticleCount);
    }
    
    var targetAttr = geometry.attributes.targetPosition;
    
    if (!targetAttr) {
      targetAttr = new THREE.BufferAttribute(new Float32Array(actualParticleCount * 3), 3);
      geometry.setAttribute('targetPosition', targetAttr);
    }
    
    var targetArray = targetAttr.array;
    var particleCount = Math.min(targetShape.length, targetArray.length / 3);
    
    for (var i = 0; i < particleCount; i++) {
      var idx = i * 3;
      targetArray[idx] = targetShape[i].x;
      targetArray[idx + 1] = targetShape[i].y;
      targetArray[idx + 2] = targetShape[i].z;
    }
    targetAttr.needsUpdate = true;
    
    if (material.uniforms && !material.uniforms.uMorphProgress) {
      material.uniforms.uMorphProgress = { value: 0 };
    }
    
    var easingFn = EASING[easingName] || EASING.easeInOutCubic;
    
    var startTime = performance.now();
    var startProgress = material.uniforms ? (material.uniforms.uMorphProgress ? material.uniforms.uMorphProgress.value : 0) : 0;
    this.isAnimating = true;
    this.isMorphing = true;
    
    if (this.onMorphStart) {
      this.onMorphStart(shapeName);
    }
    
    var animate = function() {
      var elapsed = performance.now() - startTime;
      var rawProgress = Math.min(elapsed / duration, 1);
      
      var eased = easingFn(rawProgress);
      
      var newProgress = startProgress + (1 - startProgress) * eased;
      
      if (material.uniforms && material.uniforms.uMorphProgress) {
        material.uniforms.uMorphProgress.value = newProgress;
      }
      
      self.morphProgress = newProgress;
      
      if (self.onMorphProgress) {
        self.onMorphProgress(newProgress, 'simple', shapeName);
      }
      
      if (rawProgress < 1) {
        self.currentAnimation = requestAnimationFrame(animate);
      } else {
        self.isAnimating = false;
        self.isMorphing = false;
        self.currentAnimation = null;
        self.currentShape = shapeName;
        
        if (self.onMorphComplete) {
          self.onMorphComplete(shapeName);
        }
        
        window.dispatchEvent(new CustomEvent('sw:morphComplete', {
          detail: { shape: shapeName, duration: duration, fluid: false }
        }));
        
        if (onComplete) onComplete();
      }
    };
    
    this.currentAnimation = requestAnimationFrame(animate);
  };

  // ============================================
  // RESET MORPH
  // ============================================

  MorphEngine.prototype.resetMorph = function(particleSystem, duration) {
    var self = this;
    duration = duration || CONFIG.resetDuration;
    
    if (!particleSystem || !particleSystem.particles) return;
    
    var material = particleSystem.particles.material;
    if (!material.uniforms || !material.uniforms.uMorphProgress) return;
    
    var startTime = performance.now();
    var startProgress = material.uniforms.uMorphProgress.value;
    
    var animate = function() {
      var elapsed = performance.now() - startTime;
      var progress = Math.min(elapsed / duration, 1);
      var eased = 1 - Math.pow(1 - progress, 3);
      
      material.uniforms.uMorphProgress.value = startProgress * (1 - eased);
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        self.currentShape = null;
        self.morphProgress = 0;
      }
    };
    
    requestAnimationFrame(animate);
  };

  // ============================================
  // GREETING ANIMATION
  // ============================================

  MorphEngine.prototype.playGreeting = function(particleSystem) {
    var self = this;
    
    if (!particleSystem || !particleSystem.particles) return;
    
    var geometry = particleSystem.particles.geometry;
    var positions = geometry.attributes.offset || geometry.attributes.position;
    if (!positions) return;
    
    this.greetingOrigins = new Float32Array(positions.array);
    
    var count = positions.count;
    if (!this.velocities || this.velocities.length !== count * 3) {
      this.velocities = new Float32Array(count * 3);
    }
    
    for (var i = 0; i < positions.array.length; i += 3) {
      var targetX = this.greetingOrigins[i];
      var targetY = this.greetingOrigins[i + 1];
      var targetZ = this.greetingOrigins[i + 2];
      
      positions.array[i] = (Math.random() - 0.5) * 3;
      positions.array[i + 1] = (Math.random() - 0.5) * 3;
      positions.array[i + 2] = (Math.random() - 0.5) * 3;
      
      var toTargetX = targetX - positions.array[i];
      var toTargetY = targetY - positions.array[i + 1];
      var toTargetZ = targetZ - positions.array[i + 2];
      
      this.velocities[i] = toTargetX * 0.02 + (Math.random() - 0.5) * 3;
      this.velocities[i + 1] = toTargetY * 0.02 + (Math.random() - 0.5) * 3;
      this.velocities[i + 2] = toTargetZ * 0.02 + (Math.random() - 0.5) * 3;
    }
    positions.needsUpdate = true;
    
    var startTime = performance.now();
    var duration = 2500;
    var noise = this.noise;
    
    var animate = function() {
      var elapsed = performance.now() - startTime;
      var progress = Math.min(elapsed / duration, 1);
      
      var stage, stageProgress;
      if (progress < 0.3) {
        stage = 'expand';
        stageProgress = progress / 0.3;
      } else if (progress < 0.7) {
        stage = 'swirl';
        stageProgress = (progress - 0.3) / 0.4;
      } else {
        stage = 'settle';
        stageProgress = (progress - 0.7) / 0.3;
      }
      
      var time = elapsed * 0.001;
      
      for (var i = 0; i < positions.array.length; i += 3) {
        var targetX = self.greetingOrigins[i];
        var targetY = self.greetingOrigins[i + 1];
        var targetZ = self.greetingOrigins[i + 2];
        
        var px = positions.array[i];
        var py = positions.array[i + 1];
        var pz = positions.array[i + 2];
        
        if (stage === 'expand') {
          var turbStrength = 2 * (1 - stageProgress);
          var turbX = noise.noise3D(px * 0.1 + time, py * 0.1, pz * 0.1) * turbStrength;
          var turbY = noise.noise3D(px * 0.1, py * 0.1 + time, pz * 0.1) * turbStrength;
          var turbZ = noise.noise3D(px * 0.1, py * 0.1, pz * 0.1 + time) * turbStrength;
          
          self.velocities[i] += turbX + (targetX - px) * 0.02;
          self.velocities[i + 1] += turbY + (targetY - py) * 0.02;
          self.velocities[i + 2] += turbZ + (targetZ - pz) * 0.02;
          
        } else if (stage === 'swirl') {
          var swirlStrength = 1.5 * (1 - stageProgress);
          var idx = i / 3;
          var swirlAngle = time * 3 + idx * 0.02;
          
          var toTargetX = targetX - px;
          var toTargetY = targetY - py;
          var toTargetZ = targetZ - pz;
          
          self.velocities[i] += toTargetX * 0.05 + Math.cos(swirlAngle) * swirlStrength;
          self.velocities[i + 1] += toTargetY * 0.05 + Math.sin(swirlAngle) * swirlStrength;
          self.velocities[i + 2] += toTargetZ * 0.05 + Math.sin(swirlAngle * 0.7) * swirlStrength * 0.5;
          
        } else {
          var settleStrength = 0.1 + stageProgress * 0.3;
          self.velocities[i] += (targetX - px) * settleStrength;
          self.velocities[i + 1] += (targetY - py) * settleStrength;
          self.velocities[i + 2] += (targetZ - pz) * settleStrength;
        }
        
        var damping = stage === 'settle' ? 0.8 : 0.92;
        self.velocities[i] *= damping;
        self.velocities[i + 1] *= damping;
        self.velocities[i + 2] *= damping;
        
        positions.array[i] += self.velocities[i];
        positions.array[i + 1] += self.velocities[i + 1];
        positions.array[i + 2] += self.velocities[i + 2];
      }
      
      positions.needsUpdate = true;
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        positions.array.set(self.greetingOrigins);
        positions.needsUpdate = true;
        self.greetingOrigins = null;
        
        window.dispatchEvent(new CustomEvent('sw:greetingComplete'));
      }
    };
    
    requestAnimationFrame(animate);
  };

  // ============================================
  // EXPLOSION EFFECT
  // ============================================

  MorphEngine.prototype.applyExplosionForce = function(particleSystem, epicenter, force) {
    if (!particleSystem || !particleSystem.particles) return;
    
    var geometry = particleSystem.particles.geometry;
    var positions = geometry.attributes.offset || geometry.attributes.position;
    
    if (!positions) return;
    
    var count = positions.count;
    
    if (!this.velocities || this.velocities.length !== count * 3) {
      this.velocities = new Float32Array(count * 3);
    }
    
    var cx = (epicenter.x || 0) * 50;
    var cy = (epicenter.y || 0) * 50;
    var cz = (epicenter.z || 0) * 50;
    
    for (var i = 0; i < positions.array.length; i += 3) {
      var dx = positions.array[i] - cx;
      var dy = positions.array[i + 1] - cy;
      var dz = positions.array[i + 2] - cz;
      
      var dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1;
      var invDist = 1 / dist;
      var explosionForce = force * invDist * invDist;
      explosionForce = Math.min(explosionForce, force * 2);
      
      var randAngle = Math.random() * Math.PI * 2;
      var randStrength = Math.random() * force * 0.3;
      
      this.velocities[i] = (dx * invDist) * explosionForce + Math.cos(randAngle) * randStrength;
      this.velocities[i + 1] = (dy * invDist) * explosionForce + Math.sin(randAngle) * randStrength;
      this.velocities[i + 2] = (dz * invDist) * explosionForce + (Math.random() - 0.5) * randStrength;
    }
    
    this._applyExplosionVelocities(particleSystem);
  };

  MorphEngine.prototype._applyExplosionVelocities = function(particleSystem) {
    var self = this;
    
    if (!particleSystem || !particleSystem.particles) return;
    
    var geometry = particleSystem.particles.geometry;
    var positions = geometry.attributes.offset || geometry.attributes.position;
    
    if (!positions || !this.velocities) return;
    
    var noise = this.noise;
    var frame = 0;
    var maxFrames = 40;
    
    var animate = function() {
      if (frame >= maxFrames) return;
      
      var time = frame * 0.05;
      var damping = 0.94 - frame * 0.005;
      
      for (var i = 0; i < positions.array.length; i += 3) {
        var turbX = noise.noise3D(positions.array[i] * 0.05 + time, positions.array[i + 1] * 0.05, frame * 0.1) * 0.5;
        var turbY = noise.noise3D(positions.array[i] * 0.05, positions.array[i + 1] * 0.05 + time, frame * 0.1) * 0.5;
        
        positions.array[i] += self.velocities[i] * 0.1 + turbX;
        positions.array[i + 1] += self.velocities[i + 1] * 0.1 + turbY;
        positions.array[i + 2] += self.velocities[i + 2] * 0.1;
        
        self.velocities[i] *= damping;
        self.velocities[i + 1] *= damping;
        self.velocities[i + 2] *= damping;
      }
      
      positions.needsUpdate = true;
      frame++;
      
      requestAnimationFrame(animate);
    };
    
    requestAnimationFrame(animate);
  };

  // ============================================
  // REFORM TO ELLIPSOID
  // ============================================

  MorphEngine.prototype.reformToEllipsoid = function(particleSystem) {
    var self = this;
    
    if (!particleSystem || !particleSystem.particles) return;
    
    var geometry = particleSystem.particles.geometry;
    var positions = geometry.attributes.offset || geometry.attributes.position;
    if (!positions) return;
    
    var count = positions.count;
    
    this.reformOrigins = new Float32Array(positions.array);
    this.reformTargets = new Float32Array(count * 3);
    
    for (var i = 0; i < count; i++) {
      var i3 = i * 3;
      var r = Math.cbrt(Math.random());
      var theta = Math.random() * Math.PI * 2;
      var phi = Math.acos(2 * Math.random() - 1);
      
      this.reformTargets[i3] = 45 * r * Math.sin(phi) * Math.cos(theta);
      this.reformTargets[i3 + 1] = 25 * r * Math.sin(phi) * Math.sin(theta);
      this.reformTargets[i3 + 2] = 40 * r * Math.cos(phi);
    }
    
    if (!this.velocities || this.velocities.length !== count * 3) {
      this.velocities = new Float32Array(count * 3);
    }
    
    var startTime = performance.now();
    var duration = 1500;
    var noise = this.noise;
    
    var animate = function() {
      var elapsed = performance.now() - startTime;
      var progress = Math.min(elapsed / duration, 1);
      var time = elapsed * 0.001;
      
      var stage, stageProgress;
      if (progress < 0.4) {
        stage = 'gather';
        stageProgress = progress / 0.4;
      } else {
        stage = 'settle';
        stageProgress = (progress - 0.4) / 0.6;
      }
      
      for (var i = 0; i < positions.array.length; i += 3) {
        var targetX = self.reformTargets[i];
        var targetY = self.reformTargets[i + 1];
        var targetZ = self.reformTargets[i + 2];
        
        var px = positions.array[i];
        var py = positions.array[i + 1];
        var pz = positions.array[i + 2];
        
        var toTargetX = targetX - px;
        var toTargetY = targetY - py;
        var toTargetZ = targetZ - pz;
        
        if (stage === 'gather') {
          var attractStrength = 0.03 + stageProgress * 0.05;
          var turbStrength = 1.5 * (1 - stageProgress);
          
          var turbX = noise.noise3D(px * 0.08 + time, py * 0.08, i * 0.001) * turbStrength;
          var turbY = noise.noise3D(px * 0.08, py * 0.08 + time, i * 0.001) * turbStrength;
          var turbZ = noise.noise3D(px * 0.08, py * 0.08, i * 0.001 + time) * turbStrength;
          
          self.velocities[i] += toTargetX * attractStrength + turbX;
          self.velocities[i + 1] += toTargetY * attractStrength + turbY;
          self.velocities[i + 2] += toTargetZ * attractStrength + turbZ;
          
        } else {
          var settleStrength = 0.08 + stageProgress * 0.2;
          
          self.velocities[i] += toTargetX * settleStrength;
          self.velocities[i + 1] += toTargetY * settleStrength;
          self.velocities[i + 2] += toTargetZ * settleStrength;
        }
        
        var damping = stage === 'gather' ? 0.9 : 0.75;
        self.velocities[i] *= damping;
        self.velocities[i + 1] *= damping;
        self.velocities[i + 2] *= damping;
        
        positions.array[i] += self.velocities[i];
        positions.array[i + 1] += self.velocities[i + 1];
        positions.array[i + 2] += self.velocities[i + 2];
      }
      
      positions.needsUpdate = true;
      
      if (particleSystem.particles.material.uniforms && particleSystem.particles.material.uniforms.uMorphProgress) {
        particleSystem.particles.material.uniforms.uMorphProgress.value = 0;
      }
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        for (var j = 0; j < positions.array.length; j++) {
          positions.array[j] = self.reformTargets[j];
        }
        positions.needsUpdate = true;
        
        self.reformOrigins = null;
        self.reformTargets = null;
        self.currentShape = 'ellipsoid';
        
        window.dispatchEvent(new CustomEvent('sw:reformComplete'));
      }
    };
    
    requestAnimationFrame(animate);
  };

  MorphEngine.prototype.gentleReform = function(particleSystem) {
    var self = this;
    
    if (!particleSystem || !particleSystem.particles) return;
    
    var geometry = particleSystem.particles.geometry;
    var positions = geometry.attributes.offset || geometry.attributes.position;
    var original = particleSystem.originalPositions;
    
    if (!positions || !original) return;
    
    var frame = 0;
    var maxFrames = 25;
    
    var animate = function() {
      if (frame >= maxFrames) return;
      
      var progress = frame / maxFrames;
      var strength = 0.1 + progress * 0.1;
      
      for (var i = 0; i < positions.array.length; i++) {
        positions.array[i] += (original[i] - positions.array[i]) * strength;
      }
      
      positions.needsUpdate = true;
      frame++;
      
      requestAnimationFrame(animate);
    };
    
    requestAnimationFrame(animate);
  };

  // ============================================
  // UTILITY METHODS
  // ============================================

  MorphEngine.prototype.getAvailableShapes = function() {
    return Object.keys(this.shapes);
  };

  MorphEngine.prototype.getShapeMetadata = function(shapeName) {
    return this.shapeMetadata[shapeName] || null;
  };

  MorphEngine.prototype.getCurrentShape = function() {
    return this.currentShape;
  };

  MorphEngine.prototype.getMorphProgress = function() {
    return this.morphProgress;
  };

  MorphEngine.prototype.getMorphStage = function() {
    return this.morphStage;
  };

  MorphEngine.prototype.isActive = function() {
    return this.isMorphing || this.isAnimating;
  };

  MorphEngine.prototype.isGPUEnabled = function() {
    return this.gpuSimulator && this.gpuSimulator.isInitialized;
  };

  MorphEngine.prototype.setParticleCount = function(count) {
    this.particleCount = count;
    this.shapes = {};
    this.wordShapes = {};
    this.generateAllShapes();
    
    // Reinitialize GPU if enabled
    if (this.gpuSimulator) {
      this.gpuSimulator.dispose();
      this.gpuSimulator = new GPUSPHSimulator(this.renderer, count, CONFIG.sph);
    }
  };

  MorphEngine.prototype.setSPHParameter = function(param, value) {
    if (CONFIG.sph.hasOwnProperty(param)) {
      CONFIG.sph[param] = value;
      
      if (this.gpuSimulator && this.gpuSimulator.isInitialized) {
        // Update GPU uniforms
        var uniformName = 'u' + param.charAt(0).toUpperCase() + param.slice(1);
        
        if (this.gpuSimulator.densityMaterial && this.gpuSimulator.densityMaterial.uniforms[uniformName]) {
          this.gpuSimulator.densityMaterial.uniforms[uniformName].value = value;
        }
        if (this.gpuSimulator.forceMaterial && this.gpuSimulator.forceMaterial.uniforms[uniformName]) {
          this.gpuSimulator.forceMaterial.uniforms[uniformName].value = value;
        }
      }
    }
  };

  // ============================================
// OPTIMIZED PARTICLE SYSTEM FACTORY
// ============================================

MorphEngine.prototype.createOptimizedParticleSystem = function(options) {
  options = options || {};
  
  var particleCount = options.particleCount || this.particleCount;
  var useDirectGPU = this.shouldUseDirectGPU();
  
  if (CONFIG.debug) {
    console.log('[MorphEngine] Creating particle system:',
      'count:', particleCount,
      'directGPU:', useDirectGPU);
  }
  
  // Create geometry
  var geometry = new THREE.BufferGeometry();
  
  // Create attributes
  var offsets = new Float32Array(particleCount * 3);
  var pindices = new Float32Array(particleCount);
  var angles = new Float32Array(particleCount);
  var colors = new Float32Array(particleCount * 3);
  
  // Initialize with ellipsoid distribution
  var ellipsoid = this.shapes.ellipsoid || this.createEllipsoidShape();
  
  for (var i = 0; i < particleCount; i++) {
    var i3 = i * 3;
    var point = ellipsoid[i] || ellipsoid[i % ellipsoid.length];
    
    offsets[i3] = point.x;
    offsets[i3 + 1] = point.y;
    offsets[i3 + 2] = point.z;
    
    pindices[i] = i;
    angles[i] = Math.random() * Math.PI * 2;
    
    // Default cyan color
    var baseColor = options.color || { r: 0, g: 0.83, b: 1 };
    colors[i3] = baseColor.r + (Math.random() - 0.5) * 0.1;
    colors[i3 + 1] = baseColor.g + (Math.random() - 0.5) * 0.1;
    colors[i3 + 2] = baseColor.b + (Math.random() - 0.5) * 0.1;
  }
  
  geometry.setAttribute('offset', new THREE.BufferAttribute(offsets, 3));
  geometry.setAttribute('pindex', new THREE.BufferAttribute(pindices, 1));
  geometry.setAttribute('angle', new THREE.BufferAttribute(angles, 1));
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  
  // Create material based on GPU availability
  var material;
  
  if (useDirectGPU) {
    // Use direct GPU pipeline material
    material = this.createDirectGPUMaterial(particleCount, {
      size: options.size || 4.5,
      industryColor: options.industryColor || 0x00d4ff,
      industryBlend: options.industryBlend || 0.2
    });
    
    // Initialize GPU simulator with positions
    this.initGPUWithPositions(offsets);
    
  } else {
    // Use standard material (CPU path or simple GPU)
    material = this._createStandardParticleMaterial(options);
  }
  
  // Create points mesh
  var particles = new THREE.Points(geometry, material);
  
  // Store references
  var system = {
    particles: particles,
    geometry: geometry,
    material: material,
    originalPositions: new Float32Array(offsets),
    particleCount: particleCount,
    isDirectGPU: useDirectGPU
  };
  
  return system;
};


// Standard material fallback
MorphEngine.prototype._createStandardParticleMaterial = function(options) {
  options = options || {};
  
  return new THREE.ShaderMaterial({
    uniforms: {
      uTime: { value: 0 },
      uSize: { value: options.size || 4.5 },
      uVoiceAmplitude: { value: 0 },
      uMorphProgress: { value: 0 },
      uExplosionActive: { value: 0 },
      uExplosionProgress: { value: 0 },
      uExplosionOrigin: { value: new THREE.Vector3(0, 0, 0) },
      uExplosionRadius: { value: 30 }
    },
    vertexShader: this._getStandardVertexShader(),
    fragmentShader: this._getStandardFragmentShader(),
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending
  });
};


MorphEngine.prototype._getStandardVertexShader = function() {
  // Return your existing particle-morph.vert content
  // This is used when GPU SPH isn't available
  return document.getElementById('particle-morph-vert') 
    ? document.getElementById('particle-morph-vert').textContent 
    : this._getInlineStandardVertexShader();
};


MorphEngine.prototype._getStandardFragmentShader = function() {
  return document.getElementById('particle-morph-frag')
    ? document.getElementById('particle-morph-frag').textContent
    : this._getInlineStandardFragmentShader();
};


// Inline fallbacks if shader elements don't exist
MorphEngine.prototype._getInlineStandardVertexShader = function() {
  return [
    'precision highp float;',
    'attribute vec3 offset;',
    'attribute float pindex;',
    'attribute vec3 color;',
    'attribute vec3 targetPosition;',
    '',
    'uniform float uTime;',
    'uniform float uSize;',
    'uniform float uMorphProgress;',
    'uniform float uVoiceAmplitude;',
    '',
    'varying vec3 vColor;',
    'varying float vAlpha;',
    '',
    'void main() {',
    '  vec3 pos = mix(offset, targetPosition, uMorphProgress);',
    '  pos.z += uVoiceAmplitude * 15.0 * fract(pindex * 0.1);',
    '  ',
    '  vColor = color;',
    '  vAlpha = 0.8;',
    '  ',
    '  vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);',
    '  gl_Position = projectionMatrix * mvPosition;',
    '  ',
    '  float size = uSize * (1.0 + uVoiceAmplitude * 0.5);',
    '  gl_PointSize = clamp(size * (350.0 / -mvPosition.z), 1.0, 60.0);',
    '}'
  ].join('\n');
};


MorphEngine.prototype._getInlineStandardFragmentShader = function() {
  return [
    'precision highp float;',
    'varying vec3 vColor;',
    'varying float vAlpha;',
    '',
    'void main() {',
    '  float dist = length(gl_PointCoord - 0.5);',
    '  if (dist > 0.5) discard;',
    '  float alpha = (1.0 - smoothstep(0.2, 0.5, dist)) * vAlpha;',
    '  gl_FragColor = vec4(vColor, alpha);',
    '}'
  ].join('\n');
};

  // ============================================
  // INITIALIZATION
  // ============================================

  function initialize() {
  // Export classes
  window.MorphEngine = MorphEngine;
  window.FlowField = FlowField;
  window.SpatialHash = SpatialHash;
  window.SimplexNoise = SimplexNoise;
  window.GPUSPHSimulator = GPUSPHSimulator;
  window.MORPH_EASING = EASING;
  window.LETTER_PATTERNS = LETTER_PATTERNS;
  window.MORPH_CONFIG = CONFIG;
  
  // Legacy class aliases (instances created by ParticleSystem)
  window.ParticleMorpher = MorphEngine;
  window.FluidMorphEngine = MorphEngine;
  
  // Factory function for lazy instantiation with correct particle count
  window.getMorphEngine = function(options) {
    options = options || {};
    
    // Return existing instance if particle count matches
    if (window.morphEngine) {
      var existingCount = window.morphEngine.particleCount;
      var requestedCount = options.particleCount || CONFIG.defaultParticleCount;
      
      if (existingCount === requestedCount) {
        return window.morphEngine;
      }
      
      // Count mismatch - update existing instance
      if (window.SW_DEBUG_MORPH) {
        console.log('[MorphEngine] Updating particle count:', existingCount, '→', requestedCount);
      }
      window.morphEngine.setParticleCount(requestedCount);
      return window.morphEngine;
    }
    
    // Create new instance
    window.morphEngine = new MorphEngine({
      particleCount: options.particleCount || CONFIG.defaultParticleCount,
      debug: options.debug || window.SW_DEBUG_MORPH === true,
      useGPU: options.useGPU !== false
    });
    
    // Set legacy aliases to instance
    window.particleMorpher = window.morphEngine;
    window.fluidMorphEngine = window.morphEngine;
    
    if (window.SW_DEBUG_MORPH) {
      console.log('[MorphEngine] Created with', window.morphEngine.particleCount, 'particles');
    }
    
    return window.morphEngine;
  };
  
  // Dispatch ready event (classes available, instance created on demand)
  window.dispatchEvent(new CustomEvent('sw:morphEngineReady'));
  window.dispatchEvent(new CustomEvent('sw:particleMorpherReady'));
  window.dispatchEvent(new CustomEvent('sw:fluidMorphEngineReady'));
  
  console.log('[MorphEngine] v3.0 GPU-Accelerated SPH loaded (lazy instantiation)');
}

  waitForThree(initialize);

})();


// ─── particle-system.js (Core Three.js GPU particle renderer) ───
/**
 * particle-system.js
 * ShockwaveHQ — Unified GPU Particle Rendering System
 * 
 * Merged from: three-particles-v2.js + enhanced-particle-renderer.js
 * 
 * Features:
 * - Full-field ellipsoid particle distribution (1500 desktop / 900 mobile)
 * - GPU-accelerated shader rendering with morphing support
 * - Group-level orbital motion + breathing animations
 * - Pointer parallax/tilt interaction
 * - Industry-adaptive colors and motion presets
 * - Voice reactivity with amplitude-driven effects
 * - Explosion/scatter effects with physics
 * - 3D depth rings with layered animation
 * - Post-processing bloom pipeline
 * - Adaptive quality integration
 * - WebGL context loss recovery
 * - Text collision avoidance integration
 * - Emma avatar integration
 * 
 * Dependencies: THREE.js, adaptive-quality.js, morph-engine.js
 * 
 * Usage:
 *   const system = new ParticleSystem(container, { industry: 'dental' });
 *   system.setVoiceAmplitude(0.5);
 *   // Renders automatically via internal animation loop
 */

(function() {
  'use strict';

  // ============================================
  // SHADER HOTFIX - Strip THREE.js built-in redefinitions
  // ============================================

  (function() {
    var strip = function(s) {
      if (!s) return s;
      return s
        .replace(/uniform\s+mat4\s+modelViewMatrix\s*;/g, '// modelViewMatrix auto-injected')
        .replace(/uniform\s+mat4\s+projectionMatrix\s*;/g, '// projectionMatrix auto-injected')
        .replace(/uniform\s+mat4\s+viewMatrix\s*;/g, '// viewMatrix auto-injected')
        .replace(/attribute\s+vec3\s+position\s*;/g, '// position auto-injected')
        .replace(/attribute\s+vec2\s+uv\s*;/g, '// uv auto-injected');
    };
    
    var fix = function() {
      if (window.PARTICLE_VERT) window.PARTICLE_VERT = strip(window.PARTICLE_VERT);
      if (window.PARTICLE_FRAG) window.PARTICLE_FRAG = strip(window.PARTICLE_FRAG);
      if (window.PARTICLE_MORPH_VERT) window.PARTICLE_MORPH_VERT = strip(window.PARTICLE_MORPH_VERT);
      if (window.PARTICLE_MORPH_FRAG) window.PARTICLE_MORPH_FRAG = strip(window.PARTICLE_MORPH_FRAG);
      if (window.RING_DEPTH_VERT) window.RING_DEPTH_VERT = strip(window.RING_DEPTH_VERT);
    };
    
    fix();
    setTimeout(fix, 50);
    setTimeout(fix, 200);
  })();

  // ============================================
  // CONFIGURATION
  // ============================================

  var CONFIG = {
    // Particle counts
    desktopParticleCount: 1500,
    mobileParticleCount: 900,
    mobileBreakpoint: 768,

 // Explosion - smoother, less violent
  explosionRadius: 18,              // Was 26 → smaller
  explosionDuration: 3500,          // Was 5200 → faster
  explosionScatterMultiplier: 1.2,  // Was 1.5 → less scatter
    
    // Ellipsoid distribution scales
    ellipsoidX: 45,
    ellipsoidY: 25,
    ellipsoidZ: 40,
    
    // Camera
    cameraFOV: 60,
    cameraNear: 0.1,
    cameraFar: 2000,
    cameraZ: 55,
    
    // Particle defaults
    defaultParticleSize: 4.5,
    mobileParticleSize: 3.0,
    // Base motion - ultra calm
    defaultRandomness: 0.015,         // Was 0.025
    defaultTurbulence: 0.004,         // Was 0.008
    defaultWaveFrequency: 0.08,       // Was 0.18
    defaultMotionSpeed: 0.02,         // Was 0.05
    groupBreathingAmount: 0.1,        // Was 0.2 → less breathing
    groupBreathingSpeed: 0.08,        // Was 0.15 → slower breathing
    
    // Post-processing
    bloomStrength: 0.75,
    bloomStrengthMobile: 0.35,
    bloomRadius: 0.4,
    bloomThreshold: 0.82,
    
    // Animation
     groupRotationSpeed: 0.01,   // was 0.04
     groupTiltAmount: 0.03,      // was 0.08
     groupBreathingSpeed: 0.15,  // was 0.25
     groupBreathingAmount: 0.2,  // was 2.0  -> uBreathingAmount ≈ 0.002
    pointerTiltSpeed: 0.12,
    
    // Pointer
    pointerInfluence: 0.5,
    
    // Voice
    voiceSmoothing: 0.15,
    
    // Depth effects
    depthFadeStart: -20,
    depthFadeEnd: 40,
    
    // Debug
    debug: false
  };

  // ============================================
// HARD TUNING OVERRIDES (VIN'S LOCKS)
// ============================================
var SW_HARD_TUNE = {
  enabled: true,

  // Force shader drift OFF (matches your console command)
  uniforms: {
    uMotionSpeed: 0,
    uTurbulence: 0,
    uRandom: 0,
    uWaveFrequency: 0,
    uBreathingAmount: 0,
    uPointerInfluence: 0
    // Add more if you want (uDepth, uVoiceAmplitude, etc.)
  }
};

  // ============================================
  // MOTION PRESETS
  // ============================================

  var MOTION_PRESETS = {
    idle: {
      name: 'Idle',
      randomness: 1.0,
      turbulence: 0.3,
      depthOscillation: 1.0,
      motionSpeed: 0.3,
      waveFrequency: 1.0,
      breathingAmount: 0.05
    },
    listening: {
      name: 'Listening',
      randomness: 0.8,
      turbulence: 0.4,
      depthOscillation: 1.2,
      motionSpeed: 0.4,
      waveFrequency: 1.2,
      breathingAmount: 0.06
    },
    locked: {
      name: 'Locked',
      randomness: 0.12,
      turbulence: 0.18,
      depthOscillation: 0.65,
      motionSpeed: 0.15,
      waveFrequency: 0.75,
      breathingAmount: 0.02
    },
    solid: {
  name: 'Solid',
  randomness: 0.025,        // uRandom - your locked value
  turbulence: 0.008,        // uTurbulence - your locked value
  depthOscillation: 0.4,
  motionSpeed: 0.05,        // uMotionSpeed - your locked value
  waveFrequency: 0.18,      // uWaveFrequency - your locked value
  breathingAmount: 0.006    // uBreathingAmount - your locked value
},
    liquid: {
      name: 'Liquid',
      randomness: 1.1,
      turbulence: 0.6,
      depthOscillation: 1.25,
      motionSpeed: 0.5,
      waveFrequency: 1.6,
      breathingAmount: 0.08
    },
    excited: {
      name: 'Excited',
      randomness: 1.3,
      turbulence: 0.7,
      depthOscillation: 1.5,
      motionSpeed: 0.6,
      waveFrequency: 2.0,
      breathingAmount: 0.1
    }
  };

  // ============================================
  // VERTEX SHADER
  // ============================================

  var PARTICLE_VERTEX_SHADER = `
    precision highp float;
    
    // Attributes
    attribute vec3 offset;
    attribute float pindex;
    attribute float angle;
    attribute vec3 targetPosition;
    attribute vec3 color;
    attribute float size;
    attribute float life;
    
    // Uniforms - Time
    uniform float uTime;
    uniform float uDeltaTime;
    
    // Uniforms - Motion
    uniform float uRandom;
    uniform float uDepth;
    uniform float uSize;
    uniform float uMotionSpeed;
    uniform float uTurbulence;
    uniform float uWaveFrequency;
    uniform float uBreathingAmount;
    
    // Uniforms - Morphing
    uniform float uMorphProgress;
    
    // Uniforms - Voice
    uniform float uVoiceAmplitude;
    
    // Uniforms - Explosion
    uniform float uExplosionActive;
    uniform vec3 uExplosionOrigin;
    uniform float uExplosionProgress;
    uniform float uExplosionRadius;
    
    // Uniforms - Pointer
    uniform vec2 uPointer;
    uniform float uPointerInfluence;
    
    // Uniforms - Text Collision
    uniform vec2 uTextZoneCenters[32];
    uniform float uTextZoneRadii[32];
    uniform int uTextZoneCount;
    
    // Uniforms - Depth
    uniform float uDepthFadeStart;
    uniform float uDepthFadeEnd;
    
    // Varyings
    varying vec3 vColor;
    varying float vAlpha;
    varying float vVoiceGlow;
    varying float vDepth;
    varying float vLife;
    
    // Utility functions
    float random(float seed) {
      return fract(sin(seed * 12.9898) * 43758.5453123);
    }
    
    float easeInOutCubic(float t) {
      return t < 0.5 ? 4.0 * t * t * t : 1.0 - pow(-2.0 * t + 2.0, 3.0) / 2.0;
    }
    
    // Simplex noise for organic motion
    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
    
    float snoise(vec3 v) {
      const vec2 C = vec2(1.0/6.0, 1.0/3.0);
      const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
      
      vec3 i = floor(v + dot(v, C.yyy));
      vec3 x0 = v - i + dot(i, C.xxx);
      
      vec3 g = step(x0.yzx, x0.xyz);
      vec3 l = 1.0 - g;
      vec3 i1 = min(g.xyz, l.zxy);
      vec3 i2 = max(g.xyz, l.zxy);
      
      vec3 x1 = x0 - i1 + C.xxx;
      vec3 x2 = x0 - i2 + C.yyy;
      vec3 x3 = x0 - D.yyy;
      
      i = mod289(i);
      vec4 p = permute(permute(permute(
               i.z + vec4(0.0, i1.z, i2.z, 1.0))
             + i.y + vec4(0.0, i1.y, i2.y, 1.0))
             + i.x + vec4(0.0, i1.x, i2.x, 1.0));
               
      float n_ = 0.142857142857;
      vec3 ns = n_ * D.wyz - D.xzx;
      
      vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
      
      vec4 x_ = floor(j * ns.z);
      vec4 y_ = floor(j - 7.0 * x_);
      
      vec4 x = x_ * ns.x + ns.yyyy;
      vec4 y = y_ * ns.x + ns.yyyy;
      vec4 h = 1.0 - abs(x) - abs(y);
      
      vec4 b0 = vec4(x.xy, y.xy);
      vec4 b1 = vec4(x.zw, y.zw);
      
      vec4 s0 = floor(b0)*2.0 + 1.0;
      vec4 s1 = floor(b1)*2.0 + 1.0;
      vec4 sh = -step(h, vec4(0.0));
      
      vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
      vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
      
      vec3 p0 = vec3(a0.xy, h.x);
      vec3 p1 = vec3(a0.zw, h.y);
      vec3 p2 = vec3(a1.xy, h.z);
      vec3 p3 = vec3(a1.zw, h.w);
      
      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
      p0 *= norm.x;
      p1 *= norm.y;
      p2 *= norm.z;
      p3 *= norm.w;
      
      vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
      m = m * m;
      return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
    }
    
    // Text collision avoidance
    vec3 applyTextCollision(vec3 pos) {
      vec3 result = pos;
      
      // Convert to NDC for comparison
      vec2 posNDC = pos.xy / 50.0; // Approximate world-to-NDC
      
      for (int i = 0; i < 32; i++) {
        if (i >= uTextZoneCount) break;
        
        vec2 toZone = posNDC - uTextZoneCenters[i];
        float dist = length(toZone);
        float effectiveRadius = uTextZoneRadii[i] * 1.15;
        
        if (dist < effectiveRadius && dist > 0.001) {
          float normalizedDist = dist / effectiveRadius;
          float force = pow(1.0 - normalizedDist, 3.0) * 0.5;
          
          vec2 repulsion = normalize(toZone) * force * 50.0; // Scale back to world
          result.xy += repulsion;
        }
      }
      
      return result;
    }
    
    void main() {
      vec3 pos = offset;
      float seed = pindex * 0.01;
      float rnd = random(seed);
      
      // ===== MORPHING =====
      float morphEased = easeInOutCubic(uMorphProgress);
      pos = mix(pos, targetPosition, morphEased);
      
      // ===== EXPLOSION =====
      if (uExplosionActive > 0.5) {
        vec3 toParticle = pos - uExplosionOrigin;
        float distFromOrigin = length(toParticle);
        
        if (distFromOrigin > 0.01) {
          vec3 explosionDir = normalize(toParticle);
          float expandPhase = smoothstep(0.0, 0.4, uExplosionProgress);
          float contractPhase = smoothstep(0.6, 1.0, uExplosionProgress);
          float distanceFactor = 1.0 - smoothstep(0.0, uExplosionRadius * 2.0, distFromOrigin);
          float displacement = uExplosionRadius * distanceFactor * (expandPhase - contractPhase * 0.95);
          pos += explosionDir * displacement;
          
          // Add chaos
          float chaos = (rnd - 0.5) * 8.0 * expandPhase * (1.0 - contractPhase);
          pos.x += chaos * random(seed + 1.0);
          pos.y += chaos * random(seed + 2.0);
          pos.z += chaos * random(seed + 3.0);
        }
      }
      
      // ===== ORGANIC MOTION =====
      float t = uTime * uMotionSpeed * 0.001;
      float noiseScale = 0.02 * uRandom;
      vec3 noiseInput = pos * noiseScale + t;
      
      float noiseX = snoise(noiseInput) * uTurbulence * 2.0;
      float noiseY = snoise(noiseInput + vec3(100.0, 0.0, 0.0)) * uTurbulence * 2.0;
      float noiseZ = snoise(noiseInput + vec3(200.0, 0.0, 0.0)) * uTurbulence * uDepth;
      
      pos.x += noiseX;
      pos.y += noiseY;
      pos.z += noiseZ;
      
      // Wave motion (reduced during morph)
      float waveFactor = 1.0 - uMorphProgress;
      float wave = sin(t * uWaveFrequency + pos.x * 0.1) * 0.5 * waveFactor;
      pos.y += wave;
      
      // ===== VOICE REACTIVITY =====
      float voiceDisp = uVoiceAmplitude * 15.0;
      float voiceAngle = seed * 6.283185 + uTime * 0.002;
      pos.x += cos(voiceAngle) * voiceDisp * (rnd * 0.5 + 0.5);
      pos.y += sin(voiceAngle) * voiceDisp * (random(seed + 10.0) * 0.5 + 0.5);
      pos.z += uVoiceAmplitude * 20.0 * random(seed + 20.0);
      
      // Voice scale
      float voiceScale = 1.0 + uVoiceAmplitude * 0.5;
      pos *= voiceScale;
      
      // ===== POINTER INFLUENCE =====
      if (uPointerInfluence > 0.01) {
        vec2 pointerWorld = uPointer * 30.0;
        vec2 toPointer = pointerWorld - pos.xy;
        float pointerDist = length(toPointer);
        
        if (pointerDist < 20.0 && pointerDist > 0.1) {
          float repulsion = (1.0 - pointerDist / 20.0) * uPointerInfluence * 3.0;
          pos.xy -= normalize(toPointer) * repulsion;
        }
      }
      
      // ===== TEXT COLLISION =====
      if (uTextZoneCount > 0) {
        pos = applyTextCollision(pos);
      }
      
      // ===== BREATHING =====
      float breathing = 1.0 + uBreathingAmount * sin(uTime * 0.0015 + seed * 10.0);
      pos *= breathing;
      
      // ===== OUTPUT =====
      vColor = color;
      vLife = life;
      vDepth = pos.z;
      vVoiceGlow = uVoiceAmplitude;
      
      // Depth-based alpha
      float depthFade = 1.0 - smoothstep(uDepthFadeStart, uDepthFadeEnd, pos.z);
      vAlpha = life * depthFade;
      
      // Transform
      vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
      gl_Position = projectionMatrix * mvPosition;
      
      // Size calculation
      float baseSize = uSize * size;
      
      // Voice pulse
      baseSize *= 1.0 + uVoiceAmplitude * 0.6;
      
      // Breathing size
      baseSize *= 0.92 + 0.08 * sin(uTime * 0.0015 + seed * 10.0);
      
      // Perspective size attenuation
      gl_PointSize = baseSize * (350.0 / -mvPosition.z);
      gl_PointSize = clamp(gl_PointSize, 1.0, 80.0);
    }
  `;

  // ============================================
  // FRAGMENT SHADER
  // ============================================

  var PARTICLE_FRAGMENT_SHADER = `
    precision highp float;
    
    // Uniforms
    uniform float uTime;
    uniform float uVoiceAmplitude;
    uniform vec3 uGlowColor;
    uniform float uGlowIntensity;
    
    // Varyings
    varying vec3 vColor;
    varying float vAlpha;
    varying float vVoiceGlow;
    varying float vDepth;
    varying float vLife;
    
    void main() {
      // Circular particle shape
      vec2 uv = gl_PointCoord;
      float dist = length(uv - vec2(0.5));
      
      if (dist > 0.5) discard;
      
      // Soft edge falloff
      float softEdge = 1.0 - smoothstep(0.2, 0.5, dist);
      
      // Central glow (brighter core)
      float glow = pow(1.0 - smoothstep(0.0, 0.3, dist), 1.8);
      
      // Color composition
      vec3 baseColor = vColor;
      
      // Voice glow overlay
      vec3 voiceGlow = uGlowColor * vVoiceGlow * 0.4;
      baseColor += voiceGlow;
      
      // Add central brightness
      baseColor += vec3(0.5) * glow;
      
      // Subtle shimmer
      float shimmer = sin(uTime * 0.003 + vDepth * 0.1) * 0.02;
      baseColor += shimmer;
      
      // Alpha calculation
      float alpha = softEdge * vAlpha + glow * 0.3;
      alpha = clamp(alpha, 0.0, 1.0);
      
      gl_FragColor = vec4(baseColor, alpha);
    }
  `;

  // ============================================
  // WAIT FOR DEPENDENCIES
  // ============================================

  function waitForDependencies(callback, maxAttempts) {
    maxAttempts = maxAttempts || 100;
    var attempts = 0;
    
    var check = function() {
      attempts++;
      if (typeof THREE !== 'undefined') {
        callback();
      } else if (attempts < maxAttempts) {
        setTimeout(check, 100);
      } else {
        console.error('[ParticleSystem] THREE.js not found');
      }
    };
    check();
  }

  function isDebug() {
    return window.SW_DEBUG_PARTICLES === true || CONFIG.debug;
  }

  function log() {
    if (isDebug()) {
      var args = ['[ParticleSystem]'];
      for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
      }
      console.log.apply(console, args);
    }
  }

  // ============================================
// HERO RING SYSTEM (PHASE 5) - FIXED
// ============================================

function HeroRingSystem(particleSystem, options) {
  options = options || {};
  
  this.ps = particleSystem;
  this.scene = particleSystem.scene;
  this.clock = particleSystem.clock;
  
  // Ring configuration - tuned to CSS glow locations
  this.ringConfigs = [
    { 
      name: 'purple',
      color: new THREE.Color(0x7C3AED),
      position: { x: -25, y: 12, z: -15 },
      tilt: { x: 0.15, y: -0.10 },
      radius: 18,
      thickness: 0.03
    },
    { 
      name: 'green',
      color: new THREE.Color(0x10B981),
      position: { x: 22, y: 10, z: -12 },
      tilt: { x: 0.12, y: 0.15 },
      radius: 15,
      thickness: 0.025
    },
    { 
      name: 'red',
      color: new THREE.Color(0xD12E1F),
      position: { x: 0, y: -18, z: -20 },
      tilt: { x: -0.10, y: 0.00 },
      radius: 22,
      thickness: 0.035
    }
  ];
  
  // State
  this.rings = [];
  this.pointer = { x: 0, y: 0 };
  this.pointerSmooth = { x: 0, y: 0 };
  this.time = 0;
  
  // Settings
  this.parallaxStrength = options.parallaxStrength || 0.15;
  this.wobbleSpeed = options.wobbleSpeed || 0.3;
  this.wobbleAmount = options.wobbleAmount || 0.02;
  this.rotationSpeed = options.rotationSpeed || 0.05;
  
  this.createRings();
  this.activateWebGLRings();
}

HeroRingSystem.prototype.getVertexShader = function() {
  return [
    'varying vec3 vNormal;',
    'varying vec3 vPosition;',
    'varying vec2 vUv;',
    '',
    'void main() {',
    '  vNormal = normalize(normalMatrix * normal);',
    '  vPosition = position;',
    '  vUv = uv;',
    '  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
    '}'
  ].join('\n');
};

HeroRingSystem.prototype.getFragmentShader = function() {
  return [
    'uniform float uTime;',
    'uniform vec3 uColor;',
    'uniform float uOpacity;',
    'uniform float uGlowIntensity;',
    '',
    'varying vec3 vNormal;',
    'varying vec3 vPosition;',
    'varying vec2 vUv;',
    '',
    'void main() {',
    '  vec3 viewDir = normalize(cameraPosition - vPosition);',
    '  float fresnel = pow(1.0 - max(dot(viewDir, vNormal), 0.0), 2.5);',
    '',
    '  // Glassmorphic effect - more transparent center, rim glow',
    '  float rimStrength = fresnel * 0.4;',
    '',
    '  // Dimmed base color with glass tint',
    '  vec3 glassColor = uColor * 0.35;',
    '  vec3 rimColor = uColor * (0.5 + fresnel * uGlowIntensity * 0.3);',
    '',
    '  // Blend glass and rim',
    '  vec3 finalColor = mix(glassColor, rimColor, fresnel);',
    '',
    '  // Subtle shimmer',
    '  float shimmer = sin(uTime * 1.5 + vUv.x * 15.0) * 0.015;',
    '  finalColor += shimmer;',
    '',
    '  // Glassmorphic alpha - very transparent center, subtle rim',
    '  float alpha = (0.08 + fresnel * 0.18) * uOpacity;',
    '  alpha = clamp(alpha, 0.0, 0.35);',
    '',
    '  gl_FragColor = vec4(finalColor, alpha);',
    '}'
  ].join('\n');
};

HeroRingSystem.prototype.createRings = function() {
  var self = this;
  
  this.ringConfigs.forEach(function(config, index) {
    var radiusScale = 0.85;
    var radius = config.radius * radiusScale;

    var geometry = new THREE.TorusGeometry(
      radius,
      radius * config.thickness,
      32,
      96
    );

    config.radius = radius;
    
    var material = new THREE.ShaderMaterial({
      uniforms: {
        uTime:          { value: 0 },
        uColor:         { value: config.color },
        uOpacity:       { value: 0.4 },
        uGlowIntensity: { value: 0.8 }
      },
      vertexShader:   self.getVertexShader(),
      fragmentShader: self.getFragmentShader(),
      transparent: true,
      blending: THREE.NormalBlending,
      depthWrite: false,
      side: THREE.DoubleSide
    });
    
    var ring = new THREE.Mesh(geometry, material);
    
    ring.position.set(config.position.x, config.position.y, config.position.z);
    ring.rotation.x = config.tilt.x;
    ring.rotation.y = config.tilt.y;
    
    ring.userData = {
      config: config,
      index: index,
      baseRotationZ: 0,
      baseScale: 1
    };
    
    self.scene.add(ring);
    self.rings.push(ring);
  });
};

HeroRingSystem.prototype.activateWebGLRings = function() {
  var sections = document.querySelectorAll('.live-demo, #live-ai-demo');
  sections.forEach(function(el) {
    el.classList.add('webgl-rings-active');
  });
};

HeroRingSystem.prototype.setParallax = function(nx, ny) {
  this.pointer.x = nx;
  this.pointer.y = ny;
};

HeroRingSystem.prototype.setPointer = function(nx, ny) {
  this.setParallax(nx, ny);
};

// THIS IS THE MISSING UPDATE METHOD!
HeroRingSystem.prototype.update = function(deltaTime) {
  deltaTime = deltaTime || 0.016;
  this.time += deltaTime;
  
  // Smooth pointer
  this.pointerSmooth.x += (this.pointer.x - this.pointerSmooth.x) * 0.08;
  this.pointerSmooth.y += (this.pointer.y - this.pointerSmooth.y) * 0.08;
  
  var self = this;
  
  this.rings.forEach(function(ring, index) {
    var config = ring.userData.config;
    
    // Update time uniform
    ring.material.uniforms.uTime.value = self.time;
    
    // Slow rotation
    ring.userData.baseRotationZ += deltaTime * self.rotationSpeed;
    ring.rotation.z = ring.userData.baseRotationZ;
    
    // Gentle wobble
    var wobblePhase = self.time * self.wobbleSpeed + index * 1.5;
    ring.rotation.x = config.tilt.x + Math.sin(wobblePhase) * self.wobbleAmount;
    ring.rotation.y = config.tilt.y + Math.cos(wobblePhase * 0.7) * self.wobbleAmount;
    
    // Parallax offset based on pointer
    var parallaxX = self.pointerSmooth.x * self.parallaxStrength * (10 - index * 2);
    var parallaxY = self.pointerSmooth.y * self.parallaxStrength * (8 - index * 1.5);
    
    ring.position.x = config.position.x + parallaxX;
    ring.position.y = config.position.y + parallaxY;
    
    // Keep scale at 1 (no pulse)
    ring.scale.setScalar(1);
  });
};

HeroRingSystem.prototype.alignToCssRings = function() {
  // Keep existing implementation
  try {
    var ps = this.ps;
    var camera = ps && ps.camera;
    var renderer = ps && ps.renderer;

    if (!camera || !renderer || !this.rings.length) return;
    // ... rest of existing alignToCssRings code
  } catch (e) {
    if (console && console.warn) {
      console.warn('[HeroRingSystem] alignToCssRings failed:', e);
    }
  }
};

HeroRingSystem.prototype.destroy = function() {
  var self = this;
  
  this.rings.forEach(function(ring) {
    self.scene.remove(ring);
    ring.geometry.dispose();
    ring.material.dispose();
  });
  
  this.rings = [];
  
  var sections = document.querySelectorAll('.live-demo, #live-ai-demo');
  sections.forEach(function(el) {
    el.classList.remove('webgl-rings-active');
  });
};

  // Export
  window.HeroRingSystem = HeroRingSystem;


  // ============================================
  // PARTICLE SYSTEM CLASS
  // ============================================

  function ParticleSystem(container, options) {
    if (!container) {
      console.error('[ParticleSystem] Container element required');
      return;
    }
    
    var self = this;
    options = options || {};
    
    this.container = container;
    this.options = {};
    
    // Merge options with defaults
    for (var key in CONFIG) {
      this.options[key] = CONFIG[key];
    }
    for (var key2 in options) {
      this.options[key2] = options[key2];
    }
    
    // Device detection
    this.isMobile = options.isMobile !== undefined
      ? options.isMobile
      : window.innerWidth < this.options.mobileBreakpoint;
    
    this.particleCount = this.isMobile
      ? this.options.mobileParticleCount
      : this.options.desktopParticleCount;
    
    // Quality system integration
    this.quality = window.adaptiveQuality || null;
    if (this.quality) {
      var settings = this.quality.getCurrentSettings();
      if (settings.maxParticles) {
        this.particleCount = Math.min(this.particleCount, settings.maxParticles);
      }
    }
    
    // THREE.js core
    this.scene = null;
    this.camera = null;
    this.renderer = null;
    this.clock = null;
    
    // Post-processing
    this.composer = null;
    this.bloomPass = null;
    
    // Particle system
    this.particles = null;
    this.particleGeometry = null;
    this.particleMaterial = null;
    
    // Position storage
    this.originalPositions = null;
    this.targetPositions = null;
    this.velocities = null;
    
    // Uniforms reference
    this.uniforms = null;
    
    // Subsystems
    this.textCollision = null;
    this.heroRings = null;       // Phase 5: 3 hero rings
    this.emmaAvatar = null;
    this.morpher = null;
    this.orbitalFlow = null;     // NEW: orbital specimen system
    
    // State
    this.voiceAmplitude = 0;
this.targetVoiceAmplitude = 0;
this.currentMotionPreset = 'idle';
this.motionConfig = {};
this.voiceConfig = { amplitudeMultiplier: 0.55 };
    this.currentIndustry = options.industry || null;
    this.currentPreset = null;
    this.isRunning = false;
    this.animationFrame = null;
    
    // Pointer state
    this.pointer = { x: 0, y: 0 };
    this.pointerSmooth = { x: 0, y: 0 };
    
    // Explosion state
    this.explosion = {
      active: false,
      origin: new THREE.Vector3(0, 0, 0),
      startTime: 0,
      progress: 0
    };
    this.isExplosionActive = false;
    
    // Morph state
    this.isMorphing = false;
    
    // Ring auto-spawn
    this.lastRingSpawn = 0;
    
    // Performance
    this.frameCount = 0;
    this.lastFPSUpdate = 0;
    this.currentFPS = 0;
    
    // Bound event handlers
    this.boundOnResize = null;
    this.boundOnPointerMove = null;
    this.boundOnVoice = null;
    this.boundOnQualityChange = null;
    
    // Config for morpher compatibility
    this.config = {
      particleCount: this.particleCount
    };
    
    // Initialize
    this.init();
  }

  // ============================================
  // INITIALIZATION
  // ============================================

  ParticleSystem.prototype.init = function() {
    log('Initializing Particle System...');
    log('Particles:', this.particleCount, 'Mobile:', this.isMobile);
    
    this.setupRenderer();
  this.setupCamera();
  this.setupScene();
  this.setupPostProcessing();
  this.createParticles();
  this.setupTextCollision();
  this.setupEmmaAvatar();
  this.setupMorpher();
  this.setupEventListeners();

  // Enable hero rings by default
  this.enableHeroRings();

// NEW: calm solid preset as baseline
  if (typeof this.setMotionPreset === 'function') {
    this.setMotionPreset('solid');
  }

  // NEW: tie particles into orbital flow
  this.setupOrbitalFlow();

  this.clock = new THREE.Clock();
  this.isRunning = true;
  this.animate();

// Apply initial industry preset if specified
if (this.currentIndustry) {
  this.applyIndustryPreset(this.currentIndustry);
}

// Align hero rings to CSS rings once everything is laid out
var self = this;
if (this.heroRings && typeof this.heroRings.alignToCssRings === 'function') {
  requestAnimationFrame(function() {
    self.heroRings.alignToCssRings();
  });
}
    
    log('Particle System ready');
    
    window.dispatchEvent(new CustomEvent('sw:particleSystemReady', {
      detail: { system: this }
    }));
  };

  ParticleSystem.prototype.setupRenderer = function() {
    var self = this;
    var width = this.container.clientWidth || window.innerWidth || 1280;
    var height = this.container.clientHeight || Math.round((window.innerHeight || 720) * 0.75);
    
    var antialias = !this.isMobile;
    if (this.quality) {
      var settings = this.quality.getCurrentSettings();
      antialias = settings.antialias !== false;
    }
    
    var renderer = new THREE.WebGLRenderer({
      antialias: antialias,
      alpha: true,
      powerPreference: 'high-performance',
      stencil: false,
      depth: true
    });
    
    renderer.setSize(width, height, false);
    renderer.setPixelRatio(this.isMobile ? 1 : Math.min((window.devicePixelRatio || 1), 2));
    renderer.setClearColor(0x000000, 0);
    
    this.renderer = renderer;
    this.container.appendChild(this.renderer.domElement);
    
    var canvas = this.renderer.domElement;
    canvas.classList.add('sw-particle-canvas-v2', 'sw-particle-background');
    canvas.style.position = 'absolute';
    canvas.style.top = '0';
    canvas.style.left = '0';
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.pointerEvents = 'none';
    
    // Handle WebGL context loss
    canvas.addEventListener('webglcontextlost', function(event) {
      event.preventDefault();
      log('WebGL context lost! Pausing animation...');
      self.isRunning = false;
      if (self.animationFrame) {
        cancelAnimationFrame(self.animationFrame);
        self.animationFrame = null;
      }
      self.container.classList.add('webgl-context-lost');
      window.dispatchEvent(new CustomEvent('sw:webglContextLost'));
    }, false);
    
    canvas.addEventListener('webglcontextrestored', function() {
      log('WebGL context restored! Resuming...');
      self.container.classList.remove('webgl-context-lost');
      self.rebuildMaterials();
      self.isRunning = true;
      self.clock.start();
      self.animate();
      window.dispatchEvent(new CustomEvent('sw:webglContextRestored'));
    }, false);
    
    log('Renderer:', width + 'x' + height, '@', renderer.getPixelRatio() + 'x');
  };

  ParticleSystem.prototype.setupOrbitalFlow = function() {
  // Make sure module is available
  if (typeof window.OrbitalFlowSystem === 'undefined') {
    if (this.options.debug) {
      console.log('[ParticleSystem] OrbitalFlowSystem not available');
    }
    return;
  }

  // Ensure morpher exists (for shapes/words)
  if (!this.morpher && typeof window.getMorphEngine === 'function') {
    this.morpher = window.getMorphEngine({
      particleCount: this.particleCount,
      debug: this.options.debug
    });
  }

  // Verify morpher is ready
  if (this.morpher) {
    console.log('[ParticleSystem] Morpher ready for OrbitalFlow, particle count:', this.morpher.particleCount);
  } else {
    console.warn('[ParticleSystem] No morpher available for OrbitalFlow');
  }

  // Create orbital flow controller with explicit morpher reference
  try {
    this.orbitalFlow = new window.OrbitalFlowSystem(this, {
  debug: true,

  // Make the orbit balls tiny/tight
  orbitRadiusVariation: 0.0,     // CRITICAL: removes per-particle radius variance
  orbitSpeedVariation: 0.0,      // optional: makes speed uniform
  orbitSpeedBase: 0.06,          // tweak if you want faster/slower

  leftOrbit:  { radiusX: 5.5, radiusY: 6.0, radiusZ: 5.0 },
  rightOrbit: { radiusX: 5.5, radiusY: 6.0, radiusZ: 5.0 },

  // Morph “timelapse” timing
  morphTravelDuration: 2500,
  morphFormDuration: 3500,
  morphHoldDuration: 6000,
  morphDissolveDuration: 2500,
  morphReturnDuration: 3500
});
    
    // Ensure orbital flow has morpher reference
    if (this.morpher && !this.orbitalFlow.morpher) {
      this.orbitalFlow.morpher = this.morpher;
      console.log('[ParticleSystem] Injected morpher into OrbitalFlow');
    }
    
    window.demoOrbitalFlow = this.orbitalFlow;
    console.log('[ParticleSystem] OrbitalFlow initialized successfully');
    // ========== NEW: DISABLE GPU MORPH COMPLETELY ==========
    // OrbitalFlow owns all particle motion now
    if (this.uniforms) {
  this.uniforms.uMorphProgress.value = 0;
  if (this.uniforms.uRandom)          this.uniforms.uRandom.value          = 0;
  if (this.uniforms.uTurbulence)      this.uniforms.uTurbulence.value      = 0;
  if (this.uniforms.uWaveFrequency)   this.uniforms.uWaveFrequency.value   = 0;
  if (this.uniforms.uBreathingAmount) this.uniforms.uBreathingAmount.value = 0;
  if (this.uniforms.uMotionSpeed)     this.uniforms.uMotionSpeed.value     = 0;
  if (this.uniforms.uPointerInfluence)this.uniforms.uPointerInfluence.value= 0;
}
    
    // Flag to prevent any code path from re-enabling GPU morph
    this.gpuMorphDisabled = true;
    // ========================================================
  } catch (e) {
    console.warn('[ParticleSystem] Failed to init OrbitalFlowSystem:', e);
    this.orbitalFlow = null;
  }

  // Ultra-calm when OrbitalFlow owns motion
if (this.uniforms && this.orbitalFlow) {
  this.uniforms.uRandom.value        = 0;
  this.uniforms.uTurbulence.value    = 0;
  this.uniforms.uWaveFrequency.value = 0;
  this.uniforms.uBreathingAmount.value = 0;
}

  if (this.options.debug) {
    console.log('[ParticleSystem] Orbital flow system initialized');
  }
};

  ParticleSystem.prototype.rebuildMaterials = function() {
  log('Rebuilding materials after context restore...');
  
  if (this.particleMaterial) {
    this.particleMaterial.needsUpdate = true;
  }
  
  if (this.heroRings && this.heroRings.rings) {
    this.heroRings.rings.forEach(function(ring) {
      if (ring.material) {
        ring.material.needsUpdate = true;
      }
    });
  }
  
  if (this.emmaAvatar && this.emmaAvatar.avatar && this.emmaAvatar.avatar.material) {
    this.emmaAvatar.avatar.material.needsUpdate = true;
  }
  
  log('Materials rebuilt');
};

  ParticleSystem.prototype.setupCamera = function() {
    var width = this.container.clientWidth || window.innerWidth;
    var height = this.container.clientHeight || window.innerHeight;
    
    this.camera = new THREE.PerspectiveCamera(
      this.options.cameraFOV,
      width / height,
      this.options.cameraNear,
      this.options.cameraFar
    );
    
    this.camera.position.z = this.options.cameraZ;
  };

  ParticleSystem.prototype.setupScene = function() {
    this.scene = new THREE.Scene();
  };

  ParticleSystem.prototype.setupPostProcessing = function() {
    var EffectComposer = THREE.EffectComposer || window.EffectComposer;
    var RenderPass = THREE.RenderPass || window.RenderPass;
    var UnrealBloomPass = THREE.UnrealBloomPass || window.UnrealBloomPass;
    
    if (typeof EffectComposer === 'undefined') {
      log('EffectComposer not available, using direct rendering');
      this.composer = null;
      return;
    }
    
    // Check quality settings
    if (this.quality) {
      var settings = this.quality.getCurrentSettings();
      if (!settings.postProcessing) {
        log('Post-processing disabled by quality settings');
        this.composer = null;
        return;
      }
    }
    
    try {
      var width = this.container.clientWidth || window.innerWidth;
      var height = this.container.clientHeight || window.innerHeight;
      
      this.composer = new EffectComposer(this.renderer);
      
      if (typeof RenderPass !== 'undefined') {
        var renderPass = new RenderPass(this.scene, this.camera);
        this.composer.addPass(renderPass);
      }
      
      if (typeof UnrealBloomPass !== 'undefined') {
        var bloomStrength = this.isMobile
          ? this.options.bloomStrengthMobile
          : this.options.bloomStrength;
        
        if (this.quality) {
          var settings2 = this.quality.getCurrentSettings();
          if (settings2.bloomEnabled === false) {
            bloomStrength = 0;
          } else if (settings2.bloomStrength !== undefined) {
            bloomStrength = settings2.bloomStrength;
          }
        }
        
        this.bloomPass = new UnrealBloomPass(
          new THREE.Vector2(width, height),
          bloomStrength,
          this.options.bloomRadius,
          this.options.bloomThreshold
        );
        this.composer.addPass(this.bloomPass);
        log('Bloom pass added, strength:', bloomStrength);
      }
      
      // Output pass
      var OutputPass = THREE.OutputPass || window.OutputPass;
      var ShaderPass = THREE.ShaderPass || window.ShaderPass;
      var GammaCorrectionShader = THREE.GammaCorrectionShader || window.GammaCorrectionShader;
      
      if (typeof OutputPass !== 'undefined') {
        var outputPass = new OutputPass();
        this.composer.addPass(outputPass);
      } else if (typeof ShaderPass !== 'undefined' && typeof GammaCorrectionShader !== 'undefined') {
        var gammaPass = new ShaderPass(GammaCorrectionShader);
        this.composer.addPass(gammaPass);
      }
      
      log('Post-processing configured');
      
    } catch (e) {
      console.warn('[ParticleSystem] Post-processing setup failed:', e.message);
      this.composer = null;
    }
  };

  // ============================================
  // PARTICLE CREATION
  // ============================================

  ParticleSystem.prototype.createParticles = function() {
    var self = this;
    
    // Get shaders (custom or fallback)
    var vertexShader = window.PARTICLE_MORPH_VERT || window.PARTICLE_VERT || PARTICLE_VERTEX_SHADER;
    var fragmentShader = window.PARTICLE_MORPH_FRAG || window.PARTICLE_FRAG || PARTICLE_FRAGMENT_SHADER;
    
    log('Shader source:', vertexShader === PARTICLE_VERTEX_SHADER ? 'BUILT-IN' : 'CUSTOM');
    
    this.particleGeometry = new THREE.BufferGeometry();
    
    var offsets = new Float32Array(this.particleCount * 3);
    var indices = new Float32Array(this.particleCount);
    var angles = new Float32Array(this.particleCount);
    var targetPositions = new Float32Array(this.particleCount * 3);
    var colors = new Float32Array(this.particleCount * 3);
    var sizes = new Float32Array(this.particleCount);
    var lives = new Float32Array(this.particleCount);
    
    var X_SCALE = this.options.ellipsoidX;
    var Y_SCALE = this.options.ellipsoidY;
    var Z_SCALE = this.options.ellipsoidZ;
    
    // Full-field ellipsoid distribution
    for (var i = 0; i < this.particleCount; i++) {
      // Uniform distribution in sphere, then scale to ellipsoid
      var r = Math.cbrt(Math.random());
      var theta = Math.random() * Math.PI * 2;
      var phi = Math.acos(2 * Math.random() - 1);
      
      var x = r * Math.sin(phi) * Math.cos(theta) * X_SCALE;
      var y = r * Math.sin(phi) * Math.sin(theta) * Y_SCALE;
      var z = r * Math.cos(phi) * Z_SCALE;
      
      offsets[i * 3] = x;
      offsets[i * 3 + 1] = y;
      offsets[i * 3 + 2] = z;
      
      // Initial target = same as offset
      targetPositions[i * 3] = x;
      targetPositions[i * 3 + 1] = y;
      targetPositions[i * 3 + 2] = z;
      
      indices[i] = i;
      angles[i] = Math.random() * Math.PI * 2;
      
      // Default purple color
      colors[i * 3] = 0.486;
      colors[i * 3 + 1] = 0.227;
      colors[i * 3 + 2] = 0.929;
      
      // Random size variation
      sizes[i] = 0.8 + Math.random() * 0.4;
      
      // Full life
      lives[i] = 1.0;
    }
    
    // Set all attributes
    this.particleGeometry.setAttribute('offset', new THREE.BufferAttribute(offsets, 3));
    this.particleGeometry.setAttribute('pindex', new THREE.BufferAttribute(indices, 1));
    this.particleGeometry.setAttribute('angle', new THREE.BufferAttribute(angles, 1));
    this.particleGeometry.setAttribute('targetPosition', new THREE.BufferAttribute(targetPositions, 3));
    this.particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    this.particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
    this.particleGeometry.setAttribute('life', new THREE.BufferAttribute(lives, 1));
    
    // Position attribute (required by THREE.js for bounding calculations)
    this.particleGeometry.setAttribute('position', new THREE.BufferAttribute(offsets.slice(), 3));
    
    // Store original positions
    this.originalPositions = new Float32Array(offsets);
    this.targetPositions = targetPositions;
    this.velocities = new Float32Array(this.particleCount * 3);
    
    // Create uniforms
    this.uniforms = {
      uTime: { value: 0 },
      uDeltaTime: { value: 0.016 },
      uRandom: { value: this.options.defaultRandomness },
      uDepth: { value: this.options.defaultDepth },
      uSize: { value: this.isMobile ? this.options.mobileParticleSize : this.options.defaultParticleSize },
      uMotionSpeed: { value: this.options.defaultMotionSpeed },
      uTurbulence: { value: this.options.defaultTurbulence },
      uWaveFrequency: { value: this.options.defaultWaveFrequency },
      uBreathingAmount: { value: CONFIG.groupBreathingAmount * 0.01 },
      uMorphProgress: { value: 0 },
      uVoiceAmplitude: { value: 0 },
      // Explosion
      uExplosionActive: { value: 0 },
      uExplosionOrigin: { value: new THREE.Vector3(0, 0, 0) },
      uExplosionProgress: { value: 0 },
      uExplosionRadius: { value: this.options.explosionRadius },
      // Pointer
      uPointer: { value: new THREE.Vector2(0, 0) },
      uPointerInfluence: { value: this.options.pointerInfluence },
      // Text collision
      uTextZoneCenters: { value: new Float32Array(32 * 2) },
      uTextZoneRadii: { value: new Float32Array(32) },
      uTextZoneCount: { value: 0 },
      // Depth
      uDepthFadeStart: { value: CONFIG.depthFadeStart },
      uDepthFadeEnd: { value: CONFIG.depthFadeEnd },
      // Fragment uniforms
      uGlowColor: { value: new THREE.Color(0x7C3AED) },
      uGlowIntensity: { value: 0.8 }
    };

    // Ultra‑calm baseline – prevent any jittery defaults
this.uniforms.uTurbulence.value      = 0.008;
this.uniforms.uRandom.value          = 0.025;
this.uniforms.uWaveFrequency.value   = 0.18;
this.uniforms.uMotionSpeed.value     = 0.05;
this.uniforms.uBreathingAmount.value = 0.006;

    
    this.particleMaterial = new THREE.ShaderMaterial({
      uniforms: this.uniforms,
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      depthTest: true
    });
    
    this.particles = new THREE.Points(this.particleGeometry, this.particleMaterial);
    
    // Disable frustum culling (prevents particles from disappearing)
    this.particles.frustumCulled = false;
    
    // Set proper bounding sphere
    this.particleGeometry.computeBoundingSphere();
    if (this.particleGeometry.boundingSphere) {
      this.particleGeometry.boundingSphere.radius = Math.max(X_SCALE, Y_SCALE, Z_SCALE) * 1.5;
    }
    
    this.scene.add(this.particles);
    
    // Verify shader compilation
    requestAnimationFrame(function() {
      if (!self.renderer || !self.particleMaterial) return;
      
      self.renderer.render(self.scene, self.camera);
      
      var gl = self.renderer.getContext();
      var program = self.particleMaterial.program;
      
      if (program && program.program) {
        var linked = gl.getProgramParameter(program.program, gl.LINK_STATUS);
        if (!linked) {
          console.error('[ParticleSystem] ❌ SHADER LINK FAILED');
          var vertLog = gl.getShaderInfoLog(program.vertexShader);
          var fragLog = gl.getShaderInfoLog(program.fragmentShader);
          if (vertLog) console.error('Vertex shader errors:', vertLog);
          if (fragLog) console.error('Fragment shader errors:', fragLog);
          
          // Fallback to basic material
          log('Falling back to PointsMaterial...');
          self.particleMaterial = new THREE.PointsMaterial({
            size: self.isMobile ? 3 : 5,
            color: 0x7C3AED,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            sizeAttenuation: true
          });
          self.particles.material = self.particleMaterial;
        } else {
          log('✅ Shader compiled successfully');
        }
      }
    });
    
    log('Created', this.particleCount, 'particles in ellipsoid (', X_SCALE, 'x', Y_SCALE, 'x', Z_SCALE, ')');
  };

  // ============================================
  // SUBSYSTEM SETUP
  // ============================================

  ParticleSystem.prototype.setupTextCollision = function() {
    var self = this;
    
    if (typeof window.TextCollisionManager === 'undefined') {
      log('TextCollisionManager not available');
      return;
    }
    
    try {
      if (window.textCollisionManager && window.textCollisionManager.isInitialized) {
        this.textCollision = window.textCollisionManager;
        log('Using existing TextCollisionManager');
      } else {
        this.textCollision = new window.TextCollisionManager({
          debug: false,
          maxZones: 32,
          buffer: 45,
          radiusInflation: 1.15
        });
        window.textCollisionManager = this.textCollision;
      }
      
      this.textCollision.init(this.renderer.domElement, this.camera);
      
      // Force initial detection after DOM settles
      setTimeout(function() {
        if (self.textCollision) {
          self.textCollision.detectTextElements();
          self.updateTextCollisionUniforms();
          log('Text collision zones detected:', self.textCollision.zoneCount);
        }
      }, 500);
      
      log('Text collision integrated');
    } catch (e) {
      console.warn('[ParticleSystem] Text collision setup failed:', e);
    }
  };

  ParticleSystem.prototype.setupEmmaAvatar = function() {
    if (typeof window.EmmaAvatar === 'undefined') {
      log('EmmaAvatar not available');
      return;
    }
    
    // Check quality settings
    if (this.quality) {
      var settings = this.quality.getCurrentSettings();
      if (!settings.emmaEnabled) {
        log('Emma avatar disabled by quality settings');
        return;
      }
    }
    
    try {
      this.emmaAvatar = new window.EmmaAvatar(this.scene, {
        defaultVisible: true
      });
      
      this.emmaAvatar.setPosition(0, 0, -8);
      this.emmaAvatar.setScale(0.45);
      
      log('Emma avatar integrated');
    } catch (e) {
      console.warn('[ParticleSystem] Emma avatar setup failed:', e);
    }
  };

    ParticleSystem.prototype.setupMorpher = function() {
  var self = this;
  
  // Use factory function if available (preferred)
  if (typeof window.getMorphEngine === 'function') {
    this.morpher = window.getMorphEngine({
      particleCount: this.particleCount,
      debug: this.options.debug
    });
    
    // Initialize GPU if renderer is available
    if (this.renderer && typeof this.morpher.initGPU === 'function') {
      var gpuSuccess = this.morpher.initGPU(this.renderer);
      log('GPU initialized for morpher:', gpuSuccess ? 'success' : 'failed (CPU fallback)');
    }
    
    log('Morpher integrated via factory, particleCount:', this.morpher.particleCount);
    return;
  }
  
  // Fallback: Direct class instantiation
  var MorphClass = window.MorphEngine || window.ParticleMorpher || window.FluidMorphEngine;
  
  if (typeof MorphClass === 'undefined') {
    log('MorphEngine not available');
    return;
  }
  
  // Always create with correct particle count
  this.morpher = new MorphClass({
    particleCount: this.particleCount,
    debug: this.options.debug
  });
  
  // Update global references
  window.morphEngine = this.morpher;
  window.particleMorpher = this.morpher;
  window.fluidMorphEngine = this.morpher;
  
  // Initialize GPU if renderer is available
  if (this.renderer && typeof this.morpher.initGPU === 'function') {
    var gpuSuccess = this.morpher.initGPU(this.renderer);
    log('GPU initialized for morpher:', gpuSuccess ? 'success' : 'failed (CPU fallback)');
  }
  
  log('Morpher integrated via class, particleCount:', this.morpher.particleCount);
};

  // ============================================
  // HERO RINGS (PHASE 5)
  // ============================================

  ParticleSystem.prototype.enableHeroRings = function(options) {
    if (this.heroRings) {
      log('Hero rings already enabled');
      return this.heroRings;
    }
    
    this.heroRings = new HeroRingSystem(this, options || {});
    
    // Expose globally for live-demo.js access
    window.demoHeroRings = this.heroRings;
    
    log('Hero rings enabled');
    return this.heroRings;
  };

  ParticleSystem.prototype.disableHeroRings = function() {
    if (this.heroRings) {
      this.heroRings.destroy();
      this.heroRings = null;
      window.demoHeroRings = null;
      log('Hero rings disabled');
    }
  };


  // ============================================
  // EVENT LISTENERS
  // ============================================

  ParticleSystem.prototype.setupEventListeners = function() {
    var self = this;
    
    // Window resize
    this.boundOnResize = function() { self.onResize(); };
    window.addEventListener('resize', this.boundOnResize);
    
    // Pointer move for parallax
    this.boundOnPointerMove = function(e) { self.onPointerMove(e); };
    this.container.addEventListener('mousemove', this.boundOnPointerMove);
    this.container.addEventListener('touchmove', function(e) { self.onTouchMove(e); }, { passive: true });
    
    // Voice amplitude
    this.boundOnVoice = function(e) {
      if (e.detail && typeof e.detail.amplitude === 'number') {
        self.setVoiceAmplitude(e.detail.amplitude);
      }
    };
    window.addEventListener('voiceAmplitude', this.boundOnVoice);
    window.addEventListener('sw:voiceAmplitude', this.boundOnVoice);
    
    // Industry change
    window.addEventListener('sw:industryPresetApplied', function(e) {
      if (e.detail && e.detail.industry) {
        self.onIndustryChanged(e.detail.industry, e.detail.preset);
      }
    });
    
    // Text zones updated
    window.addEventListener('sw:textZonesUpdated', function() {
      self.updateTextCollisionUniforms();
    });
    
    // Quality change
    if (this.quality) {
      this.boundOnQualityChange = function(e) {
        self.handleQualityChange(e.detail);
      };
      window.addEventListener('sw:qualityChange', this.boundOnQualityChange);
    }
  };

  ParticleSystem.prototype.onPointerMove = function(e) {
    var rect = this.container.getBoundingClientRect();
    var nx = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    var ny = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    this.pointer.x = nx;
    this.pointer.y = ny;
  };

  ParticleSystem.prototype.onTouchMove = function(e) {
    if (e.touches && e.touches.length > 0) {
      var touch = e.touches[0];
      var rect = this.container.getBoundingClientRect();
      var nx = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
      var ny = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
      this.pointer.x = nx;
      this.pointer.y = ny;
    }
  };

  // ============================================
  // QUALITY HANDLING
  // ============================================

  ParticleSystem.prototype.handleQualityChange = function(detail) {
    var settings = detail.settings;
    
    log('Quality changed to:', detail.newTier);
    
    // Update bloom
    if (this.bloomPass) {
      if (settings.bloomEnabled) {
        this.bloomPass.strength = settings.bloomStrength || 0.75;
        this.bloomPass.radius = settings.bloomRadius || 0.4;
      } else {
        this.bloomPass.strength = 0;
      }
    }
    
    // Update pixel ratio
    if (settings.pixelRatio && this.renderer) {
      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, settings.pixelRatio));
    }
    
    // Update Emma visibility
    if (this.emmaAvatar) {
      this.emmaAvatar.setVisible(settings.emmaEnabled !== false);
    }
  };

  // ============================================
  // MOTION PRESETS
  // ============================================

  ParticleSystem.prototype.setMotionPreset = function(presetName) {
    var preset = MOTION_PRESETS[presetName];
    if (!preset) {
      log('Unknown motion preset:', presetName);
      preset = MOTION_PRESETS.idle;
      presetName = 'idle';
    }
    
    this.currentMotionPreset = presetName;
    this.motionConfig = Object.assign({}, preset);
    
    if (this.uniforms) {
      this.uniforms.uRandom.value = preset.randomness;
      this.uniforms.uTurbulence.value = preset.turbulence;
      this.uniforms.uDepth.value = preset.depthOscillation;
      this.uniforms.uMotionSpeed.value = preset.motionSpeed;
      this.uniforms.uWaveFrequency.value = preset.waveFrequency;
      this.uniforms.uBreathingAmount.value = preset.breathingAmount;
    }
    
    log('Motion preset:', presetName);
  };

  // ============================================
  // EXPLOSION EFFECT
  // ============================================

  ParticleSystem.prototype.triggerExplosion = function(x, y, z) {

// If OrbitalFlow is active, OrbitalFlow owns explosion (detach + return)
  if (this.orbitalFlow && typeof this.orbitalFlow.triggerExplosion === 'function') {
    this.orbitalFlow.triggerExplosion({ x: x || 0, y: y || 0, z: z || 0 }, { lane: 'both' });
    return;
  }

  x = typeof x === 'number' ? x : 0;
  y = typeof y === 'number' ? y : 0;
  z = typeof z === 'number' ? z : 0;
  
  // Scale to world coords - use full viewport range
  var worldX = x * this.options.ellipsoidX;  // ~45 units
  var worldY = y * this.options.ellipsoidY;  // ~25 units
  var worldZ = z * this.options.ellipsoidZ;  // ~40 units
  
  this.explosion.active = true;
  this.explosion.origin.set(worldX, worldY, worldZ);
  this.explosion.startTime = performance.now();
  this.explosion.progress = 0;
  this.isExplosionActive = true;
  
  if (this.uniforms) {
    this.uniforms.uExplosionActive.value = 1.0;
    this.uniforms.uExplosionOrigin.value.copy(this.explosion.origin);
    this.uniforms.uExplosionProgress.value = 0;
    this.uniforms.uExplosionRadius.value = this.options.explosionRadius;
  }
  
  log('Explosion triggered at', x, y, z, '→ world:', worldX, worldY, worldZ);
  
  window.dispatchEvent(new CustomEvent('sw:explosionStarted', {
    detail: { origin: { x: x, y: y, z: z } }
  }));
};

  ParticleSystem.prototype.updateExplosion = function() {
 
    // OrbitalFlow owns explosion now
  if (this.orbitalFlow) return;

  if (!this.explosion.active) return;

  var now = performance.now();
  var duration = this.options.explosionDuration || 1100;
  var raw = now - this.explosion.startTime;

  // Clamp and guard against NaN
  var progress = raw / duration;
  if (!isFinite(progress)) progress = 1;

  progress = Math.min(Math.max(progress, 0), 1);

  this.explosion.progress = progress;

  if (this.uniforms) {
    this.uniforms.uExplosionProgress.value = progress;
  }

  if (progress >= 1) {
    this.explosion.active = false;
    this.isExplosionActive = false;
    if (this.uniforms) {
      this.uniforms.uExplosionActive.value = 0;
      this.uniforms.uExplosionProgress.value = 0;
    }
  }
};

  // ============================================
  // MORPHING
  // ============================================

    ParticleSystem.prototype.morphToShape = function(shapeName, duration) {
  var self = this;
  duration = duration || 1800;
  
  // Route to OrbitalFlow if active
  if (this.orbitalFlow) {
    console.log('[ParticleSystem] Routing shape morph to OrbitalFlow:', shapeName);
    return Promise.resolve(true);
  }
  
  if (!this.morpher) {
    log('Morpher not available');
    return Promise.reject(new Error('Morpher not available'));
  }
  
  // Resilient explosion check with timeout recovery
  if (this.isExplosionActive) {
    var now = performance.now();
    if (this.explosion && this.explosion.startTime && (now - this.explosion.startTime) < 2000) {
      log('Morph blocked during active explosion');
      return Promise.resolve(false);
    } else {
      log('Force-resetting stuck explosion state');
      this.isExplosionActive = false;
      this.explosion.active = false;
      if (this.uniforms) {
        this.uniforms.uExplosionActive.value = 0;
        this.uniforms.uExplosionProgress.value = 0;
      }
    }
  }
  
  if (this.isMorphing) {
    log('Morph request ignored: already morphing');
    return Promise.resolve(false);
  }
  
  this.isMorphing = true;
  
  return this.morpher.morphToShape(this, shapeName, { duration: duration, fluid: true })
    .then(function() {
      self.isMorphing = false;
    })
    .catch(function(err) {
      self.isMorphing = false;
      throw err;
    });
};

      ParticleSystem.prototype.morphToWord = function(word, duration) {
  var self = this;
  duration = duration || 1500;
  
  // Route to OrbitalFlow if active
  if (this.orbitalFlow) {
    console.log('[ParticleSystem] Routing word morph to OrbitalFlow:', word);
    return Promise.resolve(true);
  }
  
  if (!this.morpher) {
    log('Morpher not available');
    return Promise.reject(new Error('Morpher not available'));
  }
  
  // Resilient explosion check with timeout recovery
  if (this.isExplosionActive) {
    var now = performance.now();
    if (this.explosion && this.explosion.startTime && (now - this.explosion.startTime) < 2000) {
      log('Morph blocked during active explosion');
      return Promise.resolve(false);
    } else {
      log('Force-resetting stuck explosion state');
      this.isExplosionActive = false;
      this.explosion.active = false;
      if (this.uniforms) {
        this.uniforms.uExplosionActive.value = 0;
        this.uniforms.uExplosionProgress.value = 0;
      }
    }
  }
  
  if (this.isMorphing) {
    log('Morph request ignored: already morphing');
    return Promise.resolve(false);
  }
  
  this.isMorphing = true;
  
  return this.morpher.morphToWord(this, word, { duration: duration, fluid: true })
    .then(function() {
      self.isMorphing = false;
    })
    .catch(function(err) {
      self.isMorphing = false;
      throw err;
    });
};

  ParticleSystem.prototype.resetMorph = function(duration) {
    duration = duration || 1200;
    if (this.morpher) {
      this.morpher.resetMorph(this, duration);
    }
  };

  ParticleSystem.prototype.setMorphProgress = function(progress) {
  // OrbitalFlow owns all morphing - don't let GPU shader interfere
  if (this.orbitalFlow || this.gpuMorphDisabled) {
    return; // Silently ignore
  }

  if (this.uniforms && this.uniforms.uMorphProgress) {
    this.uniforms.uMorphProgress.value = progress;
  }
};

  // ============================================
  // INDUSTRY HANDLING
  // ============================================

  ParticleSystem.prototype.onIndustryChanged = function(industry, preset) {
    this.currentIndustry = industry;
    this.currentPreset = preset;
    
    // Update motion config
    if (preset && preset.motion) {
      this.setMotionPreset('idle'); // Reset to idle first
      
      // Apply preset-specific overrides
      if (this.uniforms) {
        if (preset.motion.randomness !== undefined) {
          this.uniforms.uRandom.value = preset.motion.randomness;
        }
        if (preset.motion.turbulence !== undefined) {
          this.uniforms.uTurbulence.value = preset.motion.turbulence;
        }
        if (preset.motion.speed !== undefined) {
          this.uniforms.uMotionSpeed.value = preset.motion.speed;
        }
      }
    }
    
    if (preset && preset.voiceResponse) {
      this.voiceConfig = Object.assign({}, preset.voiceResponse);
    }
    
    // Update particle colors
    if (preset && preset.colors) {
      this.updateParticleColors(preset.colors);
    }
    
    // Update glow color
    if (preset && preset.colors && preset.colors.glow && this.uniforms) {
      this.uniforms.uGlowColor.value.copy(preset.colors.glow);
    }
    
    // Update Emma
    if (this.emmaAvatar && preset) {
      this.emmaAvatar.applyPreset(preset);
    }
    
    // Trigger icon morph
    var self = this;
    if (preset && preset.iconShape && this.morpher) {
      setTimeout(function() {
        self.morphToShape(preset.iconShape, 1800);
      }, 300);
    }
    
    log('Industry changed to:', industry);
  };

  ParticleSystem.prototype.updateParticleColors = function(colors) {
    if (!colors || !this.particleGeometry) return;
    
    var colorAttr = this.particleGeometry.attributes.color;
    if (!colorAttr) return;
    
    var colorPalette = [
      colors.primary || new THREE.Color(0x7C3AED),
      colors.secondary || new THREE.Color(0x8B5CF6),
      colors.accent || new THREE.Color(0xADE8F4)
    ];
    
    for (var i = 0; i < this.particleCount; i++) {
      var rand = Math.random();
      var color;
      
      if (rand < 0.5) {
        color = colorPalette[0];
      } else if (rand < 0.8) {
        color = colorPalette[1];
      } else {
        color = colorPalette[2];
      }
      
      colorAttr.array[i * 3] = color.r;
      colorAttr.array[i * 3 + 1] = color.g;
      colorAttr.array[i * 3 + 2] = color.b;
    }
    
    colorAttr.needsUpdate = true;
  };

  ParticleSystem.prototype.applyIndustryPreset = function(industryKey) {
    if (typeof window.applyIndustryPreset === 'function') {
      window.applyIndustryPreset(this, industryKey);
    } else if (typeof window.INDUSTRY_PRESETS !== 'undefined') {
      var preset = window.INDUSTRY_PRESETS[industryKey];
      if (preset) {
        this.onIndustryChanged(industryKey, preset);
      }
    }
  };

  // ============================================
  // TEXT COLLISION
  // ============================================

  ParticleSystem.prototype.updateTextCollisionUniforms = function() {
    if (!this.textCollision || !this.uniforms) return;
    
    var textUniforms = this.textCollision.getShaderUniforms();
    
    if (textUniforms.uTextZoneCenters) {
      this.uniforms.uTextZoneCenters.value = textUniforms.uTextZoneCenters.value;
    }
    if (textUniforms.uTextZoneRadii) {
      this.uniforms.uTextZoneRadii.value = textUniforms.uTextZoneRadii.value;
    }
    if (textUniforms.uTextZoneCount) {
      this.uniforms.uTextZoneCount.value = textUniforms.uTextZoneCount.value;
    }
  };

  // ============================================
  // ANIMATION LOOP
  // ============================================

  ParticleSystem.prototype.animate = function() {
    var self = this;
    
    if (!this.isRunning) return;
    
    this.animationFrame = requestAnimationFrame(function() { self.animate(); });
    
    var deltaTime = this.clock.getDelta();
    var elapsedTime = this.clock.getElapsedTime();
    if (typeof window.extendedAnimationUpdate === 'function') {
  window.extendedAnimationUpdate(deltaTime);
}
    
    this.updateFPS();
    
    // Smooth pointer
    this.pointerSmooth.x += (this.pointer.x - this.pointerSmooth.x) * 0.08;
    this.pointerSmooth.y += (this.pointer.y - this.pointerSmooth.y) * 0.08;
    
    // Smooth voice amplitude
    var voiceMultiplier = this.voiceConfig.amplitudeMultiplier || 1.0;
    this.voiceAmplitude += (this.targetVoiceAmplitude * voiceMultiplier - this.voiceAmplitude) * CONFIG.voiceSmoothing;
    
if (this.orbitalFlow) {
  this.orbitalFlow.update(deltaTime);
}

    // Update uniforms
  if (this.uniforms) {
    this.uniforms.uTime.value = elapsedTime * 1000;
    this.uniforms.uDeltaTime.value = deltaTime;
    this.uniforms.uVoiceAmplitude.value = this.voiceAmplitude;
    this.uniforms.uPointer.value.set(this.pointerSmooth.x, this.pointerSmooth.y);
    
    // ========== NEW: Force GPU morph off when OrbitalFlow active ==========
    if (this.orbitalFlow && this.uniforms.uMorphProgress) {
      this.uniforms.uMorphProgress.value = 0;
    }
    // ======================================================================
  }
    
    // Group-level motion
    this.updateGroupMotion(elapsedTime, deltaTime);
    
    // Update explosion
    this.updateExplosion();
    
    // Update text collision if needed
    if (this.textCollision && this.textCollision.needsUpdate) {
      this.updateTextCollisionUniforms();
      this.textCollision.needsUpdate = false;
    }
    
        // Update hero rings (Phase 5)
    if (this.heroRings) {
      this.heroRings.update(deltaTime);
    }
    
    // Update Emma
    if (this.emmaAvatar) {
      this.emmaAvatar.setVoiceAmplitude(this.voiceAmplitude);
      this.emmaAvatar.update(deltaTime);
    }
    
     // Update quality system
    if (this.quality && typeof this.quality.measureFrame === 'function') {
      this.quality.measureFrame();
    }
    
    // Enforce calm limits before render
this.enforceUltraCalmLimits();

// HARD LOCK OVERRIDES (wins last)
this.applyHardTuneOverrides();

// Render
if (this.composer) {
  this.composer.render(deltaTime);
} else {
  this.renderer.render(this.scene, this.camera);
}
  };

  ParticleSystem.prototype.updateGroupMotion = function(time, deltaTime) {
  if (!this.particles) return;

  // When OrbitalFlow is active, keep the mesh mostly fixed in world space
  // and let OrbitalFlow control the per-particle positions.
  if (this.orbitalFlow) {
    // Mild pointer-based parallax only (so it still feels responsive)
    var parallaxX = this.pointerSmooth.x * 4.0;
    var parallaxY = this.pointerSmooth.y * 3.0;

    this.particles.position.set(parallaxX, parallaxY, 0);

    // Very subtle tilt based on pointer; no global spinning/orbiting
    var tiltSpeed = this.options.pointerTiltSpeed;
    this.particles.rotation.set(
      this.pointerSmooth.y * tiltSpeed * 0.3,
      this.pointerSmooth.x * tiltSpeed * 0.3,
      0
    );
    return;
  }

  // Legacy blob behavior when OrbitalFlow is not present
  this.particles.rotation.y = time * this.options.groupRotationSpeed;

  this.particles.rotation.x = Math.sin(time * 0.15) * this.options.groupTiltAmount;

  this.particles.position.y =
    Math.sin(time * this.options.groupBreathingSpeed) * this.options.groupBreathingAmount;

  var tilt = this.options.pointerTiltSpeed;
  this.particles.rotation.x += this.pointerSmooth.y * tilt * 0.5;
  this.particles.rotation.y += this.pointerSmooth.x * tilt * 0.5;
};

  ParticleSystem.prototype.updateFPS = function() {
    this.frameCount++;
    var now = performance.now();
    
    if (now - this.lastFPSUpdate >= 1000) {
      this.currentFPS = this.frameCount;
      this.frameCount = 0;
      this.lastFPSUpdate = now;
    }
  };

  // ============================================
  // RESIZE
  // ============================================

  ParticleSystem.prototype.onResize = function() {
    var width = this.container.clientWidth || window.innerWidth;
    var height = this.container.clientHeight || window.innerHeight;
    
    this.camera.aspect = width / height;
    this.camera.updateProjectionMatrix();
    
    this.renderer.setSize(width, height);
    
    if (this.composer) {
      this.composer.setSize(width, height);
    }
    
    if (this.bloomPass) {
      this.bloomPass.resolution.set(width, height);
    }
    
    if (this.textCollision) {
    this.textCollision.detectTextElements();
  }

  // Re-align hero rings to CSS aura on resize
  if (this.heroRings && typeof this.heroRings.alignToCssRings === 'function') {
    this.heroRings.alignToCssRings();
  }
};

  // ============================================
  // PUBLIC API
  // ============================================

  ParticleSystem.prototype.setVoiceAmplitude = function(amplitude) {
    this.targetVoiceAmplitude = Math.max(0, Math.min(1, amplitude));
  };

  ParticleSystem.prototype.setEmmaVisible = function(visible) {
    if (this.emmaAvatar) {
      this.emmaAvatar.setVisible(visible);
    }
  };

  ParticleSystem.prototype.getFPS = function() {
    return this.currentFPS;
  };

  ParticleSystem.prototype.getParticleCount = function() {
    return this.particleCount;
  };

  ParticleSystem.prototype.getCurrentIndustry = function() {
    return this.currentIndustry;
  };

  ParticleSystem.prototype.pause = function() {
    this.isRunning = false;
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = null;
    }
  };

  ParticleSystem.prototype.resume = function() {
    if (!this.isRunning) {
      this.isRunning = true;
      this.clock.start();
      this.animate();
    }
  };

  ParticleSystem.prototype.getStats = function() {
    return {
      particles: this.particleCount,
      fps: this.currentFPS,
      industry: this.currentIndustry,
      motionPreset: this.currentMotionPreset,
      voiceAmplitude: this.voiceAmplitude,
      isMorphing: this.isMorphing,
      isExplosionActive: this.isExplosionActive,
      ringCount: this.heroRings ? this.heroRings.rings.length : 0,
      emmaVisible: this.emmaAvatar ? this.emmaAvatar.isVisible : false,
      quality: this.quality ? this.quality.getCurrentTier() : 'unknown'
    };
  };

  // ============================================
  // CLEANUP
  // ============================================

  ParticleSystem.prototype.destroy = function() {
    log('Destroying Particle System...');
    
    // Stop animation loop
    this.isRunning = false;
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = null;
    }
    
    // Remove event listeners
    if (this.boundOnResize) {
      window.removeEventListener('resize', this.boundOnResize);
    }
    if (this.boundOnPointerMove) {
      this.container.removeEventListener('mousemove', this.boundOnPointerMove);
    }
    if (this.boundOnVoice) {
      window.removeEventListener('voiceAmplitude', this.boundOnVoice);
      window.removeEventListener('sw:voiceAmplitude', this.boundOnVoice);
    }
    if (this.boundOnQualityChange) {
      window.removeEventListener('sw:qualityChange', this.boundOnQualityChange);
    }
    
    // Destroy subsystems
if (this.emmaAvatar) {
  this.emmaAvatar.destroy();
  this.emmaAvatar = null;
}

if (this.heroRings) {
  this.heroRings.destroy();
  this.heroRings = null;
  window.demoHeroRings = null;
}

if (this.orbitalFlow) {
  this.orbitalFlow.destroy();
  if (window.demoOrbitalFlow === this.orbitalFlow) {
    window.demoOrbitalFlow = null;
  }
  this.orbitalFlow = null;
}

if (this.textCollision) {
  this.textCollision.destroy();
  this.textCollision = null;
}
    
    // Dispose particle system
    if (this.particles) {
      this.scene.remove(this.particles);
    }
    if (this.particleGeometry) {
      this.particleGeometry.dispose();
    }
    if (this.particleMaterial) {
      this.particleMaterial.dispose();
    }
    this.particles = null;
    this.particleGeometry = null;
    this.particleMaterial = null;
    
    // Dispose post-processing
    if (this.bloomPass) {
      this.bloomPass = null;
    }
    if (this.composer) {
      if (this.composer.renderTarget1) this.composer.renderTarget1.dispose();
      if (this.composer.renderTarget2) this.composer.renderTarget2.dispose();
      this.composer = null;
    }
    
    // Dispose renderer
    if (this.renderer) {
      this.renderer.dispose();
      if (this.renderer.domElement && this.renderer.domElement.parentNode) {
        this.renderer.domElement.parentNode.removeChild(this.renderer.domElement);
      }
      this.renderer = null;
    }
    
    // Clear scene
    if (this.scene) {
      while (this.scene.children.length > 0) {
        var obj = this.scene.children[0];
        this.scene.remove(obj);
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) {
          if (Array.isArray(obj.material)) {
            obj.material.forEach(function(m) { m.dispose(); });
          } else {
            obj.material.dispose();
          }
        }
      }
      this.scene = null;
    }
    
    this.camera = null;
    this.clock = null;
    this.morpher = null;
    this.uniforms = null;
    this.originalPositions = null;
    this.targetPositions = null;
    this.velocities = null;
    this.container = null;
    
    log('Particle System destroyed');
  };

   // ============================================
  // ULTRA-CALM LIMITS ENFORCEMENT
  // ============================================

  ParticleSystem.prototype.enforceUltraCalmLimits = function() {
     if (this.options.ultraCalmClamp === false) return;
    var uniforms = this.particleMaterial ? this.particleMaterial.uniforms : 
                   (this.particles && this.particles.material ? this.particles.material.uniforms : null);
    
    if (!uniforms) return;
    
    // Hard limits - never exceed these
    var CALM_LIMITS = {
      uTurbulence: 0.008,
      uRandom: 0.025,
      uWaveFrequency: 0.18,
      uMotionSpeed: 0.05,
      uBreathingAmount: 0.006
    };
    
    for (var key in CALM_LIMITS) {
      if (uniforms[key] && uniforms[key].value > CALM_LIMITS[key]) {
        uniforms[key].value = CALM_LIMITS[key];
      }
    }
  };

  ParticleSystem.prototype.applyHardTuneOverrides = function() {
  if (!SW_HARD_TUNE || !SW_HARD_TUNE.enabled) return;

  var u = this.uniforms || (this.particleMaterial ? this.particleMaterial.uniforms : null);
  if (!u) return;

  var locks = SW_HARD_TUNE.uniforms || {};
  for (var key in locks) {
    if (u[key]) u[key].value = locks[key];
  }
};

  // ============================================
  // INITIALIZATION
  // ============================================

  function initialize() {
  // Export main class
  window.ParticleSystem = ParticleSystem;
  
  // Export supporting classes
  // NOTE: old RingSystem has been removed
  window.MOTION_PRESETS = MOTION_PRESETS;
  window.PARTICLE_VERTEX_SHADER = PARTICLE_VERTEX_SHADER;
  window.PARTICLE_FRAGMENT_SHADER = PARTICLE_FRAGMENT_SHADER;
  
  // Legacy aliases for backward compatibility
  window.EnhancedParticleSystem = ParticleSystem;
  window.EnhancedParticleRenderer = ParticleSystem;
  
  log('Particle System module loaded');
  
  window.dispatchEvent(new CustomEvent('sw:particleSystemReady'));
  window.dispatchEvent(new CustomEvent('sw:enhancedParticleSystemReady')); // Legacy
  window.dispatchEvent(new CustomEvent('sw:enhancedRendererReady')); // Legacy
}

  waitForDependencies(initialize);

})();


// ─── orbital-flow-system.js (Orbital ring flow + side morphing system) ───
/**
 * orbital-flow-system.js - FIXED VERSION v2.4
 * 
 * Key fixes:
 * 1. Vertical word layout (letters stacked S-M-I-L-E)
 * 2. Better vertical letter positioning
 * 3. Tuned for left-side word lane placement
 */

(function() {
  'use strict';

  var CONFIG = {
  leftLaneRatio: 0.5,
  rightLaneRatio: 0.5,

  leftOrbit: {
    centerX: -22,
    centerY: 0,
    centerZ: -5,
    radiusX: 6,    // <-- Smaller ball
    radiusY: 8,
    radiusZ: 3
  },
  rightOrbit: {
    centerX: 22,
    centerY: 0,
    centerZ: -5,
    radiusX: 6,    // <-- Smaller ball
    radiusY: 8,
    radiusZ: 3
  },

  leftLane: {
    worldX: -22,
    worldY: 0,
    worldZ: -3
  },
  rightLane: {
    worldX: 22,
    worldY: 0,
    worldZ: -3
  },

  shapeScale: 0.45,
  wordScale: 0.40,

    // VERTICAL WORD LAYOUT CONFIG
    verticalWord: {
      letterHeight: 5,      // Height of each letter block
      letterWidth: 4,       // Width of each letter block  
      letterSpacing: 1.5,   // Vertical gap between letters
      letterDepth: 2        // Z thickness
    },

// Stroke thickness / density control (does NOT change wordScale)
wordParticleFillRatio: 0.75, // 1.0 = thick (uses all left lane particles); 0.6–0.85 recommended

// Jitter controls (lower = crisper, less “bendy”)
wordJitter: {
  xMul: 0.0,  // 0.0 = razor sharp
  yMul: 0.010,
  zMul: 0.060
},

    orbitSpeedBase: 0.02,        // ultra calm
  orbitSpeedVariation: 0.02,
  orbitRadiusVariation: 0.08,

    morphTravelDuration: 400,
    morphFormDuration: 700,
    morphHoldDuration: 3000,
    morphDissolveDuration: 400,
    morphReturnDuration: 600,

    orbitLerp: 0.05,
    travelLerp: 0.15,
    formLerp: 0.1,
        returnLerp: 0.04,

    // Explosion (OrbitalFlow-owned): detach → float → spring back
   explosion: {
  anchorMode: 'dynamic', // 'snapshot' or 'dynamic' (dynamic feels more “physics”)

  maxDuration: 2.6,
  expandTime: 0.70,
  returnTime: 1.60,

  strength: 24.0,
  randomness: 0.65,

  // Physics
  damping: 0.90,        // higher = glidier float, less energy loss
  springK: 28.0,        // lower = looser, more physical return
  springDamp: 8.0,      // lower = more bounce

  gravity: { x: 0.0, y: -3.0, z: 0.0 },   // subtle downward drift (tune)
  bounds: { x: 40, y: 24, z: 30 },        // soft “world box”
  restitution: 0.55                         // bounce off bounds
},

    debug: true
  };

  // Simple letter patterns for vertical display (5 wide x 7 tall)
  var LETTER_PATTERNS = {
    'A': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]],
    'B': [[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0]],
    'C': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,1],[0,1,1,1,0]],
    'D': [[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0]],
    'E': [[1,1,1,1,1],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,1]],
    'F': [[1,1,1,1,1],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0]],
    'G': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,0],[1,0,1,1,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
    'H': [[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]],
    'I': [[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[1,1,1,1,1]],
    'J': [[0,0,1,1,1],[0,0,0,1,0],[0,0,0,1,0],[0,0,0,1,0],[1,0,0,1,0],[1,0,0,1,0],[0,1,1,0,0]],
    'K': [[1,0,0,0,1],[1,0,0,1,0],[1,0,1,0,0],[1,1,0,0,0],[1,0,1,0,0],[1,0,0,1,0],[1,0,0,0,1]],
    'L': [[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,1]],
    'M': [[1,0,0,0,1],[1,1,0,1,1],[1,0,1,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]],
    'N': [[1,0,0,0,1],[1,1,0,0,1],[1,0,1,0,1],[1,0,0,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]],
    'O': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
    'P': [[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0],[1,0,0,0,0],[1,0,0,0,0],[1,0,0,0,0]],
    'Q': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,1,0],[0,1,1,0,1]],
    'R': [[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,1,1,1,0],[1,0,1,0,0],[1,0,0,1,0],[1,0,0,0,1]],
    'S': [[0,1,1,1,1],[1,0,0,0,0],[1,0,0,0,0],[0,1,1,1,0],[0,0,0,0,1],[0,0,0,0,1],[1,1,1,1,0]],
    'T': [[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]],
    'U': [[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
    'V': [[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,0,1,0],[0,1,0,1,0],[0,0,1,0,0]],
    'W': [[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,1,0,1],[1,1,0,1,1],[1,0,0,0,1]],
    'X': [[1,0,0,0,1],[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0],[0,1,0,1,0],[1,0,0,0,1],[1,0,0,0,1]],
    'Y': [[1,0,0,0,1],[1,0,0,0,1],[0,1,0,1,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]],
    'Z': [[1,1,1,1,1],[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0],[1,0,0,0,0],[1,1,1,1,1]],
    '0': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,1,1],[1,0,1,0,1],[1,1,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
    '1': [[0,0,1,0,0],[0,1,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,1,1,1,0]],
    '2': [[0,1,1,1,0],[1,0,0,0,1],[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0],[0,1,0,0,0],[1,1,1,1,1]],
    '3': [[0,1,1,1,0],[1,0,0,0,1],[0,0,0,0,1],[0,0,1,1,0],[0,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
    '4': [[0,0,0,1,0],[0,0,1,1,0],[0,1,0,1,0],[1,0,0,1,0],[1,1,1,1,1],[0,0,0,1,0],[0,0,0,1,0]],
    '5': [[1,1,1,1,1],[1,0,0,0,0],[1,1,1,1,0],[0,0,0,0,1],[0,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
    '6': [[0,1,1,1,0],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
    '7': [[1,1,1,1,1],[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0]],
    '8': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
    '9': [[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,1],[0,0,0,0,1],[0,0,0,0,1],[0,1,1,1,0]],
    ' ': [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]],
    '!': [[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,1,0,0]],
    '?': [[0,1,1,1,0],[1,0,0,0,1],[0,0,0,0,1],[0,0,0,1,0],[0,0,1,0,0],[0,0,0,0,0],[0,0,1,0,0]],
    '.': [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,1,0,0]],
    '+': [[0,0,0,0,0],[0,0,1,0,0],[0,0,1,0,0],[1,1,1,1,1],[0,0,1,0,0],[0,0,1,0,0],[0,0,0,0,0]],
    '-': [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[1,1,1,1,1],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]],
    '$': [[0,0,1,0,0],[0,1,1,1,1],[1,0,1,0,0],[0,1,1,1,0],[0,0,1,0,1],[1,1,1,1,0],[0,0,1,0,0]],
    '%': [[1,1,0,0,1],[1,1,0,1,0],[0,0,1,0,0],[0,0,1,0,0],[0,1,0,1,1],[1,0,0,1,1],[0,0,0,0,0]],
    '&': [[0,1,1,0,0],[1,0,0,1,0],[1,0,0,1,0],[0,1,1,0,0],[1,0,0,1,1],[1,0,0,0,1],[0,1,1,1,1]],
    '*': [[0,0,0,0,0],[0,0,1,0,0],[1,0,1,0,1],[0,1,1,1,0],[1,0,1,0,1],[0,0,1,0,0],[0,0,0,0,0]]
  };

  function strideFor(len) {
  // choose a stride that spreads repeats instead of marching in-order
  var primes = [97, 89, 83, 79, 73, 71, 67, 61, 59, 53, 47, 43, 41, 37, 31];
  for (var i = 0; i < primes.length; i++) {
    var p = primes[i];
    if (len % p !== 0) return p;
  }
  return 1;
}

  function OrbitalFlowSystem(particleSystem, options) {
    options = options || {};
    
    this.config = {};
    for (var k in CONFIG) {
      if (typeof CONFIG[k] === 'object' && CONFIG[k] !== null) {
        this.config[k] = {};
        for (var kk in CONFIG[k]) {
          this.config[k][kk] = CONFIG[k][kk];
        }
      } else {
        this.config[k] = options[k] !== undefined ? options[k] : CONFIG[k];
      }
    }
    
    // Merge nested options
    if (options.leftOrbit) {
      for (var lo in options.leftOrbit) {
        this.config.leftOrbit[lo] = options.leftOrbit[lo];
      }
    }
    if (options.rightOrbit) {
      for (var ro in options.rightOrbit) {
        this.config.rightOrbit[ro] = options.rightOrbit[ro];
      }
    }
    if (options.leftLane) {
      for (var ll in options.leftLane) {
        this.config.leftLane[ll] = options.leftLane[ll];
      }
    }
    if (options.rightLane) {
      for (var rl in options.rightLane) {
        this.config.rightLane[rl] = options.rightLane[rl];
      }
    }

        // Merge explosion options
    if (options.explosion) {
      this.config.explosion = this.config.explosion || {};
      for (var exk in options.explosion) {
        this.config.explosion[exk] = options.explosion[exk];
      }
    }

    this.ps = particleSystem;
    
    if (!this.ps || !this.ps.particles) {
      console.error('[OrbitalFlow] Invalid particle system provided');
      return;
    }

    this.particleCount = this.ps.particleCount || 1500;

    // Initialize morpher with retry
    this.morpher = null;
    this._initMorpher();

    this.leftCount = Math.floor(this.particleCount * this.config.leftLaneRatio);
    this.rightCount = this.particleCount - this.leftCount;

    // Per-particle data arrays
    this.laneAssignments = new Int8Array(this.particleCount);
    this.phases = new Float32Array(this.particleCount);
    this.radiiX = new Float32Array(this.particleCount);
    this.radiiY = new Float32Array(this.particleCount);
    this.radiiZ = new Float32Array(this.particleCount);
    this.speeds = new Float32Array(this.particleCount);
    this.phaseOffsets = new Float32Array(this.particleCount);
    this.states = new Uint8Array(this.particleCount);

    this.morphTargets = new Float32Array(this.particleCount * 3);

    // ============================================
    // EXPLOSION (OrbitalFlow-owned detach/return)
    // ============================================
    this.explosionActive = false;
    this.explosionAge = 0;
    this.explosionOrigin = { x: 0, y: 0, z: 0 };

    this.preExplosionStates = new Uint8Array(this.particleCount);
    this.explosionAnchors = new Float32Array(this.particleCount * 3); // snapshot of "grouped look"
    this.explosionVels = new Float32Array(this.particleCount * 3);
    this.explodingMask = new Uint8Array(this.particleCount); // 1 if affected


    // Separate morph state for each lane
    this.leftMorph = { phase: 'idle', target: null, type: null, progress: 0, startTime: 0 };
    this.rightMorph = { phase: 'idle', target: null, type: null, progress: 0, startTime: 0 };

    // Separate morph state for each lane
this.leftMorph = { phase: 'idle', target: null, type: null, progress: 0, startTime: 0 };
this.rightMorph = { phase: 'idle', target: null, type: null, progress: 0, startTime: 0 };

// Morph pause bookkeeping (so explosions don't desync morph timelines)
this._morphPause = {
  left:  { paused: false, elapsed: 0 },
  right: { paused: false, elapsed: 0 }
};

this.time = 0;
this.isEnabled = true;
    this.currentIndustry = 'dental';

    // Word/icon pools per industry
    this.words = ['GROW', 'SCALE', 'WIN', 'ROI', 'EMMA', 'AI'];
    this.icons = ['dental', 'hvac', 'legal', 'plumbing', 'medspa', 'pest'];
    this.wordIndex = 0;
    this.iconIndex = 0;

    this._initParticles();
    this._bindEvents();

    console.log('[OrbitalFlow] Initialized v2.4 (vertical words):', {
      particles: this.particleCount,
      leftCount: this.leftCount,
      rightCount: this.rightCount,
      hasMorpher: !!this.morpher
    });
  }

  OrbitalFlowSystem.prototype._initMorpher = function() {
  var ps = this.ps;
  
  // Lock orbital config values to prevent override
  if (ps && ps.orbitalFlow && ps.orbitalFlow.config) {
    ps.orbitalFlow.config.orbitSpeedBase = 0.02;
    ps.orbitalFlow.config.orbitRadiusVariation = 0.08;
  }
  
  // Also lock on self (this IS the orbitalFlow)
  this.config.orbitSpeedBase = 0.02;
  this.config.orbitRadiusVariation = 0.08;
  
  if (ps && ps.morpher) {
    this.morpher = ps.morpher;
    console.log('[OrbitalFlow] Using particle system morpher');
    return;
  }
  
  if (typeof window.getMorphEngine === 'function') {
    this.morpher = window.getMorphEngine({ particleCount: this.particleCount });
    console.log('[OrbitalFlow] Using getMorphEngine factory');
    return;
  }
  
  if (window.morphEngine) {
    this.morpher = window.morphEngine;
    console.log('[OrbitalFlow] Using global morphEngine');
    return;
  }
  
  if (window.MorphEngine) {
    this.morpher = new window.MorphEngine({ particleCount: this.particleCount });
    console.log('[OrbitalFlow] Created new MorphEngine instance');
    return;
  }

  console.warn('[OrbitalFlow] No morpher available - will use fallback shapes');
};

  OrbitalFlowSystem.prototype._initParticles = function() {
    var leftOrbit = this.config.leftOrbit;
    var rightOrbit = this.config.rightOrbit;
    
    for (var i = 0; i < this.particleCount; i++) {
      var isLeft = i < this.leftCount;
      var orbit = isLeft ? leftOrbit : rightOrbit;
      
      this.laneAssignments[i] = isLeft ? 0 : 1;
      
      var variation = this.config.orbitRadiusVariation;
      this.radiiX[i] = orbit.radiusX * (1 - variation/2 + Math.random() * variation);
      this.radiiY[i] = orbit.radiusY * (1 - variation/2 + Math.random() * variation);
      this.radiiZ[i] = orbit.radiusZ * (1 - variation/2 + Math.random() * variation);
      
      this.phases[i] = Math.random() * Math.PI * 2;
      this.phaseOffsets[i] = Math.random() * Math.PI * 2;
      this.speeds[i] = 1 - this.config.orbitSpeedVariation/2 + Math.random() * this.config.orbitSpeedVariation;
      
      this.states[i] = 0;

      this.morphTargets[i * 3] = 0;
      this.morphTargets[i * 3 + 1] = 0;
      this.morphTargets[i * 3 + 2] = 0;
    }
    
    this._setInitialPositions();
  };

  OrbitalFlowSystem.prototype._setInitialPositions = function() {
    var geom = this._getGeometry();
    if (!geom) return;
    
    var positions = geom.attributes.offset || geom.attributes.position;
    if (!positions) {
      console.error('[OrbitalFlow] No position attribute found');
      return;
    }
    
    var arr = positions.array;
    var leftOrbit = this.config.leftOrbit;
    var rightOrbit = this.config.rightOrbit;
    
    for (var i = 0; i < this.particleCount; i++) {
      var i3 = i * 3;
      var isLeft = this.laneAssignments[i] === 0;
      var orbit = isLeft ? leftOrbit : rightOrbit;
      
      var phase = this.phases[i];
      var phaseOffset = this.phaseOffsets[i];
      
      arr[i3] = orbit.centerX + Math.cos(phase) * this.radiiX[i];
      arr[i3 + 1] = orbit.centerY + Math.sin(phase) * this.radiiY[i];
      arr[i3 + 2] = orbit.centerZ + Math.sin(phase + phaseOffset) * this.radiiZ[i];
    }
    
    positions.needsUpdate = true;
    console.log('[OrbitalFlow] Initial positions set');
  };

  OrbitalFlowSystem.prototype._getGeometry = function() {
    if (!this.ps || !this.ps.particles || !this.ps.particles.geometry) {
      return null;
    }
    return this.ps.particles.geometry;
  };

  OrbitalFlowSystem.prototype._bindEvents = function() {
    var self = this;

    window.addEventListener('sw:morphWord', function(e) {
      if (e.detail && e.detail.word) {
        self.morphWord(e.detail.word);
      }
    });

    window.addEventListener('sw:morphIcon', function(e) {
      if (e.detail && e.detail.icon) {
        self.morphIcon(e.detail.icon);
      }
    });
  };

  // ============================================
  // MORPH API - INDEPENDENT LANES
  // ============================================

  OrbitalFlowSystem.prototype.morphWord = function(word) {
    if (!this.isEnabled) {
      console.log('[OrbitalFlow] morphWord blocked: system disabled');
      return false;
    }
    
    if (this.leftMorph.phase !== 'idle') {
      console.log('[OrbitalFlow] morphWord blocked: left lane busy, phase=' + this.leftMorph.phase);
      return false;
    }

    word = String(word).toUpperCase();
    console.log('[OrbitalFlow] morphWord starting (VERTICAL):', word);

    // Generate VERTICAL word shape
    var shapePositions = this._generateVerticalWordShape(word);
    
    if (!shapePositions || shapePositions.length === 0) {
      console.warn('[OrbitalFlow] Failed to generate vertical word shape for:', word);
      return false;
    }

    console.log('[OrbitalFlow] Generated', shapePositions.length, 'positions for vertical word');

    this._setMorphTargetsForLane(0, shapePositions);

    this.leftMorph = {
      target: word,
      type: 'word',
      phase: 'travel',
      progress: 0,
      startTime: performance.now()
    };

    // Set left lane particles to morphing state
    for (var i = 0; i < this.leftCount; i++) {
      this.states[i] = 1;
    }

    console.log('[OrbitalFlow] LEFT lane morphing to VERTICAL word:', word);
    return true;
  };

  OrbitalFlowSystem.prototype.morphIcon = function(icon) {
    if (!this.isEnabled) {
      console.log('[OrbitalFlow] morphIcon blocked: system disabled');
      return false;
    }
    
    if (this.rightMorph.phase !== 'idle') {
      console.log('[OrbitalFlow] morphIcon blocked: right lane busy, phase=' + this.rightMorph.phase);
      return false;
    }

    icon = String(icon).toLowerCase();
    console.log('[OrbitalFlow] morphIcon starting:', icon);

    var shapePositions = this._generateIconShape(icon);
    
    if (!shapePositions || shapePositions.length === 0) {
      console.warn('[OrbitalFlow] Failed to generate icon shape for:', icon);
      return false;
    }

    console.log('[OrbitalFlow] Generated', shapePositions.length, 'positions for icon');

    this._setMorphTargetsForLane(1, shapePositions);

    this.rightMorph = {
      target: icon,
      type: 'icon',
      phase: 'travel',
      progress: 0,
      startTime: performance.now()
    };

    // Set right lane particles to morphing state
    for (var i = this.leftCount; i < this.particleCount; i++) {
      this.states[i] = 1;
    }

    console.log('[OrbitalFlow] RIGHT lane morphing to icon:', icon);
    return true;
  };

  OrbitalFlowSystem.prototype._setMorphTargetsForLane = function(lane, shapePositions) {
    var startIdx = lane === 0 ? 0 : this.leftCount;
    var endIdx = lane === 0 ? this.leftCount : this.particleCount;
    var laneCenter = lane === 0 ? this.config.leftLane : this.config.rightLane;
    var scale = lane === 0 ? this.config.wordScale : this.config.shapeScale;

    console.log('[OrbitalFlow] Setting targets for lane', lane, ':', startIdx, 'to', endIdx);

    for (var i = startIdx; i < endIdx; i++) {
      var laneIdx = i - startIdx;
      var len = shapePositions.length || 1;
      var stride = strideFor(len);
      var shapeIdx = (laneIdx * stride) % len;
      var p = shapePositions[shapeIdx];

      var i3 = i * 3;
      this.morphTargets[i3] = laneCenter.worldX + (p.x || 0) * scale;
      this.morphTargets[i3 + 1] = laneCenter.worldY + (p.y || 0) * scale;
      this.morphTargets[i3 + 2] = laneCenter.worldZ + ((p.z || 0) * scale * 0.4);
    }
  };

  // ============================================
  // VERTICAL WORD SHAPE GENERATOR
  // ============================================

  OrbitalFlowSystem.prototype._generateVerticalWordShape = function(word) {
  var points = [];
  var cfg = this.config.verticalWord;

  var letterH = cfg.letterHeight;
  var letterW = cfg.letterWidth;
  var spacing = cfg.letterSpacing;
  var depth   = cfg.letterDepth;

  // Thickness control without changing wordScale:
  // Use a fraction of left lane particles to avoid “too bold/big” strokes.
  var fillRatio = (this.config.wordParticleFillRatio != null) ? this.config.wordParticleFillRatio : 1.0;
  fillRatio = Math.max(0.15, Math.min(1.0, fillRatio));
  var targetCount = Math.max(1, Math.floor(this.leftCount * fillRatio));

  // Vertical stacking bounds
  word = String(word || '').toUpperCase();
  var totalHeight = word.length * (letterH + spacing) - spacing;
  var topY = totalHeight / 2;

  // Collect all filled cells across the whole word
  var filledCells = [];
  for (var li = 0; li < word.length; li++) {
    var ch = word[li];
    var pattern = LETTER_PATTERNS[ch] || LETTER_PATTERNS[' '];
    if (!pattern) continue;

    var letterY = topY - li * (letterH + spacing);

    for (var row = 0; row < 7; row++) {
      for (var col = 0; col < 5; col++) {
        if (pattern[row] && pattern[row][col] === 1) {
          // Cell center in local space
          var cellX = (col - 2) * (letterW / 4.0);
          var cellY = letterY - (row - 3) * (letterH / 6.0);
          filledCells.push({ x: cellX, y: cellY });
        }
      }
    }
  }

  if (filledCells.length === 0) return [];

  // Small jitter to avoid perfect LED pixels
  var j = this.config.wordJitter || {};
  var jitterX = letterW * (j.xMul != null ? j.xMul : 0.01);
  var jitterY = letterH * (j.yMul != null ? j.yMul : 0.01);
  var jitterZ = depth   * (j.zMul != null ? j.zMul : 0.06);

  // EVEN distribution: round-robin across cells to avoid missing strokes
  for (var i = 0; i < targetCount; i++) {
    var cell = filledCells[i % filledCells.length];
    points.push({
      x: cell.x + (Math.random() - 0.5) * jitterX,
      y: cell.y + (Math.random() - 0.5) * jitterY,
      z: (Math.random() - 0.5) * jitterZ
    });
  }

  // HARD CENTER the word
  var minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  for (var p = 0; p < points.length; p++) {
    var pt = points[p];
    if (pt.x < minX) minX = pt.x;
    if (pt.x > maxX) maxX = pt.x;
    if (pt.y < minY) minY = pt.y;
    if (pt.y > maxY) maxY = pt.y;
  }
  var cx = (minX + maxX) * 0.5;
  var cy = (minY + maxY) * 0.5;

  for (var q = 0; q < points.length; q++) {
    points[q].x -= cx;
    points[q].y -= cy;
  }

  return points;
};

  OrbitalFlowSystem.prototype._generateWordShape = function(word) {
    // Try morpher first for fancy rendering
    if (this.morpher && typeof this.morpher.generateWordShape === 'function') {
      try {
        var shape = this.morpher.generateWordShape(word);
        if (shape && shape.length > 0) {
          // Morpher returns horizontal - we need to convert or skip
          // For now, prefer our vertical generator
          console.log('[OrbitalFlow] Skipping morpher, using vertical generator');
        }
      } catch (e) {
        console.warn('[OrbitalFlow] morpher.generateWordShape failed:', e);
      }
    }

    // Use vertical word shape
    return this._generateVerticalWordShape(word);
  };

  OrbitalFlowSystem.prototype._generateIconShape = function(icon) {
    // Try morpher's shape library
    if (this.morpher && this.morpher.shapes) {
      var shapeKey = icon;
      
      if (typeof window.mapIndustryToIconShape === 'function') {
        shapeKey = window.mapIndustryToIconShape(icon) || icon;
      }

      if (this.morpher.shapes[shapeKey]) {
        return this.morpher.shapes[shapeKey];
      }
      
      if (this.morpher.shapes[icon]) {
        return this.morpher.shapes[icon];
      }
    }

    // Fallback: star/flower shape
    return this._generateFallbackIconShape(icon);
  };

  OrbitalFlowSystem.prototype._generateFallbackIconShape = function(icon) {
    var points = [];
    var count = this.rightCount;

    // Create a star-like pattern
    for (var i = 0; i < count; i++) {
      var t = i / count;
      var angle = t * Math.PI * 2 * 4;
      var r = 8 + Math.sin(t * Math.PI * 8) * 5;

      points.push({
        x: Math.cos(angle) * r + (Math.random() - 0.5) * 2,
        y: Math.sin(angle) * r + (Math.random() - 0.5) * 2,
        z: (Math.random() - 0.5) * 4
      });
    }

    return points;
  };

  // ============================================
  // MAIN UPDATE LOOP
  // ============================================

  OrbitalFlowSystem.prototype.update = function(deltaTime) {
    if (!this.isEnabled) return;

    var geom = this._getGeometry();
    if (!geom) return;

    var positions = geom.attributes.offset || geom.attributes.position;
    if (!positions || !positions.array) return;

    this.time += deltaTime;
    var arr = positions.array;

    this._updateMorphState(this.leftMorph, 'left');
    this._updateMorphState(this.rightMorph, 'right');

     // Advance explosion time + hard-stop if needed
    if (this.explosionActive) {
      this.explosionAge += deltaTime;
      var maxD = (this.config.explosion && this.config.explosion.maxDuration) ? this.config.explosion.maxDuration : 2.2;

      if (this.explosionAge > maxD) {
        // Restore anything still exploding
        for (var k = 0; k < this.particleCount; k++) {
          if (this.states[k] === 3) {
            this.states[k] = this.preExplosionStates[k];
            this.explodingMask[k] = 0;
          }
        }
        this.explosionActive = false;

        // Resume paused morph timers (so phases continue where they left off)
var resumeNow = performance.now();
if (this._morphPause.left.paused && this.leftMorph && this.leftMorph.phase !== 'idle') {
  this.leftMorph.startTime = resumeNow - this._morphPause.left.elapsed;
}
if (this._morphPause.right.paused && this.rightMorph && this.rightMorph.phase !== 'idle') {
  this.rightMorph.startTime = resumeNow - this._morphPause.right.elapsed;
}
this._morphPause.left.paused = false;
this._morphPause.right.paused = false;
      }
    }

    for (var i = 0; i < this.particleCount; i++) {
      var i3 = i * 3;
      var state = this.states[i];
      var lane = this.laneAssignments[i];

     if (state === 0) {
        this._updateOrbitingParticle(i, i3, arr, lane, deltaTime);
      } else if (state === 1) {
        var morph = lane === 0 ? this.leftMorph : this.rightMorph;
        this._updateMorphingParticle(i, i3, arr, morph, lane);
      } else if (state === 3) {
        this._updateExplodingParticle(i, i3, arr, deltaTime);
      } else {
        this._updateReturningParticle(i, i3, arr, lane);
      }
    }

    // FAILSAFE: if explosion ended, no particles may remain in state 3
if (!this.explosionActive) {
  for (var i = 0; i < this.particleCount; i++) {
    if (this.states[i] === 3) {
      this.states[i] = this.preExplosionStates[i] || 0;
      this.explodingMask[i] = 0;
    }
  }
}
    positions.needsUpdate = true;
  };

  OrbitalFlowSystem.prototype._updateMorphState = function(morph, laneName) {
  if (!morph || morph.phase === 'idle') return;

  // Pause morph phase progression during explosions
  if (this.explosionActive) {
    var pause = (laneName === 'left') ? this._morphPause.left : this._morphPause.right;
    if (pause && pause.paused) return;
  }

  // Always source uniforms safely from this.ps (no global getParticleSystem)
  var uniforms =
    (this.ps && this.ps.particleMaterial && this.ps.particleMaterial.uniforms) ||
    (this.ps && this.ps.particles && this.ps.particles.material && this.ps.particles.material.uniforms) ||
    null;

  var now = performance.now();
  var elapsed = now - morph.startTime;

  var travelEnd   = this.config.morphTravelDuration;
  var formEnd     = travelEnd + this.config.morphFormDuration;
  var holdEnd     = formEnd + this.config.morphHoldDuration;
  var dissolveEnd = holdEnd + this.config.morphDissolveDuration;
  var returnEnd   = dissolveEnd + this.config.morphReturnDuration;

  var prevPhase = morph.phase;

  if (elapsed < travelEnd) {
    morph.phase = 'travel';
    morph.progress = elapsed / travelEnd;
  } else if (elapsed < formEnd) {
    morph.phase = 'form';
    morph.progress = (elapsed - travelEnd) / this.config.morphFormDuration;
  } else if (elapsed < holdEnd) {
    morph.phase = 'hold';
    morph.progress = (elapsed - formEnd) / this.config.morphHoldDuration;
  } else if (elapsed < dissolveEnd) {
    morph.phase = 'dissolve';
    morph.progress = (elapsed - holdEnd) / this.config.morphDissolveDuration;
  } else if (elapsed < returnEnd) {
    morph.phase = 'return';
    morph.progress = (elapsed - dissolveEnd) / this.config.morphReturnDuration;

    // Mark lane particles as "returning" (state 2) ONLY if they're currently morphing (state 1).
    var startIdx = (laneName === 'left') ? 0 : this.leftCount;
    var endIdx   = (laneName === 'left') ? this.leftCount : this.particleCount;
    for (var i = startIdx; i < endIdx; i++) {
      if (this.states[i] === 1) this.states[i] = 2;
    }
  } else {
    morph.phase = 'idle';
    morph.progress = 0;
    morph.target = null;
    if (this.config.debug) console.log('[OrbitalFlow]', laneName.toUpperCase(), 'morph complete');
  }

  // Optional: keep shader drift ultra-calm during visible shape phases
  if (uniforms) {
    var inShapePhase = (morph.phase === 'form' || morph.phase === 'hold');
    if (uniforms.uRandom)          uniforms.uRandom.value          = inShapePhase ? 0.015 : 0.025;
    if (uniforms.uTurbulence)      uniforms.uTurbulence.value      = inShapePhase ? 0.004 : 0.008;
    if (uniforms.uWaveFrequency)   uniforms.uWaveFrequency.value   = 0.18;
    if (uniforms.uBreathingAmount) uniforms.uBreathingAmount.value = 0.006;
  }

  if (this.config.debug && prevPhase !== morph.phase) {
    console.log('[OrbitalFlow]', laneName, 'phase:', prevPhase, '->', morph.phase);
  }
};


 OrbitalFlowSystem.prototype._updateOrbitingParticle = function(idx, i3, arr, lane, deltaTime) {
  var orbit = lane === 0 ? this.config.leftOrbit : this.config.rightOrbit;

  this._advanceOrbitPhase(idx, deltaTime);
  var phase = this.phases[idx];
  var phaseOffset = this.phaseOffsets[idx]; // <-- FIX: define it

  var targetX = orbit.centerX + Math.cos(phase) * this.radiiX[idx];
  var targetY = orbit.centerY + Math.sin(phase) * this.radiiY[idx];
  var targetZ = orbit.centerZ + Math.sin(phase + phaseOffset) * this.radiiZ[idx];


    var turbulence = Math.sin(this.time * 0.4 + idx * 0.08) * 0.4;
    targetX += turbulence;
    targetY += turbulence * 0.6;

    var lerp = this.config.orbitLerp;
    arr[i3] += (targetX - arr[i3]) * lerp;
    arr[i3 + 1] += (targetY - arr[i3 + 1]) * lerp;
    arr[i3 + 2] += (targetZ - arr[i3 + 2]) * lerp;
  };

  OrbitalFlowSystem.prototype._updateMorphingParticle = function(idx, i3, arr, morph, lane) {
    if (!morph || morph.phase === 'idle') {
      this.states[idx] = 2;
      return;
    }

    var laneCenter = lane === 0 ? this.config.leftLane : this.config.rightLane;
    var laneIdx = lane === 0 ? idx : (idx - this.leftCount);

    var targetX, targetY, targetZ;
    var lerp;

    if (morph.phase === 'travel') {
      var gatherProgress = this._easeOutCubic(morph.progress);
      
      targetX = arr[i3] + (laneCenter.worldX - arr[i3]) * gatherProgress;
      targetY = arr[i3 + 1] + (laneCenter.worldY - arr[i3 + 1]) * gatherProgress * 0.6;
      targetZ = arr[i3 + 2] + (laneCenter.worldZ - arr[i3 + 2]) * gatherProgress * 0.4;
      lerp = this.config.travelLerp;

    } else if (morph.phase === 'form' || morph.phase === 'hold') {
      targetX = this.morphTargets[i3];
      targetY = this.morphTargets[i3 + 1];
      targetZ = this.morphTargets[i3 + 2];
      lerp = morph.phase === 'form' ? this.config.formLerp : this.config.formLerp * 0.3;

    } else if (morph.phase === 'dissolve') {
      var dissolveProgress = this._easeInCubic(morph.progress);
      var angle = laneIdx * 0.12 + this.time * 1.5;
      var dissolveR = 6 + dissolveProgress * 12;
      
      targetX = laneCenter.worldX + Math.cos(angle) * dissolveR;
      targetY = laneCenter.worldY + Math.sin(angle) * dissolveR;
      targetZ = laneCenter.worldZ + (Math.random() - 0.5) * 15 * dissolveProgress;
      lerp = this.config.travelLerp;

    } else {
      targetX = arr[i3];
      targetY = arr[i3 + 1];
      targetZ = arr[i3 + 2];
      lerp = this.config.orbitLerp;
    }

    arr[i3] += (targetX - arr[i3]) * lerp;
    arr[i3 + 1] += (targetY - arr[i3 + 1]) * lerp;
    arr[i3 + 2] += (targetZ - arr[i3 + 2]) * lerp;
  };

  OrbitalFlowSystem.prototype._updateReturningParticle = function(idx, i3, arr, lane) {
    var orbit = lane === 0 ? this.config.leftOrbit : this.config.rightOrbit;
    var phase = this.phases[idx];
    var phaseOffset = this.phaseOffsets[idx];

    var targetX = orbit.centerX + Math.cos(phase) * this.radiiX[idx];
    var targetY = orbit.centerY + Math.sin(phase) * this.radiiY[idx];
    var targetZ = orbit.centerZ + Math.sin(phase + phaseOffset) * this.radiiZ[idx];

    var lerp = this.config.returnLerp;
    arr[i3] += (targetX - arr[i3]) * lerp;
    arr[i3 + 1] += (targetY - arr[i3 + 1]) * lerp;
    arr[i3 + 2] += (targetZ - arr[i3 + 2]) * lerp;

    var dx = targetX - arr[i3];
    var dy = targetY - arr[i3 + 1];
    var dz = targetZ - arr[i3 + 2];
    var distSq = dx * dx + dy * dy + dz * dz;
    
    if (distSq < 4) {
      this.states[idx] = 0;
    }
  };

  OrbitalFlowSystem.prototype._advanceOrbitPhase = function(idx, deltaTime) {
    var dir = idx % 2 === 0 ? 1 : -1;
    this.phases[idx] += deltaTime * this.config.orbitSpeedBase * this.speeds[idx] * dir;
  };

  // Easing functions
  OrbitalFlowSystem.prototype._easeOutCubic = function(t) {
    return 1 - Math.pow(1 - t, 3);
  };

  OrbitalFlowSystem.prototype._easeInCubic = function(t) {
    return t * t * t;
  };

    // ============================================
  // EXPLOSION HELPERS (detach → float → spring back)
  // ============================================

  OrbitalFlowSystem.prototype._smoothstep = function(a, b, x) {
    x = Math.max(0, Math.min(1, (x - a) / (b - a)));
    return x * x * (3 - 2 * x);
  };

  OrbitalFlowSystem.prototype._epicenterToWorld = function(epicenter) {
    var x = epicenter && typeof epicenter.x === 'number' ? epicenter.x : 0;
    var y = epicenter && typeof epicenter.y === 'number' ? epicenter.y : 0;
    var z = epicenter && typeof epicenter.z === 'number' ? epicenter.z : 0;

    // If it looks like NDC (-1..1), map to your rough world range
    var isNDC = (Math.abs(x) <= 1.5 && Math.abs(y) <= 1.5);
    if (isNDC) {
      return { x: x * 30, y: y * 20, z: -5 + z * 10 };
    }
    return { x: x, y: y, z: z };
  };

  // PUBLIC: triggers a detach+return explosion. lane: 'left'|'right'|'both'
  OrbitalFlowSystem.prototype.triggerExplosion = function(epicenter, opts) {
    opts = opts || {};
    var geom = this._getGeometry();
    if (!geom) return false;

    var positions = geom.attributes.offset || geom.attributes.position;
    if (!positions || !positions.array) return false;

    var arr = positions.array;
    var origin = this._epicenterToWorld(epicenter || { x: 0, y: 0, z: 0 });

    var exp = this.config.explosion || {};
    var strength = (opts.strength != null) ? opts.strength : exp.strength;
    var randomness = (opts.randomness != null) ? opts.randomness : exp.randomness;

      var laneMode = opts.lane || 'both';
  var affectLeft = (laneMode === 'both' || laneMode === 'left');
  var affectRight = (laneMode === 'both' || laneMode === 'right');

  // Pause morph timers so phases don't advance while particles are detached
  var now = performance.now();

  if (affectLeft && this.leftMorph && this.leftMorph.phase && this.leftMorph.phase !== 'idle') {
    this._morphPause.left.paused = true;
    this._morphPause.left.elapsed = now - this.leftMorph.startTime;
  }
  if (affectRight && this.rightMorph && this.rightMorph.phase && this.rightMorph.phase !== 'idle') {
    this._morphPause.right.paused = true;
    this._morphPause.right.elapsed = now - this.rightMorph.startTime;
  }

  this.explosionActive = true;
    this.explosionAge = 0;
    this.explosionOrigin.x = origin.x;
    this.explosionOrigin.y = origin.y;
    this.explosionOrigin.z = origin.z;

    for (var i = 0; i < this.particleCount; i++) {
      var lane = this.laneAssignments[i]; // 0 left, 1 right
      var ok = (lane === 0 && affectLeft) || (lane === 1 && affectRight);
      this.explodingMask[i] = ok ? 1 : 0;
      if (!ok) continue;

      var i3 = i * 3;

      // Anchor = current "grouped look" snapshot
      this.explosionAnchors[i3] = arr[i3];
      this.explosionAnchors[i3 + 1] = arr[i3 + 1];
      this.explosionAnchors[i3 + 2] = arr[i3 + 2];

      // Remember what it was doing, then mark exploding
      this.preExplosionStates[i] = this.states[i];
      this.states[i] = 3; // NEW state: exploding

      // Outward impulse (+ randomized direction)
      var dx = arr[i3] - origin.x;
      var dy = arr[i3 + 1] - origin.y;
      var dz = arr[i3 + 2] - origin.z;

      var dist = Math.sqrt(dx * dx + dy * dy + dz * dz) + 0.0001;
      var nx = dx / dist, ny = dy / dist, nz = dz / dist;

      var rx = (Math.random() - 0.5);
      var ry = (Math.random() - 0.5);
      var rz = (Math.random() - 0.5);
      var rlen = Math.sqrt(rx * rx + ry * ry + rz * rz) + 0.0001;
      rx /= rlen; ry /= rlen; rz /= rlen;

      nx = nx * (1 - randomness) + rx * randomness;
      ny = ny * (1 - randomness) + ry * randomness;
      nz = nz * (1 - randomness) + rz * randomness;

      var nlen = Math.sqrt(nx * nx + ny * ny + nz * nz) + 0.0001;
      nx /= nlen; ny /= nlen; nz /= nlen;

      // Gentle falloff so far particles don’t teleport
      var falloff = 1 / (0.8 + dist * 0.06);
      var v = strength * (0.65 + Math.random() * 0.7) * falloff;

      this.explosionVels[i3] = nx * v;
      this.explosionVels[i3 + 1] = ny * v;
      this.explosionVels[i3 + 2] = nz * v;
    }

    return true;
  };

    OrbitalFlowSystem.prototype._getExplosionAnchor = function(idx, i3, lane) {
    var exp = this.config.explosion || {};
    if (exp.anchorMode !== 'dynamic') {
      return {
        x: this.explosionAnchors[i3],
        y: this.explosionAnchors[i3 + 1],
        z: this.explosionAnchors[i3 + 2]
      };
    }

    // Dynamic anchor: if it was orbiting, anchor = current orbit target
    var pre = this.preExplosionStates[idx];

    if (pre === 0) {
      // orbit target from current phase
      var orbit = lane === 0 ? this.config.leftOrbit : this.config.rightOrbit;
      var phase = this.phases[idx];
      var phaseOffset = this.phaseOffsets[idx];

      return {
        x: orbit.centerX + Math.cos(phase) * this.radiiX[idx],
        y: orbit.centerY + Math.sin(phase) * this.radiiY[idx],
        z: orbit.centerZ + Math.sin(phase + phaseOffset) * this.radiiZ[idx]
      };
    }

   // If it was morphing, anchor back to morphTargets (clean shape reform)
  if (pre === 1) {
    // Only lock to morphTargets when the lane is actually in a stable shape phase
    // (form/hold). During travel/dissolve, morphTargets may not represent the visible intent.
    var morph = (lane === 0) ? this.leftMorph : this.rightMorph;
    var stable = morph && (morph.phase === 'form' || morph.phase === 'hold');

    if (stable) {
      return {
        x: this.morphTargets[i3],
        y: this.morphTargets[i3 + 1],
        z: this.morphTargets[i3 + 2]
      };
    }
  }

  // Otherwise (returning/travel/dissolve), anchor to the snapshot for stability
  return {
    x: this.explosionAnchors[i3],
    y: this.explosionAnchors[i3 + 1],
    z: this.explosionAnchors[i3 + 2]
  };
  };

  OrbitalFlowSystem.prototype._updateExplodingParticle = function(idx, i3, arr, deltaTime) {
    var exp = this.config.explosion || {};
    var dt = Math.max(0.001, Math.min(0.05, deltaTime)); // seconds

    // keep orbit “clock” moving even while detached
this._advanceOrbitPhase(idx, dt);


   var lane = this.laneAssignments[idx];
   var a = this._getExplosionAnchor(idx, i3, lane);
   var ax0 = a.x, ay0 = a.y, az0 = a.z;

    var t = this.explosionAge;
    var expandT = exp.expandTime || 0.55;
    var returnT = exp.returnTime || 1.25;

    // ballistic early, spring later
    var pullOn = this._smoothstep(expandT * 0.7, returnT, t);

    var k = exp.springK || 38.0;
    var sd = exp.springDamp || 10.0;

    var px = arr[i3], py = arr[i3 + 1], pz = arr[i3 + 2];
    var vx = this.explosionVels[i3], vy = this.explosionVels[i3 + 1], vz = this.explosionVels[i3 + 2];

    var fx = (ax0 - px) * (k * pullOn) - vx * (sd * pullOn);
    var fy = (ay0 - py) * (k * pullOn) - vy * (sd * pullOn);
    var fz = (az0 - pz) * (k * pullOn) - vz * (sd * pullOn);

    // Gravity (subtle)
var g = exp.gravity || { x: 0, y: 0, z: 0 };
vx += (fx + (g.x || 0)) * dt;
vy += (fy + (g.y || 0)) * dt;
vz += (fz + (g.z || 0)) * dt;

// Soft world bounds bounce
var b = exp.bounds || null;
if (b) {
  var r = exp.restitution != null ? exp.restitution : 0.55;

  if (arr[i3] < -b.x) { arr[i3] = -b.x; vx = Math.abs(vx) * r; }
  if (arr[i3] >  b.x) { arr[i3] =  b.x; vx = -Math.abs(vx) * r; }

  if (arr[i3 + 1] < -b.y) { arr[i3 + 1] = -b.y; vy = Math.abs(vy) * r; }
  if (arr[i3 + 1] >  b.y) { arr[i3 + 1] =  b.y; vy = -Math.abs(vy) * r; }

  if (arr[i3 + 2] < -b.z) { arr[i3 + 2] = -b.z; vz = Math.abs(vz) * r; }
  if (arr[i3 + 2] >  b.z) { arr[i3 + 2] =  b.z; vz = -Math.abs(vz) * r; }
}

    var damp = exp.damping || 0.86;
    var dampPow = Math.pow(damp, dt * 60);
    vx *= dampPow; vy *= dampPow; vz *= dampPow;

    arr[i3] = px + vx * dt;
    arr[i3 + 1] = py + vy * dt;
    arr[i3 + 2] = pz + vz * dt;

    this.explosionVels[i3] = vx;
    this.explosionVels[i3 + 1] = vy;
    this.explosionVels[i3 + 2] = vz;

    // settle + restore prior state
    if (t > (exp.maxDuration || 2.2) * 0.65) {
      var dx = ax0 - arr[i3], dy = ay0 - arr[i3 + 1], dz = az0 - arr[i3 + 2];
      var distSq = dx * dx + dy * dy + dz * dz;
      var speedSq = vx * vx + vy * vy + vz * vz;

      if (distSq < 0.25 && speedSq < 0.08) {
        arr[i3] = ax0; arr[i3 + 1] = ay0; arr[i3 + 2] = az0;
        this.states[idx] = this.preExplosionStates[idx];
        this.explodingMask[idx] = 0;
      }
    }
  };

  // ============================================
  // PUBLIC API
  // ============================================

  OrbitalFlowSystem.prototype.setIndustry = function(industry) {
    industry = (industry || '').toLowerCase();
    if (industry === 'law') industry = 'legal';
    if (industry === 'pestcontrol' || industry === 'pest control') industry = 'pest';

    this.currentIndustry = industry;

    var iconMap = {
      dental: ['dental', 'smile', 'tooth'],
      hvac: ['hvac', 'flame', 'snowflake'],
      legal: ['legal', 'scales', 'gavel'],
      plumbing: ['plumbing', 'wrench', 'droplet'],
      medspa: ['medspa', 'sparkle', 'lotus'],
      pest: ['pest', 'shield', 'ant']
    };

    var wordMap = {
      dental: ['SMILE', 'CARE', 'BRIGHT', 'TEETH'],
      hvac: ['COOL', 'HEAT', 'COMFORT', 'AIR'],
      legal: ['WIN', 'JUSTICE', 'DEFEND', 'TRUST'],
      plumbing: ['FLOW', 'FIX', 'FAST', 'PIPES'],
      medspa: ['GLOW', 'RENEW', 'BEAUTY', 'RADIANT'],
      pest: ['SAFE', 'GUARD', 'SHIELD', 'PROTECT']
    };

    if (iconMap[industry]) {
      this.icons = iconMap[industry];
      this.iconIndex = 0;
    }

    if (wordMap[industry]) {
      this.words = wordMap[industry];
      this.wordIndex = 0;
    }

    console.log('[OrbitalFlow] Industry set to:', industry);
  };

  OrbitalFlowSystem.prototype.getNextWord = function() {
    var word = this.words[this.wordIndex % this.words.length];
    this.wordIndex++;
    return word;
  };

  OrbitalFlowSystem.prototype.getNextIcon = function() {
    var icon = this.icons[this.iconIndex % this.icons.length];
    this.iconIndex++;
    return icon;
  };

  OrbitalFlowSystem.prototype.enable = function() {
    this.isEnabled = true;
  };

  OrbitalFlowSystem.prototype.disable = function() {
    this.isEnabled = false;
  };

  OrbitalFlowSystem.prototype.getStats = function() {
    var leftOrbiting = 0, leftMorphing = 0, leftReturning = 0;
    var rightOrbiting = 0, rightMorphing = 0, rightReturning = 0;

    for (var i = 0; i < this.particleCount; i++) {
      var state = this.states[i];
      if (this.laneAssignments[i] === 0) {
        if (state === 0) leftOrbiting++;
        else if (state === 1) leftMorphing++;
        else leftReturning++;
      } else {
        if (state === 0) rightOrbiting++;
        else if (state === 1) rightMorphing++;
        else rightReturning++;
      }
    }

    return {
      leftLane: {
        total: this.leftCount,
        orbiting: leftOrbiting,
        morphing: leftMorphing,
        returning: leftReturning,
        currentMorph: this.leftMorph.target,
        phase: this.leftMorph.phase
      },
      rightLane: {
        total: this.rightCount,
        orbiting: rightOrbiting,
        morphing: rightMorphing,
        returning: rightReturning,
        currentMorph: this.rightMorph.target,
        phase: this.rightMorph.phase
      }
    };
  };

  OrbitalFlowSystem.prototype.destroy = function() {
    this.isEnabled = false;
    this.leftMorph = { phase: 'idle', target: null, type: null, progress: 0, startTime: 0 };
    this.rightMorph = { phase: 'idle', target: null, type: null, progress: 0, startTime: 0 };
    console.log('[OrbitalFlow] Destroyed');
  };

  // ============================================
  // EXPORT
  // ============================================

  window.OrbitalFlowSystem = OrbitalFlowSystem;
  console.log('[OrbitalFlowSystem] Dual-lane module v2.4 (VERTICAL WORDS) loaded');

})();


// ─── particle-intelligence.js (State machine orchestrator (11 states)) ───
/**
 * particle-intelligence.js
 * ShockwaveHQ — Particle Behavior State Machine & Orchestrator
 * 
 * Central nervous system for all particle behaviors:
 * - 11 states with validated transitions
 * - State blending between transitions
 * - Event-driven animations
 * - Physics simulation coordination
 * - Emma avatar synchronization
 * - Fusion sequences for cinematic moments
 * - Voice reactivity coordination
 * - Industry-aware morphing
 * 
 * Dependencies: THREE.js, adaptive-quality.js, morph-engine.js
 * 
 * Usage:
 *   const intelligence = new ParticleIntelligenceSystem({ industry: 'dental' });
 *   await intelligence.init('#canvas');
 *   intelligence.setState('LISTENING');
 */

(function() {
  'use strict';

  // ============================================
  // WAIT FOR DEPENDENCIES
  // ============================================

  function waitForDependencies(callback, maxAttempts) {
    maxAttempts = maxAttempts || 100;
    var attempts = 0;
    
    var check = function() {
      attempts++;
      var hasThree = typeof THREE !== 'undefined';
      var hasMorph = typeof window.MorphEngine !== 'undefined';
      
      if (hasThree && hasMorph) {
        callback();
      } else if (attempts < maxAttempts) {
        setTimeout(check, 50);
      } else {
        console.warn('[ParticleIntelligence] Some dependencies not found:', {
          THREE: hasThree,
          MorphEngine: hasMorph
        });
        // Initialize anyway with reduced functionality
        callback();
      }
    };
    check();
  }

  // ============================================
  // STATE DEFINITIONS (11 STATES)
  // ============================================

  var STATES = {
    INITIALIZING: 'INITIALIZING',
    GREETING: 'GREETING',
    IDLE: 'IDLE',
    LISTENING: 'LISTENING',
    FORMING: 'FORMING',
    LOCKED: 'LOCKED',
    COALESCING: 'COALESCING',
    FUSED: 'FUSED',
    MORPHING: 'MORPHING',
    EXPLODING: 'EXPLODING',
    REFORMING: 'REFORMING'
  };

  // Valid state transitions
  var TRANSITIONS = {
    INITIALIZING: ['GREETING', 'IDLE'],
    GREETING: ['IDLE'],
    IDLE: ['LISTENING', 'FORMING', 'COALESCING', 'EXPLODING', 'MORPHING'],
    LISTENING: ['IDLE', 'FORMING', 'MORPHING'],
    FORMING: ['LOCKED', 'IDLE', 'EXPLODING'],
    LOCKED: ['IDLE', 'EXPLODING', 'COALESCING', 'MORPHING'],
    COALESCING: ['FUSED', 'EXPLODING'],
    FUSED: ['MORPHING', 'EXPLODING', 'IDLE'],
    MORPHING: ['FUSED', 'EXPLODING', 'IDLE', 'LOCKED'],
    EXPLODING: ['REFORMING'],
    REFORMING: ['IDLE']
  };

  // State configuration with parameters
  var STATE_CONFIG = {
    INITIALIZING: {
      name: 'Initializing',
      turbulence: 0.1,
      motionSpeed: 0.1,
      breathingAmount: 0.01,
      orbitSpeed: 0.01,
      randomness: 0.2,
      depthOscillation: 0.5,
      waveFrequency: 0.5,
      allowMorph: false,
      allowExplosion: false,
      emmaState: 'idle',
      duration: null
    },
    GREETING: {
      name: 'Greeting',
      turbulence: 0.4,
      motionSpeed: 0.5,
      breathingAmount: 0.06,
      orbitSpeed: 0.05,
      randomness: 0.6,
      depthOscillation: 1.2,
      waveFrequency: 1.2,
      allowMorph: false,
      allowExplosion: false,
      emmaState: 'excited',
      duration: 2500
    },
    IDLE: {
    name: 'Idle',
    turbulence: 0.08,         // Was 0.3 → still calm but alive
    motionSpeed: 0.08,        // Was 0.3
    breathingAmount: 0.015,   // Was 0.05
    orbitSpeed: 0.01,         // Was 0.04
    randomness: 0.25,         // Was 1.0
    depthOscillation: 0.4,    // Was 1.0
    waveFrequency: 0.3,       // Was 1.0
    allowMorph: true,
    allowExplosion: true,
    emmaState: 'idle',
    duration: null
  },
    LISTENING: {
      name: 'Listening',
      turbulence: 0.35,
      motionSpeed: 0.4,
      breathingAmount: 0.06,
      orbitSpeed: 0.05,
      randomness: 0.8,
      depthOscillation: 1.1,
      waveFrequency: 1.3,
      allowMorph: true,
      allowExplosion: true,
      emmaState: 'listening',
      duration: null
    },
    FORMING: {
    name: 'Forming',
    turbulence: 0.002,        // Was 0.15 → 7.5x calmer
    motionSpeed: 0.01,        // Was 0.1 → 10x slower
    breathingAmount: 0.002,   // Was 0.02 → 10x less
    orbitSpeed: 0.005,        // Was 0.02 → 4x slower
    randomness: 0.01,         // Was 0.3 → 30x tighter
    depthOscillation: 0.1,    // Was 0.6 → 6x less depth jitter
    waveFrequency: 0.05,      // Was 0.7 → 14x calmer
    allowMorph: false,
    allowExplosion: false,
    emmaState: 'watching',
    duration: 2000
  },
  LOCKED: {
    name: 'Locked',
    turbulence: 0.001,        // Was 0.1 → 100x calmer
    motionSpeed: 0.005,       // Was 0.08 → 16x slower
    breathingAmount: 0.001,   // Was 0.015 → 15x less
    orbitSpeed: 0.002,        // Was 0.015 → 7.5x slower
    randomness: 0.005,        // Was 0.12 → 24x tighter (CRITICAL for clean text)
    depthOscillation: 0.05,   // Was 0.65 → 13x less depth jitter
    waveFrequency: 0.03,      // Was 0.75 → 25x calmer
    allowMorph: false,
    allowExplosion: true,
    emmaState: 'watching',
    duration: 4000
  },
    COALESCING: {
      name: 'Coalescing',
      turbulence: 0.2,
      motionSpeed: 0.15,
      breathingAmount: 0.03,
      orbitSpeed: 0.03,
      randomness: 0.4,
      depthOscillation: 0.8,
      waveFrequency: 0.9,
      allowMorph: false,
      allowExplosion: false,
      emmaState: 'focusing',
      duration: 2000
    },
    FUSED: {
    name: 'Fused',
    turbulence: 0.001,        // Was 0.05
    motionSpeed: 0.005,       // Was 0.05
    breathingAmount: 0.001,   // Was 0.01
    orbitSpeed: 0.002,
    randomness: 0.005,        // Was 0.06
    depthOscillation: 0.05,   // Was 0.4
    waveFrequency: 0.03,      // Was 0.6
    allowMorph: true,
    allowExplosion: true,
    emmaState: 'powerful',
    duration: null
  },
    MORPHING: {
      name: 'Morphing',
      turbulence: 0.15,
      motionSpeed: 0.1,
      breathingAmount: 0.02,
      orbitSpeed: 0.02,
      randomness: 0.25,
      depthOscillation: 0.7,
      waveFrequency: 0.8,
      allowMorph: false,
      allowExplosion: false,
      emmaState: 'transforming',
      duration: 2500
    },
    EXPLODING: {
      name: 'Exploding',
      turbulence: 0.8,
      motionSpeed: 0.0,
      breathingAmount: 0.0,
      orbitSpeed: 0.0,
      randomness: 1.5,
      depthOscillation: 2.0,
      waveFrequency: 2.0,
      allowMorph: false,
      allowExplosion: false,
      emmaState: 'excited',
      duration: 600
    },
    REFORMING: {
      name: 'Reforming',
      turbulence: 0.25,
      motionSpeed: 0.2,
      breathingAmount: 0.04,
      orbitSpeed: 0.04,
      randomness: 0.5,
      depthOscillation: 0.9,
      waveFrequency: 1.0,
      allowMorph: false,
      allowExplosion: false,
      emmaState: 'recovering',
      duration: 1200
    }
  };

  // ============================================
  // TIMING CONFIGURATION
  // ============================================

  var TIMING = {
    greeting: 2500,
    formHold: 4000,
    explosion: 600,
    reform: 1200,
    coalesce: 2000,
    morph: 2500,
    morphReturn: 4000,
    ripple: 400,
    scatter: 500,
    float: 600,
    converge: 1000,
    solidify: 400,
    fusionSequence: 8000,
    celebrationBurst: 1000
  };

  // ============================================
  // CONFIGURATION
  // ============================================

  var CONFIG = {
    // State blending
    blendSpeed: 0.08,
    fastBlendSpeed: 0.15,
    
    // Physics
    defaultGravity: { x: 0, y: 0, z: 0 },
    voiceGravityMultiplier: 0.5,
    
    // Voice reactivity
    voiceSmoothing: 0.15,
    voiceThreshold: 0.05,
    voiceHighThreshold: 0.3,
    
    // Morph
    morphReturnDelay: 4000,
    autoMorphInterval: 12000,
    autoMorphEnabled: true,
    
    // Rings
    ringSpawnInterval: 6000,
    celebrationRingBurst: 5,
    explosionRingCount: 5,
    idleRingCount: 1,
    
    // Pointer
    pointerInfluence: 0.5,
    pointerRepulsionRadius: 20,
    
    // Performance
    maxMorphQueueLength: 5,

    // Morph uniform freezing (OFF by default)
    freezeUniformsDuringMorph: false,

    // Debug
    debug: false
  };

  // ============================================
  // INDUSTRY MAPPINGS
  // ============================================

  var INDUSTRY_SHAPES = {
    dental: 'dental',
    hvac: 'hvac',
    legal: 'legal',
    plumbing: 'plumbing',
    medspa: 'medspa',
    pest: 'pest',
    pestcontrol: 'pest',
    default: 'blob'
  };

  var INDUSTRY_WORDS = {
    dental: ['SMILE', 'CARE', 'TEETH', 'DENTAL', 'BRIGHT', 'HEALTHY'],
    hvac: ['COMFORT', 'COOL', 'HEAT', 'AIR', 'HOME', 'WARM'],
    legal: ['JUSTICE', 'LAW', 'DEFEND', 'WIN', 'RIGHTS', 'TRUST'],
    plumbing: ['FLOW', 'FIX', 'PIPES', 'WATER', 'FAST', 'RELIABLE'],
    medspa: ['GLOW', 'RENEW', 'BEAUTY', 'SPA', 'RADIANT', 'YOUTH'],
    pest: ['SHIELD', 'SAFE', 'GUARD', 'PROTECT', 'CLEAN', 'HOME'],
    pestcontrol: ['SHIELD', 'SAFE', 'GUARD', 'PROTECT', 'CLEAN', 'HOME'],
    default: ['GROW', 'SCALE', 'EMMA', 'AI', 'CALL', 'WIN', 'ROI']
  };

  var INDUSTRY_ALTERNATE_SHAPES = {
    dental: ['dental', 'smile', 'sparkle'],
    hvac: ['hvac', 'flame', 'snowflake'],
    legal: ['legal', 'gavel', 'shield'],
    plumbing: ['plumbing', 'wrench', 'droplet'],
    medspa: ['medspa', 'lotus', 'face', 'sparkle'],
    pest: ['shield', 'ant', 'bee', 'checkmark'],
    pestcontrol: ['shield', 'ant', 'bee', 'checkmark'],
    default: ['blob', 'sphere', 'torus', 'helix']
  };

  // ============================================
  // PARTICLE INTELLIGENCE SYSTEM CLASS
  // ============================================

  function ParticleIntelligenceSystem(options) {
    var self = this;
    options = options || {};
    
    // Configuration
    this.options = {};
    for (var key in CONFIG) {
      this.options[key] = CONFIG[key];
    }
    for (var key2 in options) {
      this.options[key2] = options[key2];
    }
    
    // Core references
    this.particleSystem = null;
    this.canvas = null;
    this.container = null;
    
    // Modules
    this.modules = {
      renderer: null,
      morpher: null,
      quality: null,
      emma: null,
      textCollision: null,
      ringSystem: null
    };
    
    // State machine
    this.currentState = STATES.INITIALIZING;
    this.previousState = null;
    this.stateStartTime = performance.now();
    this.stateEndTime = null;
    this.transitionProgress = 0;
    
    // Blended parameters (smoothly interpolated)
    this.blendedParams = this.cloneStateConfig(STATE_CONFIG.IDLE);
    this.targetParams = this.cloneStateConfig(STATE_CONFIG.IDLE);
    
    // Voice state
    this.voiceAmplitude = 0;
    this.targetVoiceAmplitude = 0;
    this.isVoiceActive = false;
    this.voicePeakTime = 0;
    
    // Morphing state
    this.currentMorphShape = null;
    this.morphProgress = 0;
    this.isMorphing = false;
    this.lastMorphTime = 0;
    this.morphQueue = [];
    this.lockedShape = null;
    this.autoMorphEnabled = this.options.autoMorphEnabled;
    
    // Explosion state
    this.isExploding = false;
    this.explosionProgress = 0;
    this.explosionOrigin = { x: 0, y: 0, z: 0 };
    
    // Fusion sequence
    this.isFusionSequenceActive = false;
    this.fusionStage = 0;
    
    // Industry
    this.currentIndustry = options.industry || this.detectIndustry();
    this.industryPreset = null;
    this._wordIndex = 0;
    this._shapeIndex = 0;
    
    // Pointer tracking
    this.pointer = { x: 0, y: 0 };
    this.pointerSmooth = { x: 0, y: 0 };
    
    // Rings
    this.lastRingSpawn = 0;
    
    // Animation
    this.isRunning = false;
    this.animationFrame = null;
    this.clock = null;
    this.lastFrameTime = 0;
    
    // Callbacks
    this.onStateChange = null;
    this.onMorphComplete = null;
    this.onExplosionComplete = null;
    this.onVoiceActivity = null;
    
    // Bound event handlers
    this.boundHandlers = {
      voiceAmplitude: function(e) { self.handleVoiceEvent(e); },
      emmaSpeak: function(e) { self.handleEmmaSpeech(e); },
      callStart: function(e) { self.handleCallStart(e); },
      callEnd: function(e) { self.handleCallEnd(e); },
      industryChange: function(e) { self.handleIndustryEvent(e); },
      demoState: function(e) { self.handleDemoStateEvent(e); },
      morphComplete: function(e) { self.handleMorphComplete(e); },
      qualityChange: function(e) { self.handleQualityChange(e); },
      pointerMove: function(e) { self.handlePointerMove(e); },
      click: function(e) { self.handleClick(e); },
      dblclick: function(e) { self.handleDoubleClick(e); },
      resize: self.debounce(function() { self.handleResize(); }, 250)
    };
    
    // Initialize
    this.setupEventListeners();
    
    if (this.options.debug) {
      console.log('[ParticleIntelligence] Initialized with industry:', this.currentIndustry);
    }
  }

  // ============================================
  // INITIALIZATION
  // ============================================

  ParticleIntelligenceSystem.prototype.init = function(canvasSelector) {
    var self = this;
    canvasSelector = canvasSelector || '#live-demo-canvas';
    
    return new Promise(function(resolve, reject) {
      try {
        // Find canvas/container
var element;

if (canvasSelector instanceof HTMLElement) {
  // Already a DOM node
  element = canvasSelector;
} else if (typeof canvasSelector === 'string') {
  element = document.querySelector(canvasSelector);
} else {
  console.error(
    '[ParticleIntelligence] Invalid selector or element passed to init():',
    canvasSelector
  );
  resolve(false);
  return;
}

if (!element) {
  console.error('[ParticleIntelligence] Element not found:', canvasSelector);
  resolve(false);
  return;
}
        // Determine if it's a canvas or container
        if (element.tagName === 'CANVAS') {
          self.canvas = element;
          self.container = element.parentElement;
        } else {
          self.container = element;
          self.canvas = element.querySelector('canvas');
        }
        
        // Check WebGL support
        if (!self.checkWebGLSupport()) {
          console.warn('[ParticleIntelligence] WebGL not supported, using fallback');
          self.initFallbackMode();
          resolve(false);
          return;
        }
        
        // Initialize modules
        self.initModules();
        
        // Bind canvas events
        if (self.container) {
          self.container.addEventListener('mousemove', self.boundHandlers.pointerMove);
          self.container.addEventListener('touchmove', function(e) {
            if (e.touches && e.touches[0]) {
              self.handlePointerMove(e.touches[0]);
            }
          }, { passive: true });
          self.container.addEventListener('click', self.boundHandlers.click);
          self.container.addEventListener('dblclick', self.boundHandlers.dblclick);
        }
        
        // Apply industry preset
        self.applyIndustryPreset(self.currentIndustry);
        
        // Start animation loop
        self.start();
        
        // Transition to greeting
        setTimeout(function() {
          self.setState(STATES.GREETING);
        }, 100);
        
        console.log('[ParticleIntelligence] ✅ System ready | Industry:', self.currentIndustry);
        resolve(true);
        
      } catch (error) {
        console.error('[ParticleIntelligence] Init failed:', error);
        self.initFallbackMode();
        resolve(false);
      }
    });
  };

  ParticleIntelligenceSystem.prototype.initModules = function() {
    // Get morph engine
    if (window.morphEngine) {
      this.modules.morpher = window.morphEngine;
    } else if (window.MorphEngine) {
      this.modules.morpher = new window.MorphEngine({
        particleCount: this.options.particleCount || 1500,
        debug: this.options.debug
      });
    }
    
    // Get quality manager
    if (window.adaptiveQuality) {
      this.modules.quality = window.adaptiveQuality;
    } else if (window.AdaptiveQualitySystem) {
      this.modules.quality = new window.AdaptiveQualitySystem({
        debug: this.options.debug
      });
    }
    
    // Get Emma avatar (if available)
    if (window.emmaAvatar) {
      this.modules.emma = window.emmaAvatar;
    }
    
    // Get text collision (if available)
    if (window.textCollisionManager) {
      this.modules.textCollision = window.textCollisionManager;
    }
    
    if (this.options.debug) {
      console.log('[ParticleIntelligence] Modules:', {
        morpher: !!this.modules.morpher,
        quality: !!this.modules.quality,
        emma: !!this.modules.emma,
        textCollision: !!this.modules.textCollision
      });
    }
  };

  ParticleIntelligenceSystem.prototype.checkWebGLSupport = function() {
    try {
      var canvas = document.createElement('canvas');
      var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      return !!gl;
    } catch (e) {
      return false;
    }
  };

  ParticleIntelligenceSystem.prototype.initFallbackMode = function() {
    console.warn('[ParticleIntelligence] Running in fallback mode (CSS animations)');
    if (this.container) {
      this.container.classList.add('webgl-fallback');
    }
  };

  // ============================================
  // SET PARTICLE SYSTEM REFERENCE
  // ============================================

  ParticleIntelligenceSystem.prototype.setParticleSystem = function(system) {
    this.particleSystem = system;
    this.modules.renderer = system;
    
    // Update morpher particle count if needed
    if (this.modules.morpher && system && system.particleCount) {
      if (this.modules.morpher.particleCount !== system.particleCount) {
        this.modules.morpher.setParticleCount(system.particleCount);
      }
    }
    
    if (this.options.debug) {
      console.log('[ParticleIntelligence] Particle system linked');
    }
  };

  // ============================================
  // EVENT LISTENERS
  // ============================================

  ParticleIntelligenceSystem.prototype.setupEventListeners = function() {
    // Voice events
    window.addEventListener('voiceAmplitude', this.boundHandlers.voiceAmplitude);
    window.addEventListener('sw:voiceAmplitude', this.boundHandlers.voiceAmplitude);
    
    // Emma speech
    window.addEventListener('emmaSpeak', this.boundHandlers.emmaSpeak);
    window.addEventListener('sw:emmaSpeak', this.boundHandlers.emmaSpeak);
    
    // Call events
    window.addEventListener('callStart', this.boundHandlers.callStart);
    window.addEventListener('sw:callStart', this.boundHandlers.callStart);
    window.addEventListener('callEnd', this.boundHandlers.callEnd);
    window.addEventListener('sw:callEnd', this.boundHandlers.callEnd);
    
    // Industry events
    window.addEventListener('sw:industryPresetApplied', this.boundHandlers.industryChange);
    
    // Demo state events
    window.addEventListener('sw:demoStateChange', this.boundHandlers.demoState);
    
    // Morph complete
    window.addEventListener('sw:morphComplete', this.boundHandlers.morphComplete);
    
    // Quality change
    window.addEventListener('sw:qualityChange', this.boundHandlers.qualityChange);
    
    // Resize
    window.addEventListener('resize', this.boundHandlers.resize);
  };

  ParticleIntelligenceSystem.prototype.removeEventListeners = function() {
    window.removeEventListener('voiceAmplitude', this.boundHandlers.voiceAmplitude);
    window.removeEventListener('sw:voiceAmplitude', this.boundHandlers.voiceAmplitude);
    window.removeEventListener('emmaSpeak', this.boundHandlers.emmaSpeak);
    window.removeEventListener('sw:emmaSpeak', this.boundHandlers.emmaSpeak);
    window.removeEventListener('callStart', this.boundHandlers.callStart);
    window.removeEventListener('sw:callStart', this.boundHandlers.callStart);
    window.removeEventListener('callEnd', this.boundHandlers.callEnd);
    window.removeEventListener('sw:callEnd', this.boundHandlers.callEnd);
    window.removeEventListener('sw:industryPresetApplied', this.boundHandlers.industryChange);
    window.removeEventListener('sw:demoStateChange', this.boundHandlers.demoState);
    window.removeEventListener('sw:morphComplete', this.boundHandlers.morphComplete);
    window.removeEventListener('sw:qualityChange', this.boundHandlers.qualityChange);
    window.removeEventListener('resize', this.boundHandlers.resize);
    
    if (this.container) {
      this.container.removeEventListener('mousemove', this.boundHandlers.pointerMove);
      this.container.removeEventListener('click', this.boundHandlers.click);
      this.container.removeEventListener('dblclick', this.boundHandlers.dblclick);
    }
  };

  // ============================================
  // STATE MACHINE
  // ============================================

  ParticleIntelligenceSystem.prototype.setState = function(newState, options) {
    options = options || {};
    
    // Validate state exists
    if (!STATE_CONFIG[newState]) {
      if (this.options.debug) {
        console.warn('[ParticleIntelligence] Invalid state:', newState);
      }
      return false;
    }
    
    // Validate transition (unless forced)
    if (!options.force) {
      var allowedTransitions = TRANSITIONS[this.currentState];
      if (allowedTransitions && allowedTransitions.indexOf(newState) === -1) {
        if (this.options.debug) {
          console.warn('[ParticleIntelligence] Invalid transition:', this.currentState, '→', newState);
        }
        return false;
      }
    }
    
    // Don't transition to same state unless forced
    if (newState === this.currentState && !options.force) {
      return false;
    }
    
    // Store previous state
    this.previousState = this.currentState;
    this.currentState = newState;
    this.stateStartTime = performance.now();
    this.transitionProgress = 0;
    
    var config = STATE_CONFIG[newState];
    
    // Set state end time if duration is defined
    if (config.duration) {
      this.stateEndTime = this.stateStartTime + config.duration;
    } else {
      this.stateEndTime = null;
    }
    
    // Update target parameters
    this.targetParams = this.cloneStateConfig(config);
    
    // Execute state entry actions
    this.onStateEnter(newState, options);
    
    // Notify Emma avatar
    this.updateEmmaState(config.emmaState);
    
    // Dispatch event
    window.dispatchEvent(new CustomEvent('sw:particleStateChange', {
      detail: {
        previousState: this.previousState,
        newState: newState,
        config: config,
        options: options
      }
    }));
    
    // Callback
    if (this.onStateChange) {
      this.onStateChange(newState, this.previousState);
    }
    
    if (this.options.debug) {
      console.log('[ParticleIntelligence] State:', this.previousState, '→', newState);
    }
    
    return true;
  };

  ParticleIntelligenceSystem.prototype.cloneStateConfig = function(config) {
    var clone = {};
    for (var key in config) {
      clone[key] = config[key];
    }
    return clone;
  };

  ParticleIntelligenceSystem.prototype.onStateEnter = function(state, options) {
    var self = this;
    var morpher = this.modules.morpher;
    var renderer = this.particleSystem;
    
    switch (state) {
      case STATES.GREETING:
        if (morpher && renderer) {
          morpher.playGreeting(renderer);
        }
        break;
        
      case STATES.IDLE:
        // Enable auto-morphing
        this.autoMorphEnabled = this.options.autoMorphEnabled;
        break;
        
      case STATES.LISTENING:
        // Keep auto-morph but with reduced frequency
        break;
        
            case STATES.FORMING:
        if (options.shape && morpher && renderer) {
          this.isMorphing = true;
          morpher.morphToShape(renderer, options.shape, { duration: TIMING.morph, fluid: true });
        } else if (options.word && morpher && renderer) {
          this.isMorphing = true;
          morpher.morphToWord(renderer, options.word, { duration: TIMING.morph, fluid: true });
        }
        break;
        
      case STATES.LOCKED:
        this.lockedShape = options.shape || options.word || 'custom';
        
        // Auto-return to idle after hold
        setTimeout(function() {
          if (self.currentState === STATES.LOCKED) {
            self.returnToIdle();
          }
        }, TIMING.formHold);
        break;
        
      case STATES.COALESCING:
        // Particles draw together
        break;
        
      case STATES.FUSED:
        // Solid form achieved
        break;
        
      case STATES.MORPHING:
        // Handled by morph system
        break;
        
      case STATES.EXPLODING:
        var epicenter = options.epicenter || { x: 0, y: 0, z: 0 };
        this.triggerExplosion(epicenter);
        break;
        
        case STATES.REFORMING:
        // If OrbitalFlow exists, it already springs particles back to their anchors.
        // Reforming-to-ellipsoid would fight OrbitalFlow’s lane layout.
        if (!(window.demoOrbitalFlow && typeof window.demoOrbitalFlow.triggerExplosion === 'function')) {
          if (morpher && renderer) {
            morpher.reformToEllipsoid(renderer);
          }
        }
        
        // Transition to idle after reform
        setTimeout(function() {
          if (self.currentState === STATES.REFORMING) {
            self.setState(STATES.IDLE, { force: true });
          }
        }, TIMING.reform);
        break;
    }
  };

  ParticleIntelligenceSystem.prototype.returnToIdle = function() {
    var self = this;
    var morpher = this.modules.morpher;
    var renderer = this.particleSystem;
    
    // Reset morph
    if (morpher && renderer) {
      morpher.resetMorph(renderer, 1000);
    }
    
    setTimeout(function() {
      self.setState(STATES.IDLE, { force: true });
      self.isMorphing = false;
      self.lockedShape = null;
    }, 1000);
  };

  ParticleIntelligenceSystem.prototype.updateEmmaState = function(emmaState) {
    var emma = this.modules.emma || window.emmaAvatar;
    if (!emma) return;
    
    switch (emmaState) {
      case 'speaking':
        if (typeof emma.startSpeaking === 'function') {
          emma.startSpeaking(0.6);
        }
        break;
        
      case 'excited':
      case 'happy':
      case 'powerful':
        if (typeof emma.triggerSpeakBurst === 'function') {
          emma.triggerSpeakBurst();
        }
        break;
        
      case 'idle':
      case 'watching':
      case 'listening':
      case 'focusing':
      case 'transforming':
      case 'recovering':
        if (typeof emma.stopSpeaking === 'function') {
          emma.stopSpeaking();
        }
        break;
    }
  };

  // ============================================
  // EVENT HANDLERS
  // ============================================

  ParticleIntelligenceSystem.prototype.handlePointerMove = function(event) {
    if (!this.container) return;
    
    var rect = this.container.getBoundingClientRect();
    var clientX = event.clientX !== undefined ? event.clientX : (event.touches ? event.touches[0].clientX : 0);
    var clientY = event.clientY !== undefined ? event.clientY : (event.touches ? event.touches[0].clientY : 0);
    
    this.pointer.x = ((clientX - rect.left) / rect.width) * 2 - 1;
    this.pointer.y = -((clientY - rect.top) / rect.height) * 2 + 1;
  };

  ParticleIntelligenceSystem.prototype.handleClick = function(event) {
  // Ignore during certain states
  if ([STATES.EXPLODING, STATES.REFORMING, STATES.COALESCING, STATES.GREETING].indexOf(this.currentState) !== -1) {
    return;
  }
  
// If OrbitalFlow + Live Demo are active, don't also dispatch morphs here
if (window.demoOrbitalFlow) return;

  if (this.isFusionSequenceActive) return;

  // Single click triggers BOTH lanes via OrbitalFlow
  if (this.currentState === STATES.IDLE || this.currentState === STATES.LISTENING) {
    var word = this.getNextWord();
    var icon = this.getIndustryShape();

    // Dispatch both events
    window.dispatchEvent(new CustomEvent('sw:morphWord', {
      detail: { word: word }
    }));

    // Slight delay for visual interest
    var self = this;
    setTimeout(function() {
      window.dispatchEvent(new CustomEvent('sw:morphIcon', {
        detail: { icon: icon }
      }));
    }, 100);
  }
};

  ParticleIntelligenceSystem.prototype.handleDoubleClick = function(event) {
    var epicenter = this.getEpicenterFromEvent(event);
    
    // Double-click triggers explosion
    if (this.currentState === STATES.FUSED || this.currentState === STATES.MORPHING || this.currentState === STATES.LOCKED) {
      this.setState(STATES.EXPLODING, { epicenter: epicenter, force: true });
    } else if ([STATES.IDLE, STATES.LISTENING].indexOf(this.currentState) !== -1) {
      this.triggerQuickScatter(epicenter);
    }
  };

  ParticleIntelligenceSystem.prototype.getEpicenterFromEvent = function(event) {
    if (!this.container) return { x: 0, y: 0, z: 0 };
    
    var rect = this.container.getBoundingClientRect();
    return {
      x: ((event.clientX - rect.left) / rect.width) * 2 - 1,
      y: -((event.clientY - rect.top) / rect.height) * 2 + 1,
      z: 0
    };
  };

  ParticleIntelligenceSystem.prototype.handleVoiceEvent = function(e) {
    var amplitude = (e.detail && typeof e.detail.amplitude === 'number')
      ? e.detail.amplitude
      : 0;
    
    this.targetVoiceAmplitude = amplitude;
    
    // Track peak time
    if (amplitude > this.options.voiceHighThreshold) {
      this.voicePeakTime = performance.now();
    }
    
    // Transition to listening state if amplitude is significant
    if (amplitude > this.options.voiceThreshold && !this.isVoiceActive) {
      this.isVoiceActive = true;
      
      if (this.currentState === STATES.IDLE) {
        this.setState(STATES.LISTENING);
      }
      
      if (this.onVoiceActivity) {
        this.onVoiceActivity(true, amplitude);
      }
    }
    // Return to idle when voice stops
    else if (amplitude <= this.options.voiceThreshold && this.isVoiceActive) {
      this.isVoiceActive = false;
      
      if (this.currentState === STATES.LISTENING) {
        this.setState(STATES.IDLE, { force: true });
      }
      
      if (this.onVoiceActivity) {
        this.onVoiceActivity(false, amplitude);
      }
    }
  };

  ParticleIntelligenceSystem.prototype.handleEmmaSpeech = function(e) {
  var text = (e.detail && e.detail.text) ? e.detail.text.toLowerCase() : '';

  // Trigger side WORD morphs on certain keywords
  var wordTriggers = ['shockwave', 'emma', 'ai', 'hello', 'welcome', 'grow', 'scale', 'roi'];

  for (var i = 0; i < wordTriggers.length; i++) {
    var w = wordTriggers[i];
    if (text.indexOf(w) !== -1 &&
        (this.currentState === STATES.IDLE || this.currentState === STATES.LISTENING)) {

      window.dispatchEvent(new CustomEvent('sw:morphWord', {
        detail: { word: w.toUpperCase() }
      }));
      break;
    }
  }

  // Optional: icon morph for industry words (if you implement detectIndustryFromText)
  if (typeof this.detectIndustryFromText === 'function') {
    var industryIcon = this.detectIndustryFromText(text);
    if (industryIcon) {
      window.dispatchEvent(new CustomEvent('sw:morphIcon', {
        detail: { icon: industryIcon }
      }));
    }
  }
};

  ParticleIntelligenceSystem.prototype.handleCallStart = function(e) {
    if (this.currentState === STATES.IDLE) {
      this.setState(STATES.LISTENING);
    }
    
    // Run fusion sequence for voice calls
    this.runFusionSequence('voice_live');
  };

  ParticleIntelligenceSystem.prototype.handleCallEnd = function(e) {
    if (this.currentState === STATES.LISTENING) {
      this.setState(STATES.IDLE, { force: true });
    }
  };

  ParticleIntelligenceSystem.prototype.handleIndustryEvent = function(e) {
  if (!e.detail) return;
  
  var industry = e.detail.industry;
  var preset = e.detail.preset;
  
  if (industry !== this.currentIndustry) {
    this.currentIndustry = industry;
    this.industryPreset = preset;
    this._wordIndex = 0;
    this._shapeIndex = 0;

    // If OrbitalFlow exists, update its icon set instead of center morph
    if (window.demoOrbitalFlow && typeof window.demoOrbitalFlow.setIndustry === 'function') {
      window.demoOrbitalFlow.setIndustry(industry);

      // Optionally trigger an icon morph on the right to show the new industry
      window.dispatchEvent(new CustomEvent('sw:morphIcon', {
        detail: { icon: INDUSTRY_SHAPES[industry] || industry }
      }));
    } else {
      // Legacy center morph (no OrbitalFlow present)
      if (INDUSTRY_SHAPES[industry]) {
        this.queueMorph({
          shape: INDUSTRY_SHAPES[industry],
          duration: 1800
        });
      }
    }
  }
};

  ParticleIntelligenceSystem.prototype.handleDemoStateEvent = function(e) {
    if (!e.detail) return;
    
    var demoState = e.detail.state;
    
    switch (demoState) {
      case 'voice_connecting':
      case 'voice_live':
        if (!this.isExploding && !this.isMorphing) {
          this.setState(STATES.LISTENING);
        }
        break;
        
      case 'voice_summary':
        this.triggerCelebration();
        break;
        
      case 'booking_complete':
  this.triggerCelebration();

  if (window.demoOrbitalFlow || window.OrbitalFlowSystem) {
    window.dispatchEvent(new CustomEvent('sw:morphIcon', {
      detail: { icon: 'checkmark' }
    }));
  } else {
    this.morphToShape('checkmark');
  }
  break;
        
      case 'idle':
      case 'chat_active':
        if (!this.isVoiceActive && !this.isExploding && !this.isMorphing) {
          this.setState(STATES.IDLE, { force: true });
        }
        break;
    }
  };

  ParticleIntelligenceSystem.prototype.handleMorphComplete = function(e) {
    this.isMorphing = false;
    
    if (this.currentState === STATES.FORMING) {
      this.setState(STATES.LOCKED, { force: true });
    } else if (this.currentState === STATES.MORPHING) {
      this.setState(STATES.FUSED, { force: true });
    }
    
    if (this.onMorphComplete) {
      this.onMorphComplete(e.detail ? e.detail.shape : null);
    }
  };

  ParticleIntelligenceSystem.prototype.handleQualityChange = function(e) {
    if (!e.detail) return;
    
    var settings = e.detail.settings;
    
    // Adjust animation intensity based on quality
    if (settings.particleMultiplier < 0.5) {
      this.options.autoMorphInterval = 18000; // Slower on low-end
    } else {
      this.options.autoMorphInterval = CONFIG.autoMorphInterval;
    }
  };

  ParticleIntelligenceSystem.prototype.handleResize = function() {
    // Notify subsystems
    if (this.particleSystem && typeof this.particleSystem.onResize === 'function') {
      this.particleSystem.onResize();
    }
    
    if (this.modules.textCollision) {
      this.modules.textCollision.detectTextElements();
    }
  };

  // ============================================
  // EXPLOSION SYSTEM
  // ============================================

  ParticleIntelligenceSystem.prototype.triggerExplosion = function(epicenter) {
    var self = this;
    var morpher = this.modules.morpher;
    var renderer = this.particleSystem;
    
    if (this.options.debug) {
      console.log('[ParticleIntelligence] 💥 EXPLOSION at', epicenter);
    }
    
    this.isExploding = true;
    this.explosionProgress = 0;
    this.explosionOrigin = epicenter;
    
    // Create explosion rings
    this.spawnExplosionRings(epicenter, this.options.explosionRingCount);
    
        // Apply explosion force via OrbitalFlow if available (detach + return)
    if (window.demoOrbitalFlow && typeof window.demoOrbitalFlow.triggerExplosion === 'function') {
      window.demoOrbitalFlow.triggerExplosion(epicenter, { lane: 'both' });
    } else if (morpher && renderer) {
      // Legacy fallback
      morpher.applyExplosionForce(renderer, epicenter, 200);
    }
    
    // Schedule state transitions
    setTimeout(function() {
      if (self.currentState === STATES.EXPLODING) {
        self.isExploding = false;
        self.setState(STATES.REFORMING, { force: true });
      }
    }, TIMING.explosion);
    
    setTimeout(function() {
      if (self.currentState === STATES.REFORMING) {
        self.setState(STATES.IDLE, { force: true });
      }
    }, TIMING.explosion + TIMING.reform);
    
    // Dispatch event
    window.dispatchEvent(new CustomEvent('sw:explosionStarted', {
      detail: { origin: epicenter }
    }));
  };

  ParticleIntelligenceSystem.prototype.triggerQuickScatter = function(epicenter) {
    var morpher = this.modules.morpher;
    var renderer = this.particleSystem;
    
        // Smaller explosion force
    if (window.demoOrbitalFlow && typeof window.demoOrbitalFlow.triggerExplosion === 'function') {
      window.demoOrbitalFlow.triggerExplosion(epicenter, { lane: 'both', strength: 10.0, randomness: 0.65 });
    } else if (morpher && renderer) {
      morpher.applyExplosionForce(renderer, epicenter, 80);
    }
    
    // Fewer rings
    this.spawnExplosionRings(epicenter, 3);
    
    // Quick reform
    var self = this;
    setTimeout(function() {
      if (morpher && renderer) {
        morpher.gentleReform(renderer);
      }
    }, 400);
  };

  ParticleIntelligenceSystem.prototype.spawnExplosionRings = function(epicenter, count) {
    window.dispatchEvent(new CustomEvent('sw:createRings', {
      detail: {
        epicenter: epicenter,
        count: count
      }
    }));
  };

  // ============================================
  // FUSION SEQUENCE
  // ============================================

      ParticleIntelligenceSystem.prototype.runFusionSequence = function(triggerSource) {
    var self = this;
    triggerSource = triggerSource || 'manual';
    
    if (this.currentState === STATES.EXPLODING || this.isFusionSequenceActive) {
      return Promise.resolve();
    }
    
    this.isFusionSequenceActive = true;
    var morpher = this.modules.morpher;
    var renderer = this.particleSystem;
    
    console.log('[ParticleIntelligence] 🔥 Starting fusion sequence (' + triggerSource + ')');
    
    return this.delay(100)
      .then(function() {
        // Stage 1: Coalesce into fusion core
        self.fusionStage = 1;
        self.setState(STATES.COALESCING, { force: true });
        
        if (morpher && renderer) {
          morpher.morphToShape(renderer, 'fusion_core', { duration: 900, fluid: true });
        }
        return self.delay(1100);
      })
      .then(function() {
        // Stage 2: Transform to blob
        self.fusionStage = 2;
        self.setState(STATES.FUSED, { force: true });
        
        if (morpher && renderer) {
          morpher.morphToShape(renderer, 'blob', { duration: 800, fluid: true });
        }
        return self.delay(1200);
      })
      .then(function() {
        // Stage 3: Industry shape
        self.fusionStage = 3;
        self.setState(STATES.MORPHING, { force: true });
        
        var industryShape = self.getIndustryShape();
        if (morpher && renderer && industryShape) {
          morpher.morphToShape(renderer, industryShape, { duration: 1200, fluid: true });
        }
        return self.delay(1600);
      })
      .then(function() {
        // Stage 4: Hold
        self.fusionStage = 4;
        self.setState(STATES.LOCKED, { force: true });
        return self.delay(2500);
      })
      .then(function() {
        // Stage 5: Release
        self.fusionStage = 5;
        
        if (morpher && renderer) {
          morpher.resetMorph(renderer, 1000);
        }
        return self.delay(1200);
      })
      .then(function() {
        self.fusionStage = 0;
        self.isFusionSequenceActive = false;
        self.setState(STATES.IDLE, { force: true });
        
        window.dispatchEvent(new CustomEvent('sw:fusionSequenceComplete', {
          detail: { source: triggerSource, industry: self.currentIndustry }
        }));
        
        console.log('[ParticleIntelligence] Fusion sequence complete');
      })
      .catch(function(error) {
        console.error('[ParticleIntelligence] Fusion sequence error:', error);
        self.fusionStage = 0;
        self.isFusionSequenceActive = false;
        self.setState(STATES.IDLE, { force: true });
      });
  };

  // ============================================
  // CELEBRATION
  // ============================================

  ParticleIntelligenceSystem.prototype.triggerCelebration = function() {
    var self = this;
    
    // Spawn multiple rings in burst pattern
    for (var i = 0; i < this.options.celebrationRingBurst; i++) {
      (function(delay) {
        setTimeout(function() {
          var x = (Math.random() - 0.5) * 0.6;
          var y = (Math.random() - 0.5) * 0.4;
          
          self.spawnExplosionRings({ x: x, y: y, z: 0 }, 1);
        }, delay);
      })(i * 200);
    }
    
    // Update Emma
    this.updateEmmaState('happy');
    
    // Dispatch event
    window.dispatchEvent(new CustomEvent('sw:celebration'));
  };

  // ============================================
  // MORPHING API
  // ============================================

      ParticleIntelligenceSystem.prototype.morphToShape = function(shapeName, duration) {
    duration = duration || TIMING.morph;
    
    if (!this.canMorph()) {
      this.queueMorph({ shape: shapeName, duration: duration });
      return;
    }
    
    this.setState(STATES.FORMING, { shape: shapeName });
    this.isMorphing = true;
    
    var morpher = this.modules.morpher;
    var renderer = this.particleSystem;
    
    if (morpher && renderer) {
      // Pass options object to match MorphEngine signature
      morpher.morphToShape(renderer, shapeName, { duration: duration, fluid: true });
    }
    
    var self = this;
    setTimeout(function() {
      if (self.currentState === STATES.FORMING) {
        self.setState(STATES.LOCKED, { shape: shapeName, force: true });
      }
    }, duration);
  };

    ParticleIntelligenceSystem.prototype.morphToWord = function(word, duration) {
    duration = duration || TIMING.morph;
    word = word.toUpperCase();
    
    if (!this.canMorph()) {
      this.queueMorph({ word: word, duration: duration });
      return;
    }
    
    this.setState(STATES.FORMING, { word: word });
    this.isMorphing = true;
    
    var morpher = this.modules.morpher;
    var renderer = this.particleSystem;
    
    if (morpher && renderer) {
      // Pass options object to match MorphEngine signature
      morpher.morphToWord(renderer, word, { duration: duration, fluid: true });
    }
    
    var self = this;
    setTimeout(function() {
      if (self.currentState === STATES.FORMING) {
        self.setState(STATES.LOCKED, { word: word, force: true });
      }
    }, duration);
  };

  ParticleIntelligenceSystem.prototype.canMorph = function() {
    return this.targetParams.allowMorph &&
           !this.isMorphing &&
           !this.isExploding &&
           !this.isFusionSequenceActive &&
           [STATES.IDLE, STATES.LISTENING].indexOf(this.currentState) !== -1;
  };

  ParticleIntelligenceSystem.prototype.queueMorph = function(morphData) {
    if (this.morphQueue.length < this.options.maxMorphQueueLength) {
      this.morphQueue.push(morphData);
    }
  };

  ParticleIntelligenceSystem.prototype.processQueuedMorph = function() {
    if (this.morphQueue.length === 0 || !this.canMorph()) {
      return;
    }
    
    var next = this.morphQueue.shift();
    
    if (next.shape) {
      this.morphToShape(next.shape, next.duration);
    } else if (next.word) {
      this.morphToWord(next.word, next.duration);
    }
  };

  // ============================================
  // AUTO-MORPH
  // ============================================

  ParticleIntelligenceSystem.prototype.checkAutoMorph = function(now) {
  // If OrbitalFlow is active, do NOT auto-morph in the center
  if (window.demoOrbitalFlow || window.OrbitalFlowSystem) {
    return;
  }

  if (!this.autoMorphEnabled) return;
  if (now - this.lastMorphTime < this.options.autoMorphInterval) return;
  if (!this.canMorph()) return;
  
  // Alternate between words and shapes (legacy center behavior)
  var useWord = Math.random() > 0.4;
  
  if (useWord) {
    var word = this.getNextWord();
    this.morphToWord(word, 1500);
  } else {
    var shape = this.getNextShape();
    this.morphToShape(shape, 1800);
  }
  
  this.lastMorphTime = now;
};

  // ============================================
  // INDUSTRY HELPERS
  // ============================================

  ParticleIntelligenceSystem.prototype.detectIndustry = function() {
    // URL parameter
    try {
      var urlParams = new URLSearchParams(window.location.search);
      var urlIndustry = urlParams.get('industry');
      if (urlIndustry) {
        return this.normalizeIndustry(urlIndustry);
      }
    } catch (e) {}
    
    // Data attribute
    try {
      var demoSection = document.querySelector('[data-sw-industry], [data-industry]');
      if (demoSection) {
        var dataIndustry = demoSection.getAttribute('data-sw-industry') ||
                          demoSection.getAttribute('data-industry');
        if (dataIndustry) {
          return this.normalizeIndustry(dataIndustry);
        }
      }
    } catch (e) {}
    
    // Global demo state
    try {
      if (window.ShockwaveLiveDemo && window.ShockwaveLiveDemo.currentIndustry) {
        return this.normalizeIndustry(window.ShockwaveLiveDemo.currentIndustry);
      }
    } catch (e) {}
    
    return 'default';
  };

  ParticleIntelligenceSystem.prototype.normalizeIndustry = function(industry) {
    if (!industry) return 'default';
    var key = String(industry).toLowerCase().trim();
    
    var aliases = {
      'law': 'legal',
      'med spa': 'medspa',
      'med-spa': 'medspa',
      'pest control': 'pest',
      'pestcontrol': 'pest'
    };
    
    return aliases[key] || key;
  };

  ParticleIntelligenceSystem.prototype.applyIndustryPreset = function(industry) {
    industry = this.normalizeIndustry(industry);
    this.currentIndustry = industry;
    
    // Get preset from industry-presets.js if available
    if (window.INDUSTRY_PRESETS && window.INDUSTRY_PRESETS[industry]) {
      this.industryPreset = window.INDUSTRY_PRESETS[industry];
    }
    
    // Apply to particle system if connected
    if (this.particleSystem && typeof this.particleSystem.applyIndustryPreset === 'function') {
      this.particleSystem.applyIndustryPreset(industry);
    }
    
    // Apply to Emma
    if (this.modules.emma && this.industryPreset && typeof this.modules.emma.applyPreset === 'function') {
      this.modules.emma.applyPreset(this.industryPreset);
    }
    
    if (this.options.debug) {
      console.log('[ParticleIntelligence] Applied industry preset:', industry);
    }
  };

  ParticleIntelligenceSystem.prototype.getIndustryShape = function() {
    var industry = this.currentIndustry || 'default';
    return INDUSTRY_SHAPES[industry] || INDUSTRY_SHAPES.default;
  };

  ParticleIntelligenceSystem.prototype.getNextWord = function() {
    var industry = this.currentIndustry || 'default';
    var words = INDUSTRY_WORDS[industry] || INDUSTRY_WORDS.default;
    
    var word = words[this._wordIndex % words.length];
    this._wordIndex++;
    
    return word;
  };

  ParticleIntelligenceSystem.prototype.getNextShape = function() {
    var industry = this.currentIndustry || 'default';
    var shapes = INDUSTRY_ALTERNATE_SHAPES[industry] || INDUSTRY_ALTERNATE_SHAPES.default;
    
    var shape = shapes[this._shapeIndex % shapes.length];
    this._shapeIndex++;
    
    return shape;
  };

  // ============================================
  // ANIMATION LOOP
  // ============================================

  ParticleIntelligenceSystem.prototype.start = function() {
    if (this.isRunning) return;
    
    this.isRunning = true;
    this.lastFrameTime = performance.now();
    
    var self = this;
    var animate = function() {
      if (!self.isRunning) return;
      
      var now = performance.now();
      var deltaTime = Math.min(now - self.lastFrameTime, 50); // Cap at 50ms
      self.lastFrameTime = now;
      
      self.update(deltaTime, now);
      
      self.animationFrame = requestAnimationFrame(animate);
    };
    
    this.animationFrame = requestAnimationFrame(animate);
    
    if (this.options.debug) {
      console.log('[ParticleIntelligence] Animation started');
    }
  };

  ParticleIntelligenceSystem.prototype.stop = function() {
    this.isRunning = false;
    
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = null;
    }
    
    if (this.options.debug) {
      console.log('[ParticleIntelligence] Animation stopped');
    }
  };

  ParticleIntelligenceSystem.prototype.update = function(deltaTime, now) {
    // Check for state timeout
    if (this.stateEndTime && now >= this.stateEndTime) {
      this.handleStateTimeout();
    }
    
    // Smooth voice amplitude
    this.voiceAmplitude += (this.targetVoiceAmplitude - this.voiceAmplitude) * this.options.voiceSmoothing;
    
    // Smooth pointer
    this.pointerSmooth.x += (this.pointer.x - this.pointerSmooth.x) * 0.08;
    this.pointerSmooth.y += (this.pointer.y - this.pointerSmooth.y) * 0.08;
    
    // Blend parameters
    this.blendParameters(deltaTime);
    
    // Apply parameters to particle system
    this.applyParameters();
    
    // Process morph queue
    this.processQueuedMorph();
    
    // Auto-morph check
    this.checkAutoMorph(now);
    
    // Auto ring spawn
    this.checkAutoRingSpawn(now);
    
    // Update quality system
    if (this.modules.quality && typeof this.modules.quality.measureFrame === 'function') {
      this.modules.quality.measureFrame();
    }
  };

  ParticleIntelligenceSystem.prototype.blendParameters = function(deltaTime) {
    var speed = this.options.blendSpeed;
    
    // Use faster blend for certain transitions
    if (this.currentState === STATES.EXPLODING || this.currentState === STATES.REFORMING) {
      speed = this.options.fastBlendSpeed;
    }
    
    // Blend each parameter
    var params = ['turbulence', 'motionSpeed', 'breathingAmount', 'orbitSpeed', 
                  'randomness', 'depthOscillation', 'waveFrequency'];
    
    for (var i = 0; i < params.length; i++) {
      var key = params[i];
      if (this.blendedParams[key] !== undefined && this.targetParams[key] !== undefined) {
        this.blendedParams[key] += (this.targetParams[key] - this.blendedParams[key]) * speed;
      }
    }
  };

 ParticleIntelligenceSystem.prototype.applyParameters = function() {
  var renderer = this.particleSystem;
  if (!renderer) return;
  
  var uniforms = renderer.particleMaterial ? renderer.particleMaterial.uniforms : 
                 (renderer.particles && renderer.particles.material ? renderer.particles.material.uniforms : null);
  
  if (!uniforms) return;

  // ===== DEV OVERRIDE: Kill shader drift globally =====
// Toggle in console: window.SW_SHADER_DRIFT_OFF = true/false
if (window.SW_SHADER_DRIFT_OFF === true) {
  if (uniforms.uRandom)          uniforms.uRandom.value = 0;
  if (uniforms.uTurbulence)      uniforms.uTurbulence.value = 0;
  if (uniforms.uWaveFrequency)   uniforms.uWaveFrequency.value = 0;
  if (uniforms.uBreathingAmount) uniforms.uBreathingAmount.value = 0;
  if (uniforms.uMotionSpeed)     uniforms.uMotionSpeed.value = 0;
  if (uniforms.uPointerInfluence) uniforms.uPointerInfluence.value = 0;

  // Keep voice/pointer from reintroducing motion artifacts
  if (uniforms.uVoiceAmplitude) uniforms.uVoiceAmplitude.value = 0;
  if (uniforms.uPointer) uniforms.uPointer.value.set(0, 0);

  return;
}
  
    // Optional: freeze uniforms during morph/lock states (OFF unless enabled)
  var isFormingShape = (
    this.currentState === 'FORMING' || 
    this.currentState === 'LOCKED' || 
    this.currentState === 'MORPHING' ||
    this.currentState === 'FUSED' ||
    this.isMorphing
  );

  var freezeEnabled =
    (this.options && this.options.freezeUniformsDuringMorph === true) ||
    (window.SW_FREEZE_UNIFORMS_DURING_MORPH === true);

  if (isFormingShape && freezeEnabled) {
    // FROZEN VALUES (only when enabled)
    if (uniforms.uRandom)           uniforms.uRandom.value = 0.005;
    if (uniforms.uTurbulence)       uniforms.uTurbulence.value = 0.001;
    if (uniforms.uWaveFrequency)    uniforms.uWaveFrequency.value = 0.01;
    if (uniforms.uBreathingAmount)  uniforms.uBreathingAmount.value = 0.001;
    if (uniforms.uMotionSpeed)      uniforms.uMotionSpeed.value = 0.005;
    if (uniforms.uDepth)            uniforms.uDepth.value = 0.05;

    // Keep these minimal to avoid reintroducing jitter
    if (uniforms.uVoiceAmplitude)   uniforms.uVoiceAmplitude.value = this.voiceAmplitude * 0.3;
    if (uniforms.uPointer)          uniforms.uPointer.value.set(0, 0);

    return;
  }
    
  // Normal parameter application (non-morph states)
  if (uniforms.uTurbulence) {
    uniforms.uTurbulence.value = this.blendedParams.turbulence;
  }
  if (uniforms.uMotionSpeed) {
    uniforms.uMotionSpeed.value = this.blendedParams.motionSpeed;
  }
  if (uniforms.uRandom) {
    uniforms.uRandom.value = this.blendedParams.randomness;
  }
  if (uniforms.uDepth) {
    uniforms.uDepth.value = this.blendedParams.depthOscillation;
  }
  if (uniforms.uWaveFrequency) {
    uniforms.uWaveFrequency.value = this.blendedParams.waveFrequency;
  }
  if (uniforms.uVoiceAmplitude) {
    uniforms.uVoiceAmplitude.value = this.voiceAmplitude;
  }
  if (uniforms.uPointer) {
    uniforms.uPointer.value.set(this.pointerSmooth.x, this.pointerSmooth.y);
  }
  
  // Apply via methods if available
  if (typeof renderer.setVoiceAmplitude === 'function') {
    renderer.setVoiceAmplitude(this.voiceAmplitude);
  }
};


  ParticleIntelligenceSystem.prototype.handleStateTimeout = function() {
    // Return to appropriate state
    if (this.isVoiceActive) {
      this.setState(STATES.LISTENING, { force: true });
    } else {
      this.returnToIdle();
    }
  };

  ParticleIntelligenceSystem.prototype.checkAutoRingSpawn = function(now) {
    if (this.currentState !== STATES.IDLE && this.currentState !== STATES.LISTENING) {
      return;
    }
    
    if (now - this.lastRingSpawn > this.options.ringSpawnInterval) {
      this.lastRingSpawn = now;
      
      // Spawn at semi-random position near center
      var x = (Math.random() - 0.5) * 0.3;
      var y = (Math.random() - 0.5) * 0.2;
      
      this.spawnExplosionRings({ x: x, y: y, z: 0 }, this.options.idleRingCount);
    }
  };

  // ============================================
  // PUBLIC API
  // ============================================

  ParticleIntelligenceSystem.prototype.getState = function() {
    return this.currentState;
  };

  ParticleIntelligenceSystem.prototype.getCurrentState = function() {
    return this.currentState;
  };

  ParticleIntelligenceSystem.prototype.getVoiceAmplitude = function() {
    return this.voiceAmplitude;
  };

  ParticleIntelligenceSystem.prototype.getIndustry = function() {
    return this.currentIndustry;
  };

  ParticleIntelligenceSystem.prototype.setIndustry = function(industry) {
    this.applyIndustryPreset(industry);
  };

  ParticleIntelligenceSystem.prototype.triggerGreeting = function() {
    if (this.currentState === STATES.IDLE || this.currentState === STATES.INITIALIZING) {
      this.currentState = STATES.INITIALIZING;
      this.setState(STATES.GREETING);
    }
  };

  ParticleIntelligenceSystem.prototype.triggerExplosionManual = function(x, y) {
    x = x || 0;
    y = y || 0;
    this.triggerQuickScatter({ x: x, y: y, z: 0 });
  };

  ParticleIntelligenceSystem.prototype.setAutoMorph = function(enabled) {
    this.autoMorphEnabled = enabled;
  };

  ParticleIntelligenceSystem.prototype.enableDebug = function() {
    this.options.debug = true;
    console.log('[ParticleIntelligence] Debug mode enabled');
  };

  ParticleIntelligenceSystem.prototype.getStats = function() {
    return {
      state: this.currentState,
      previousState: this.previousState,
      isVoiceActive: this.isVoiceActive,
      voiceAmplitude: this.voiceAmplitude.toFixed(3),
      isMorphing: this.isMorphing,
      isExploding: this.isExploding,
      isFusionActive: this.isFusionSequenceActive,
      fusionStage: this.fusionStage,
      industry: this.currentIndustry,
      morphQueueLength: this.morphQueue.length,
      fps: this.modules.quality ? this.modules.quality.averageFPS : 0,
      qualityLevel: this.modules.quality ? this.modules.quality.currentTier : 'unknown',
      autoMorphEnabled: this.autoMorphEnabled,
      modules: {
        morpher: !!this.modules.morpher,
        quality: !!this.modules.quality,
        emma: !!this.modules.emma,
        textCollision: !!this.modules.textCollision,
        renderer: !!this.particleSystem
      }
    };
  };

  ParticleIntelligenceSystem.prototype.getDebugInfo = function() {
    return this.getStats();
  };

  // ============================================
  // UTILITIES
  // ============================================

  ParticleIntelligenceSystem.prototype.delay = function(ms) {
    return new Promise(function(resolve) {
      setTimeout(resolve, ms);
    });
  };

  ParticleIntelligenceSystem.prototype.debounce = function(func, wait) {
    var timeout;
    return function() {
      var context = this;
      var args = arguments;
      clearTimeout(timeout);
      timeout = setTimeout(function() {
        func.apply(context, args);
      }, wait);
    };
  };

  // ============================================
  // CLEANUP
  // ============================================

  ParticleIntelligenceSystem.prototype.destroy = function() {
    this.stop();
    this.removeEventListeners();
    
    this.morphQueue = [];
    this.particleSystem = null;
    this.modules = {
      renderer: null,
      morpher: null,
      quality: null,
      emma: null,
      textCollision: null,
      ringSystem: null
    };
    
    this.onStateChange = null;
    this.onMorphComplete = null;
    this.onExplosionComplete = null;
    this.onVoiceActivity = null;
    
    if (this.options.debug) {
      console.log('[ParticleIntelligence] Destroyed');
    }
  };

  // ============================================
  // EXPORT
  // ============================================

  // Primary export
  window.ParticleIntelligenceSystem = ParticleIntelligenceSystem;
  
  // Legacy aliases for compatibility
  window.ParticleIntelligence = ParticleIntelligenceSystem;
  
  // State exports
  window.PARTICLE_STATES = STATES;
  window.PARTICLE_STATE_CONFIG = STATE_CONFIG;
  window.PARTICLE_TRANSITIONS = TRANSITIONS;
  window.PARTICLE_TIMING = TIMING;
  
  // Dispatch ready event
  window.dispatchEvent(new CustomEvent('sw:particleIntelligenceReady'));
  
  console.log('[ParticleIntelligence] Module loaded with', Object.keys(STATES).length, 'states');

  // Initialize on dependencies ready
  waitForDependencies(function() {
    if (CONFIG.debug) {
      console.log('[ParticleIntelligence] Dependencies ready');
    }
  });

})();

// ─── text-collision.js (Text collision avoidance) ───
/**
 * text-collision.js
 * ShockwaveHQ — Text Collision Avoidance System
 * 
 * Detects text elements in the Live Demo section and creates
 * repulsion zones that particles flow around (never overlap).
 * 
 * Features:
 * - Automatic text element detection
 * - NDC coordinate conversion for GPU
 * - Inflated radii for stronger avoidance
 * - No debug spam (controlled via flag)
 * - MutationObserver for dynamic content
 * 
 * Dependencies: THREE.js
 * 
 * Usage:
 *   textCollisionManager.init(canvas, camera);
 *   const uniforms = textCollisionManager.getShaderUniforms();
 */

(function() {
  'use strict';

  // ============================================
  // DEBUG FLAG - Set to true only when needed
  // ============================================
  
  const SW_DEBUG_TEXT_COLLISION = window.SW_DEBUG_TEXT_COLLISION === true;

  // ============================================
  // CONFIGURATION
  // ============================================

  const CONFIG = {
    maxZones: 32,
    defaultBuffer: 45,
    defaultStrength: 1.8,
    radiusInflation: 1.15,
    resizeDebounce: 200,
    scrollThrottle: 80,
    
    textSelectors: [
      'h1', 'h2', 'h3', 'h4',
      'p', 'label',
      '.live-demo-title',
      '.live-demo-subtitle',
      '.live-demo-subsubtitle',
      '.eyebrow',
      '.sw-demo-chat-name',
      '.sw-demo-chat-status',
      '.sw-demo-chat-bubble',
      '.sw-demo-chip',
      '.sw-demo-console-title',
      '.sw-demo-console-scenario',
      '.sw-step',
      '.sw-console-status-label',
      '.sw-console-decision-text',
      '.sw-demo-modal-title',
      '.sw-demo-modal-sub',
      '.sw-live-proof-bar',
      '.sw-live-proof-context',
      '.sw-live-proof-footnote',
      '.sw-demo-chat-send',
      '.sw-demo-chat-cta-btn',
      '.sw-demo-console-primary',
      '.sw-demo-console-secondary',
      '.sw-demo-modal-submit',
      '.live-demo-trust-strip',
      '.live-demo-status-text',
      '.live-demo-status-metric',
      '.sw-demo-why-now',
      '.live-demo-roi-chip',
      '.sw-demo-complete-title',
      '.sw-demo-complete-sub',
      '.sw-complete-stat-label',
      '.sw-complete-stat-value'
    ],
    
    containerSelectors: [
      '.live-demo',
      '#live-ai-demo',
      '[data-live-demo-root]',
      '.live-demo-inner'
    ]
  };

  // ============================================
  // WAIT FOR THREE.JS
  // ============================================

  function waitForThree(callback, maxAttempts = 50) {
    let attempts = 0;
    const check = () => {
      attempts++;
      if (typeof THREE !== 'undefined') {
        callback();
      } else if (attempts < maxAttempts) {
        setTimeout(check, 100);
      } else {
        console.error('[text-collision] THREE.js not found');
      }
    };
    check();
  }

  // ============================================
  // TEXT COLLISION MANAGER CLASS
  // ============================================

  class TextCollisionManager {
    constructor(options = {}) {
      this.maxZones = options.maxZones || CONFIG.maxZones;
      this.buffer = options.buffer || CONFIG.defaultBuffer;
      this.strength = options.strength || CONFIG.defaultStrength;
      this.radiusInflation = options.radiusInflation || CONFIG.radiusInflation;
      
      this.textZones = [];
      this.canvas = null;
      this.camera = null;
      this.containerEl = null;
      this.needsUpdate = true;
      this.isInitialized = false;
      
      // Cached uniform arrays
      this.uniformCenters = new Float32Array(this.maxZones * 2);
      this.uniformRadii = new Float32Array(this.maxZones);
      
      // Timers
      this.resizeTimeout = null;
      this.scrollTimeout = null;
      this.lastScrollTime = 0;
      
      // Observer
      this.mutationObserver = null;
      
      if (SW_DEBUG_TEXT_COLLISION) {
        console.log('[text-collision] Manager created');
      }
    }

    /**
     * Initialize with WebGL canvas
     */
    init(canvas, camera = null) {
      if (!canvas) {
        console.error('[text-collision] Canvas element required');
        return false;
      }
      
      this.canvas = canvas;
      this.camera = camera;
      this.containerEl = this.findContainer();
      
      if (!this.containerEl) {
        this.containerEl = document.body;
      }
      
      this.detectTextElements();
      this.setupEventListeners();
      
      this.isInitialized = true;
      
      if (SW_DEBUG_TEXT_COLLISION) {
        console.log('[text-collision] Initialized');
      }
      
      return true;
    }

    /**
     * Find the demo container element
     */
    findContainer() {
      for (const selector of CONFIG.containerSelectors) {
        const el = document.querySelector(selector);
        if (el) return el;
      }
      return null;
    }

    /**
     * Setup event listeners
     */
    setupEventListeners() {
      // Resize handler
      const handleResize = () => {
        clearTimeout(this.resizeTimeout);
        this.resizeTimeout = setTimeout(() => {
          this.detectTextElements();
        }, CONFIG.resizeDebounce);
      };
      
      window.addEventListener('resize', handleResize);
      
      // Scroll handler
      const handleScroll = () => {
        const now = Date.now();
        if (now - this.lastScrollTime > CONFIG.scrollThrottle) {
          this.lastScrollTime = now;
          this.detectTextElements();
        }
      };
      
      window.addEventListener('scroll', handleScroll, { passive: true });
      
             // Mutation observer with rate limiting
      if (typeof MutationObserver !== 'undefined' && this.containerEl) {
        // Rate limiting state
        let mutationCount = 0;
        let mutationResetTimer = null;
        const MAX_MUTATIONS_PER_SECOND = 10;
        const MUTATION_COOLDOWN_MS = 150;
        let lastMutationProcess = 0;
        
        this.mutationObserver = new MutationObserver((mutations) => {
          // Count mutations for rate limiting
          mutationCount++;
          
          // Reset counter every second
          if (!mutationResetTimer) {
            mutationResetTimer = setTimeout(() => {
              mutationCount = 0;
              mutationResetTimer = null;
            }, 1000);
          }
          
          // Skip if too many mutations (likely animation spam)
          if (mutationCount > MAX_MUTATIONS_PER_SECOND) {
            if (SW_DEBUG_TEXT_COLLISION) {
              console.log('[text-collision] Rate limited - too many mutations');
            }
            return;
          }
          
          // Check for relevant changes
          const hasRelevantChanges = mutations.some(m => {
            // Skip text content changes in chat bubbles (too frequent)
            if (m.type === 'characterData') {
              const parent = m.target.parentElement;
              if (parent && parent.classList && parent.classList.contains('sw-demo-chat-bubble')) {
                return false;
              }
            }
            
            return m.type === 'childList' || 
              m.type === 'characterData' ||
              (m.type === 'attributes' && (m.attributeName === 'class' || m.attributeName === 'hidden'));
          });
          
          if (hasRelevantChanges) {
            // Enforce minimum cooldown between detection runs
            const now = Date.now();
            const timeSinceLastProcess = now - lastMutationProcess;
            const delay = Math.max(MUTATION_COOLDOWN_MS - timeSinceLastProcess, 0);
            
            clearTimeout(this.resizeTimeout);
            this.resizeTimeout = setTimeout(() => {
              lastMutationProcess = Date.now();
              this.detectTextElements();
            }, delay + 80);
          }
        });
        
        this.mutationObserver.observe(this.containerEl, {
          childList: true,
          subtree: true,
          characterData: true,
          attributes: true,
          attributeFilter: ['class', 'hidden', 'style']
        });
      }
      
      // Demo state changes
      window.addEventListener('sw:demoStateChange', () => {
        setTimeout(() => this.detectTextElements(), 100);
      });
      
      // Chat messages
      window.addEventListener('sw:chatMessage', () => {
        setTimeout(() => this.detectTextElements(), 50);
      });
    }

    /**
     * Detect all text elements and convert to collision zones
     */
    detectTextElements() {
      this.textZones = [];
      
      if (!this.canvas || !this.containerEl) {
        return;
      }
      
      const canvasRect = this.canvas.getBoundingClientRect();
      
      if (canvasRect.width === 0 || canvasRect.height === 0) {
        return;
      }
      
      const selectorString = CONFIG.textSelectors.join(', ');
      
      let textElements;
      try {
        textElements = this.containerEl.querySelectorAll(selectorString);
      } catch (e) {
        textElements = [];
      }
      
      textElements.forEach(el => {
        const zone = this.elementToZone(el, canvasRect);
        if (zone) {
          this.textZones.push(zone);
        }
      });
      
      // Cap at maximum
      if (this.textZones.length > this.maxZones) {
        this.textZones.sort((a, b) => b.radius - a.radius);
        this.textZones = this.textZones.slice(0, this.maxZones);
      }
      
      this.updateUniformArrays();
      this.needsUpdate = true;
      
      // Dispatch event
      window.dispatchEvent(new CustomEvent('sw:textZonesUpdated', {
        detail: { count: this.textZones.length }
      }));
      
      if (SW_DEBUG_TEXT_COLLISION && this.textZones.length > 0) {
        console.log(`[text-collision] Detected ${this.textZones.length} zones`);
      }
    }

    /**
     * Convert DOM element to collision zone
     */
    elementToZone(el, canvasRect) {
      const rect = el.getBoundingClientRect();
      
      // Skip invalid elements
      if (rect.width === 0 || rect.height === 0) return null;
      
      // Skip elements outside canvas
      if (rect.right < canvasRect.left ||
          rect.left > canvasRect.right ||
          rect.bottom < canvasRect.top ||
          rect.top > canvasRect.bottom) {
        return null;
      }
      
      // Skip hidden elements
      try {
        const style = window.getComputedStyle(el);
        if (style.display === 'none' || 
            style.visibility === 'hidden' ||
            style.opacity === '0' ||
            el.hidden) {
          return null;
        }
      } catch (e) {
        return null;
      }
      
      // Calculate center in canvas-relative coordinates
      const centerX = rect.left + rect.width / 2 - canvasRect.left;
      const centerY = rect.top + rect.height / 2 - canvasRect.top;
      
      // Convert to NDC (-1 to 1)
      const ndcX = (centerX / canvasRect.width) * 2 - 1;
      const ndcY = -((centerY / canvasRect.height) * 2 - 1);
      
      // Calculate radius with buffer and inflation
      const radiusX = ((rect.width / 2 + this.buffer) / canvasRect.width) * 2;
      const radiusY = ((rect.height / 2 + this.buffer) / canvasRect.height) * 2;
      const radius = Math.max(radiusX, radiusY) * this.radiusInflation;
      
      // Determine strength based on element type
      let strength = this.strength;
      
      if (el.tagName === 'H1' || el.tagName === 'H2') {
        strength *= 1.4;
      } else if (el.tagName === 'BUTTON' || el.classList.contains('sw-demo-chip')) {
        strength *= 1.25;
      } else if (el.classList.contains('sw-demo-chat-bubble')) {
        strength *= 1.15;
      } else if (el.classList.contains('sw-live-proof-bar')) {
        strength *= 1.5;
      }
      
      return {
        center: new THREE.Vector2(ndcX, ndcY),
        radius: radius,
        strength: strength,
        type: this.getElementType(el)
      };
    }

    /**
     * Get element type for categorization
     */
    getElementType(el) {
      if (el.tagName.match(/^H[1-6]$/)) return 'heading';
      if (el.tagName === 'P') return 'paragraph';
      if (el.tagName === 'BUTTON') return 'button';
      if (el.classList.contains('sw-demo-chat-bubble')) return 'chat-bubble';
      if (el.classList.contains('sw-demo-chip')) return 'chip';
      if (el.classList.contains('sw-live-proof-bar')) return 'proof';
      return 'text';
    }

    /**
     * Update cached uniform arrays
     */
    updateUniformArrays() {
      this.uniformCenters.fill(0);
      this.uniformRadii.fill(0);
      
      const count = Math.min(this.textZones.length, this.maxZones);
      
      for (let i = 0; i < count; i++) {
        const zone = this.textZones[i];
        this.uniformCenters[i * 2] = zone.center.x;
        this.uniformCenters[i * 2 + 1] = zone.center.y;
        this.uniformRadii[i] = zone.radius;
      }
    }

    /**
     * Get shader-compatible uniform objects
     */
    getShaderUniforms() {
      return {
        uTextZoneCenters: { value: this.uniformCenters },
        uTextZoneRadii: { value: this.uniformRadii },
        uTextZoneCount: { value: Math.min(this.textZones.length, this.maxZones) }
      };
    }

    /**
     * Update existing uniforms in a material
     */
    updateMaterialUniforms(material) {
      if (!material || !material.uniforms) return;
      
      const uniforms = material.uniforms;
      
      if (uniforms.uTextZoneCenters) {
        uniforms.uTextZoneCenters.value = this.uniformCenters;
      }
      if (uniforms.uTextZoneRadii) {
        uniforms.uTextZoneRadii.value = this.uniformRadii;
      }
      if (uniforms.uTextZoneCount) {
        uniforms.uTextZoneCount.value = Math.min(this.textZones.length, this.maxZones);
      }
      
      this.needsUpdate = false;
    }

    /**
     * CPU-side repulsion force calculation (fallback/debug)
     */
    getRepulsionForce(particlePos) {
      const totalForce = new THREE.Vector2(0, 0);
      
      for (const zone of this.textZones) {
        const toParticle = new THREE.Vector2(
          particlePos.x - zone.center.x,
          particlePos.y - zone.center.y
        );
        
        const distance = toParticle.length();
        
        if (distance < zone.radius && distance > 0.001) {
          const normalizedDist = distance / zone.radius;
          const forceMagnitude = zone.strength * Math.pow(1 - normalizedDist, 3);
          
          toParticle.normalize().multiplyScalar(forceMagnitude);
          totalForce.add(toParticle);
        }
      }
      
      return totalForce;
    }

    /**
     * Check if position is inside any zone
     */
    isInsideAnyZone(pos) {
      for (const zone of this.textZones) {
        const dx = pos.x - zone.center.x;
        const dy = pos.y - zone.center.y;
        const distSq = dx * dx + dy * dy;
        
        if (distSq < zone.radius * zone.radius) {
          return true;
        }
      }
      return false;
    }

    /**
     * Add custom collision zone
     */
    addCustomZone(options) {
      const zone = {
        center: new THREE.Vector2(options.x || 0, options.y || 0),
        radius: (options.radius || 0.2) * this.radiusInflation,
        strength: options.strength || this.strength,
        type: 'custom'
      };
      
      this.textZones.push(zone);
      this.updateUniformArrays();
      this.needsUpdate = true;
      
      return zone;
    }

    /**
     * Remove custom zone
     */
    removeCustomZone(zone) {
      const index = this.textZones.indexOf(zone);
      if (index > -1) {
        this.textZones.splice(index, 1);
        this.updateUniformArrays();
        this.needsUpdate = true;
      }
    }

    /**
     * Clear all zones
     */
    clearAllZones() {
      this.textZones = [];
      this.updateUniformArrays();
      this.needsUpdate = true;
    }

    /**
     * Destroy manager
     */
    destroy() {
      if (this.mutationObserver) {
        this.mutationObserver.disconnect();
        this.mutationObserver = null;
      }
      
      clearTimeout(this.resizeTimeout);
      clearTimeout(this.scrollTimeout);
      
      this.canvas = null;
      this.camera = null;
      this.containerEl = null;
      this.textZones = [];
      this.isInitialized = false;
      
      if (SW_DEBUG_TEXT_COLLISION) {
        console.log('[text-collision] Manager destroyed');
      }
    }

    /**
     * Getters
     */
    get zoneCount() {
      return this.textZones.length;
    }

    get zones() {
      return this.textZones;
    }
  }

  // ============================================
  // GLSL SNIPPET FOR SHADERS
  // ============================================

  const TEXT_COLLISION_GLSL = `
// Text collision uniforms
uniform vec2 uTextZoneCenters[32];
uniform float uTextZoneRadii[32];
uniform int uTextZoneCount;

// Apply text collision avoidance
vec2 applyTextCollision(vec2 pos) {
  vec2 result = pos;
  
  for (int i = 0; i < 32; i++) {
    if (i >= uTextZoneCount) break;
    
    vec2 toZone = pos - uTextZoneCenters[i];
    float dist = length(toZone);
    float effectiveRadius = uTextZoneRadii[i] * 1.15;
    
    if (dist < effectiveRadius && dist > 0.001) {
      float normalizedDist = dist / effectiveRadius;
      float force = pow(1.0 - normalizedDist, 3.0) * 0.5;
      
      vec2 repulsion = normalize(toZone) * force;
      result += repulsion;
    }
  }
  
  return result;
}
`;

  // ============================================
  // INITIALIZATION
  // ============================================

  function initialize() {
    window.TextCollisionManager = TextCollisionManager;
    window.textCollisionManager = new TextCollisionManager();
    window.TEXT_COLLISION_GLSL = TEXT_COLLISION_GLSL;
    
    window.dispatchEvent(new CustomEvent('sw:textCollisionReady'));
    
    // Auto-init if canvas exists
    setTimeout(() => {
      const canvas = document.querySelector('.sw-particle-canvas-v2, #particle-canvas, .sw-particle-background');
      if (canvas && !window.textCollisionManager.isInitialized) {
        window.textCollisionManager.init(canvas);
      }
    }, 500);
  }

  waitForThree(initialize);

})();

// ─── emma-avatar.js (Holographic AI avatar) ───
/**
 * emma-avatar.js
 * ShockwaveHQ — Holographic AI Assistant Avatar
 * 
 * Creates a "Cortana meets JARVIS" holographic avatar for Emma
 * with scan lines, fresnel rim lighting, breathing animation,
 * orbit particles, and voice-reactive pulsing.
 * 
 * Design References:
 * - Deutsche Telekom "Emma" holographic assistant
 * - Cortana (Halo) scan line aesthetic
 * - JARVIS (Iron Man) floating UI particles
 * 
 * Dependencies: THREE.js, industry-presets.js (optional)
 * Loaded by: build.js injection system
 * 
 * Usage:
 *   const emma = new EmmaAvatar(scene);
 *   emma.setVoiceAmplitude(0.5);
 *   emma.update(deltaTime);
 */

(function() {
  'use strict';

  // ============================================
  // CONFIGURATION
  // ============================================

  const CONFIG = {
    // Avatar geometry
    sphereRadius: 8,
    sphereSegments: 32,
    
    // Glow ring
    ringInnerRadius: 9,
    ringOuterRadius: 10.5,
    ringSegments: 64,
    
    // Orbit particles
    orbitParticleCount: 6,
    orbitRadius: 12,
    orbitParticleSize: 0.5,
    
    // Animation speeds
    breathingSpeed: 0.8,        // Hz
    breathingAmount: 0.05,      // Scale variation
    rotationSpeed: 0.1,         // Radians per second
    scanLineSpeed: 5.0,         // Scan line scroll speed
    
    // Voice reactivity
    voiceScaleMultiplier: 0.3,  // How much voice affects scale
    voiceGlowMultiplier: 0.3,   // How much voice affects glow
    voiceRingMultiplier: 0.5,   // How much voice affects ring
    voiceSmoothing: 0.15,       // Amplitude interpolation speed
    
    // Colors (defaults, overridden by industry preset)
    defaultColor: 0x7C3AED,     // Purple
    glowColor: 0x8B5CF6,        // Light purple
    orbitColor: 0xADE8F4,       // Light cyan
    scanLineColor: 0xE9D5FF,    // Very light purple
    
    // Visibility
    defaultOpacity: 0.7,
    defaultVisible: true,
    
    // Position
    defaultPosition: { x: 0, y: 0, z: 0 }
  };

  // ============================================
  // WAIT FOR THREE.JS
  // ============================================

  function waitForThree(callback, maxAttempts = 50) {
    let attempts = 0;
    const check = () => {
      attempts++;
      if (typeof THREE !== 'undefined') {
        callback();
      } else if (attempts < maxAttempts) {
        setTimeout(check, 100);
      } else {
        console.error('[emma-avatar] THREE.js not found after 5 seconds');
      }
    };
    check();
  }

  // ============================================
  // EMMA HOLOGRAM FRAGMENT SHADER
  // ============================================

  const EMMA_HOLO_VERTEX_SHADER = `
    uniform float uTime;
    uniform float uVoiceAmplitude;
    
    varying vec3 vNormal;
    varying vec3 vPosition;
    varying vec2 vUv;
    varying vec3 vWorldPosition;
    
    void main() {
      vNormal = normalize(normalMatrix * normal);
      vPosition = position;
      vUv = uv;
      
      // Voice-reactive vertex displacement (subtle bulge)
      vec3 displaced = position;
      float voiceDisplace = uVoiceAmplitude * 0.5;
      displaced += normal * voiceDisplace * (0.5 + 0.5 * sin(position.y * 3.0 + uTime * 2.0));
      
      vec4 worldPosition = modelMatrix * vec4(displaced, 1.0);
      vWorldPosition = worldPosition.xyz;
      
      vec4 mvPosition = modelViewMatrix * vec4(displaced, 1.0);
      gl_Position = projectionMatrix * mvPosition;
    }
  `;

  const EMMA_HOLO_FRAGMENT_SHADER = `
    uniform float uTime;
    uniform float uVoiceAmplitude;
    uniform vec3 uColor;
    uniform vec3 uScanLineColor;
    uniform float uOpacity;
    uniform float uScanLineSpeed;
    uniform float uGlowIntensity;
    
    varying vec3 vNormal;
    varying vec3 vPosition;
    varying vec2 vUv;
    varying vec3 vWorldPosition;
    
    void main() {
      // ===== FRESNEL RIM LIGHTING =====
      // Brighter at edges (silhouette effect)
      vec3 viewDirection = normalize(cameraPosition - vWorldPosition);
      float fresnel = pow(1.0 - max(dot(viewDirection, vNormal), 0.0), 3.0);
      
      // ===== SCAN LINES =====
      // Horizontal lines that scroll vertically
      float scanLineFreq = 20.0;
      float scanLineY = vPosition.y * scanLineFreq - uTime * uScanLineSpeed;
      float scanLine = sin(scanLineY) * 0.5 + 0.5;
      scanLine = smoothstep(0.4, 0.6, scanLine);
      
      // Secondary finer scan lines
      float fineScanY = vPosition.y * 60.0 - uTime * uScanLineSpeed * 0.5;
      float fineScan = sin(fineScanY) * 0.5 + 0.5;
      fineScan = smoothstep(0.45, 0.55, fineScan) * 0.3;
      
      // Combine scan lines
      float totalScan = scanLine * 0.7 + fineScan;
      
      // ===== HOLOGRAM NOISE =====
      // Subtle noise for holographic effect
      float noise = fract(sin(dot(vUv + uTime * 0.1, vec2(12.9898, 78.233))) * 43758.5453);
      noise = noise * 0.1;
      
      // ===== VOICE REACTIVITY =====
      // Pulse effect when speaking
      float voicePulse = 1.0 + uVoiceAmplitude * 0.5;
      float voiceGlow = uVoiceAmplitude * uGlowIntensity;
      
      // ===== COMBINE EFFECTS =====
      // Base color with fresnel
      vec3 baseColor = uColor * (0.3 + fresnel * 0.7);
      
      // Add scan line color
      vec3 scanColor = mix(baseColor, uScanLineColor, totalScan * 0.4);
      
      // Add glow from voice
      vec3 finalColor = scanColor + uColor * voiceGlow;
      
      // Add noise
      finalColor += vec3(noise) * 0.1;
      
      // ===== ALPHA CALCULATION =====
      // More opaque at edges, scan lines visible
      float alpha = fresnel * 0.6 + totalScan * 0.25 + 0.15;
      alpha *= uOpacity * voicePulse;
      alpha = clamp(alpha, 0.0, 1.0);
      
      // ===== OUTPUT =====
      gl_FragColor = vec4(finalColor, alpha);
    }
  `;

  // ============================================
  // EMMA AVATAR CLASS
  // ============================================

  class EmmaAvatar {
    /**
     * Create Emma holographic avatar
     * 
     * @param {THREE.Scene} scene - Three.js scene to add avatar to
     * @param {Object} options - Configuration options
     */
    constructor(scene, options = {}) {
      if (!scene) {
        console.error('[emma-avatar] Scene is required');
        return;
      }
      
      this.scene = scene;
      this.options = Object.assign({}, CONFIG, options);
      
      // State
      this.voiceAmplitude = 0;
      this.targetVoiceAmplitude = 0;
      this.isVisible = this.options.defaultVisible;
      this.isSpeaking = false;
      
      // Three.js objects
      this.group = null;           // Container group
      this.avatar = null;          // Main hologram sphere
      this.glowRing = null;        // Horizontal glow ring
      this.innerGlow = null;       // Inner glow sphere
      this.orbitParticles = [];    // Orbiting particles
      this.auraParticles = null;   // Ambient aura particles
      
      // Animation state
      this.time = 0;
      this.breathPhase = 0;
      
      // Industry preset colors
      this.colors = {
        primary: new THREE.Color(this.options.defaultColor),
        glow: new THREE.Color(this.options.glowColor),
        orbit: new THREE.Color(this.options.orbitColor),
        scanLine: new THREE.Color(this.options.scanLineColor)
      };
      
      // Create avatar
      this.create();
      
      console.log('✨ Emma Avatar created');
    }

    /**
     * Create all avatar components
     */
    create() {
      // Container group for all components
      this.group = new THREE.Group();
      this.group.position.set(
        this.options.defaultPosition.x,
        this.options.defaultPosition.y,
        this.options.defaultPosition.z
      );
      
      // Create components
      this.createMainSphere();
      this.createInnerGlow();
      this.createGlowRing();
      this.createOrbitParticles();
      this.createAuraParticles();
      
      // Add to scene
      this.scene.add(this.group);
      
      // Set initial visibility
      this.setVisible(this.isVisible);
    }

    /**
     * Create main hologram sphere
     */
    createMainSphere() {
      const geometry = new THREE.SphereGeometry(
        this.options.sphereRadius,
        this.options.sphereSegments,
        this.options.sphereSegments
      );
      
      const material = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uVoiceAmplitude: { value: 0 },
          uColor: { value: this.colors.primary },
          uScanLineColor: { value: this.colors.scanLine },
          uOpacity: { value: this.options.defaultOpacity },
          uScanLineSpeed: { value: this.options.scanLineSpeed },
          uGlowIntensity: { value: 0.8 }
        },
        vertexShader: EMMA_HOLO_VERTEX_SHADER,
        fragmentShader: EMMA_HOLO_FRAGMENT_SHADER,
        transparent: true,
        blending: THREE.AdditiveBlending,
        side: THREE.DoubleSide,
        depthWrite: false
      });
      
      this.avatar = new THREE.Mesh(geometry, material);
      this.group.add(this.avatar);
    }

    /**
     * Create inner glow sphere (core)
     */
    createInnerGlow() {
      const geometry = new THREE.SphereGeometry(
        this.options.sphereRadius * 0.6,
        16,
        16
      );
      
      const material = new THREE.MeshBasicMaterial({
        color: this.colors.glow,
        transparent: true,
        opacity: 0.3,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      
      this.innerGlow = new THREE.Mesh(geometry, material);
      this.group.add(this.innerGlow);
    }

    /**
     * Create horizontal glow ring
     */
    createGlowRing() {
      const geometry = new THREE.RingGeometry(
        this.options.ringInnerRadius,
        this.options.ringOuterRadius,
        this.options.ringSegments
      );
      
      const material = new THREE.MeshBasicMaterial({
        color: this.colors.primary,
        transparent: true,
        opacity: 0.4,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      
      this.glowRing = new THREE.Mesh(geometry, material);
      this.glowRing.rotation.x = Math.PI / 2; // Horizontal
      this.group.add(this.glowRing);
    }

    /**
     * Create orbiting satellite particles
     */
    createOrbitParticles() {
      this.orbitParticles = [];
      
      for (let i = 0; i < this.options.orbitParticleCount; i++) {
        // Particle geometry
        const geometry = new THREE.SphereGeometry(
          this.options.orbitParticleSize,
          8,
          8
        );
        
        // Particle material with glow
        const material = new THREE.MeshBasicMaterial({
          color: this.colors.orbit,
          transparent: true,
          opacity: 0.8,
          blending: THREE.AdditiveBlending
        });
        
        const particle = new THREE.Mesh(geometry, material);
        
        // Store orbit parameters
        particle.userData = {
          orbitAngle: (i / this.options.orbitParticleCount) * Math.PI * 2,
          orbitRadius: this.options.orbitRadius,
          orbitSpeed: 0.5 + Math.random() * 0.3,
          orbitTilt: (Math.random() - 0.5) * 0.5, // Slight tilt variation
          verticalOffset: (i % 2) * 5 - 2.5,      // Stagger heights
          verticalSpeed: 0.3 + Math.random() * 0.2,
          phaseOffset: Math.random() * Math.PI * 2
        };
        
        // Add glow trail (small line behind particle)
        const trailGeometry = new THREE.BufferGeometry();
        const trailPositions = new Float32Array(6); // 2 points
        trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
        
        const trailMaterial = new THREE.LineBasicMaterial({
          color: this.colors.orbit,
          transparent: true,
          opacity: 0.4,
          blending: THREE.AdditiveBlending
        });
        
        const trail = new THREE.Line(trailGeometry, trailMaterial);
        particle.userData.trail = trail;
        
        this.group.add(particle);
        this.group.add(trail);
        this.orbitParticles.push(particle);
      }
    }

    /**
     * Create ambient aura particles
     */
    createAuraParticles() {
      const particleCount = 50;
      const geometry = new THREE.BufferGeometry();
      
      const positions = new Float32Array(particleCount * 3);
      const sizes = new Float32Array(particleCount);
      const alphas = new Float32Array(particleCount);
      
      for (let i = 0; i < particleCount; i++) {
        // Distribute in sphere around avatar
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const radius = this.options.sphereRadius * (1.2 + Math.random() * 0.8);
        
        positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
        positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
        positions[i * 3 + 2] = radius * Math.cos(phi);
        
        sizes[i] = 0.5 + Math.random() * 1.5;
        alphas[i] = 0.3 + Math.random() * 0.4;
      }
      
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      geometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));
      
      // Store original positions for animation
      geometry.userData = {
        originalPositions: positions.slice(),
        particleCount: particleCount
      };
      
      const material = new THREE.PointsMaterial({
        color: this.colors.glow,
        size: 1,
        transparent: true,
        opacity: 0.5,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        sizeAttenuation: true
      });
      
      this.auraParticles = new THREE.Points(geometry, material);
      this.group.add(this.auraParticles);
    }

    // ============================================
    // UPDATE METHODS
    // ============================================

    /**
     * Update avatar animation (call every frame)
     * 
     * @param {number} deltaTime - Time since last frame in seconds
     */
    update(deltaTime) {
      if (!this.group || !this.isVisible) return;
      
      this.time += deltaTime;
      
      // Smooth voice amplitude interpolation
      this.voiceAmplitude += (this.targetVoiceAmplitude - this.voiceAmplitude) * this.options.voiceSmoothing;
      
      // Update components
      this.updateMainSphere(deltaTime);
      this.updateInnerGlow(deltaTime);
      this.updateGlowRing(deltaTime);
      this.updateOrbitParticles(deltaTime);
      this.updateAuraParticles(deltaTime);
      this.updateGroupAnimation(deltaTime);
    }

    /**
     * Update main sphere
     */
    updateMainSphere(deltaTime) {
      if (!this.avatar) return;
      
      const material = this.avatar.material;
      
      // Update shader uniforms
      material.uniforms.uTime.value = this.time;
      material.uniforms.uVoiceAmplitude.value = this.voiceAmplitude;
      
      // Breathing animation
      this.breathPhase += deltaTime * this.options.breathingSpeed * Math.PI * 2;
      const breathScale = 1.0 + Math.sin(this.breathPhase) * this.options.breathingAmount;
      
      // Voice scale
      const voiceScale = 1.0 + this.voiceAmplitude * this.options.voiceScaleMultiplier;
      
      // Combined scale
      const totalScale = breathScale * voiceScale;
      this.avatar.scale.setScalar(totalScale);
    }

    /**
     * Update inner glow
     */
    updateInnerGlow(deltaTime) {
      if (!this.innerGlow) return;
      
      // Pulse with voice
      const pulseScale = 0.6 + this.voiceAmplitude * 0.3;
      this.innerGlow.scale.setScalar(pulseScale);
      
      // Opacity with voice
      this.innerGlow.material.opacity = 0.3 + this.voiceAmplitude * 0.4;
    }

    /**
     * Update glow ring
     */
    updateGlowRing(deltaTime) {
      if (!this.glowRing) return;
      
      // Scale expansion with voice
      const ringScale = 1.0 + this.voiceAmplitude * this.options.voiceRingMultiplier;
      this.glowRing.scale.set(ringScale, ringScale, 1);
      
      // Opacity with voice
      this.glowRing.material.opacity = 0.4 + this.voiceAmplitude * this.options.voiceGlowMultiplier;
      
      // Slow rotation
      this.glowRing.rotation.z += deltaTime * 0.2;
    }

    /**
     * Update orbit particles
     */
    updateOrbitParticles(deltaTime) {
      this.orbitParticles.forEach(particle => {
        const data = particle.userData;
        
        // Update orbit angle
        data.orbitAngle += data.orbitSpeed * deltaTime;
        
        // Calculate position with voice-reactive radius
        const radius = data.orbitRadius * (1 + this.voiceAmplitude * 0.2);
        const angle = data.orbitAngle;
        
        // Orbital position
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        
        // Vertical bobbing
        const verticalBob = Math.sin(this.time * data.verticalSpeed + data.phaseOffset) * 3;
        const y = data.verticalOffset + verticalBob;
        
        // Apply tilt
        const tiltedY = y * Math.cos(data.orbitTilt) - z * Math.sin(data.orbitTilt);
        const tiltedZ = y * Math.sin(data.orbitTilt) + z * Math.cos(data.orbitTilt);
        
        particle.position.set(x, tiltedY, tiltedZ);
        
        // Update trail
        if (data.trail) {
          const trailPositions = data.trail.geometry.attributes.position.array;
          
          // Current position
          trailPositions[0] = x;
          trailPositions[1] = tiltedY;
          trailPositions[2] = tiltedZ;
          
          // Previous position (offset by angle)
          const trailAngle = angle - 0.3;
          trailPositions[3] = Math.cos(trailAngle) * radius;
          trailPositions[4] = tiltedY - verticalBob * 0.2;
          trailPositions[5] = Math.sin(trailAngle) * radius;
          
          data.trail.geometry.attributes.position.needsUpdate = true;
        }
        
        // Particle glow with voice
        particle.material.opacity = 0.6 + this.voiceAmplitude * 0.4;
        
        // Slight size pulse
        const sizeScale = 1 + Math.sin(this.time * 3 + data.phaseOffset) * 0.2;
        particle.scale.setScalar(sizeScale);
      });
    }

    /**
     * Update aura particles
     */
    updateAuraParticles(deltaTime) {
      if (!this.auraParticles) return;
      
      const geometry = this.auraParticles.geometry;
      const positions = geometry.attributes.position.array;
      const original = geometry.userData.originalPositions;
      const count = geometry.userData.particleCount;
      
      for (let i = 0; i < count; i++) {
        const idx = i * 3;
        
        // Floating animation
        const floatOffset = Math.sin(this.time * 0.5 + i * 0.5) * 0.5;
        
        // Voice-reactive expansion
        const expansion = 1 + this.voiceAmplitude * 0.3;
        
        positions[idx] = original[idx] * expansion + Math.sin(this.time + i) * 0.2;
        positions[idx + 1] = original[idx + 1] * expansion + floatOffset;
        positions[idx + 2] = original[idx + 2] * expansion + Math.cos(this.time + i) * 0.2;
      }
      
      geometry.attributes.position.needsUpdate = true;
      
      // Opacity with voice
      this.auraParticles.material.opacity = 0.3 + this.voiceAmplitude * 0.3;
    }

    /**
     * Update group animation (rotation)
     */
    updateGroupAnimation(deltaTime) {
      // Slow continuous rotation
      this.group.rotation.y += deltaTime * this.options.rotationSpeed;
    }

    // ============================================
    // PUBLIC CONTROL METHODS
    // ============================================

    /**
     * Set voice amplitude (0-1)
     * 
     * @param {number} amplitude - Voice amplitude value
     */
    setVoiceAmplitude(amplitude) {
      this.targetVoiceAmplitude = Math.max(0, Math.min(1, amplitude));
      this.isSpeaking = amplitude > 0.1;
    }

    /**
     * Set visibility
     * 
     * @param {boolean} visible
     */
    setVisible(visible) {
      this.isVisible = visible;
      if (this.group) {
        this.group.visible = visible;
      }
    }

    /**
     * Toggle visibility
     */
    toggleVisible() {
      this.setVisible(!this.isVisible);
    }

    /**
     * Set position
     * 
     * @param {number} x
     * @param {number} y
     * @param {number} z
     */
    setPosition(x, y, z) {
      if (this.group) {
        this.group.position.set(x, y, z);
      }
    }

    /**
     * Set scale
     * 
     * @param {number} scale
     */
    setScale(scale) {
      if (this.group) {
        this.group.scale.setScalar(scale);
      }
    }

    /**
     * Apply industry preset colors
     * 
     * @param {Object} preset - Industry preset object
     */
    applyPreset(preset) {
      if (!preset || !preset.emma) return;
      
      const emmaConfig = preset.emma;
      
      // Update colors
      if (emmaConfig.color) {
        this.colors.primary.copy(emmaConfig.color);
        
        // Update materials
        if (this.avatar && this.avatar.material.uniforms) {
          this.avatar.material.uniforms.uColor.value = this.colors.primary;
        }
        if (this.glowRing) {
          this.glowRing.material.color.copy(this.colors.primary);
        }
      }
      
      // Update glow intensity
      if (typeof emmaConfig.glowIntensity === 'number') {
        if (this.avatar && this.avatar.material.uniforms) {
          this.avatar.material.uniforms.uGlowIntensity.value = emmaConfig.glowIntensity;
        }
      }
      
      // Update scan line speed
      if (typeof emmaConfig.scanLineSpeed === 'number') {
        if (this.avatar && this.avatar.material.uniforms) {
          this.avatar.material.uniforms.uScanLineSpeed.value = emmaConfig.scanLineSpeed;
        }
      }
      
      // Update orbit speed
      if (typeof emmaConfig.orbitSpeed === 'number') {
        this.orbitParticles.forEach(particle => {
          particle.userData.orbitSpeed = emmaConfig.orbitSpeed + Math.random() * 0.2;
        });
      }
      
      console.log(`✨ Emma preset applied: ${preset.name || 'custom'}`);
    }

    /**
     * Set primary color
     * 
     * @param {THREE.Color|number|string} color
     */
    setColor(color) {
      const newColor = color instanceof THREE.Color ? color : new THREE.Color(color);
      this.colors.primary.copy(newColor);
      
      // Update materials
      if (this.avatar && this.avatar.material.uniforms) {
        this.avatar.material.uniforms.uColor.value = this.colors.primary;
      }
      if (this.glowRing) {
        this.glowRing.material.color.copy(this.colors.primary);
      }
      if (this.innerGlow) {
        this.innerGlow.material.color.copy(this.colors.primary);
      }
    }

    /**
     * Trigger speaking animation burst
     */
    triggerSpeakBurst() {
      // Temporary amplitude spike
      this.targetVoiceAmplitude = 0.8;
      
      setTimeout(() => {
        this.targetVoiceAmplitude = 0.4;
      }, 200);
      
      setTimeout(() => {
        this.targetVoiceAmplitude = 0;
      }, 800);
    }

    /**
     * Start continuous speaking state
     * 
     * @param {number} intensity - Speaking intensity (0-1)
     */
    startSpeaking(intensity = 0.6) {
      this.isSpeaking = true;
      this.targetVoiceAmplitude = intensity;
    }

    /**
     * Stop speaking
     */
    stopSpeaking() {
      this.isSpeaking = false;
      this.targetVoiceAmplitude = 0;
    }

    // ============================================
    // CLEANUP
    // ============================================

    /**
     * Destroy avatar and clean up resources
     */
    destroy() {
      if (!this.group) return;
      
      // Remove from scene
      this.scene.remove(this.group);
      
      // Dispose geometries and materials
      if (this.avatar) {
        this.avatar.geometry.dispose();
        this.avatar.material.dispose();
      }
      
      if (this.innerGlow) {
        this.innerGlow.geometry.dispose();
        this.innerGlow.material.dispose();
      }
      
      if (this.glowRing) {
        this.glowRing.geometry.dispose();
        this.glowRing.material.dispose();
      }
      
      this.orbitParticles.forEach(particle => {
        particle.geometry.dispose();
        particle.material.dispose();
        if (particle.userData.trail) {
          particle.userData.trail.geometry.dispose();
          particle.userData.trail.material.dispose();
        }
      });
      
      if (this.auraParticles) {
        this.auraParticles.geometry.dispose();
        this.auraParticles.material.dispose();
      }
      
      // Clear references
      this.group = null;
      this.avatar = null;
      this.innerGlow = null;
      this.glowRing = null;
      this.orbitParticles = [];
      this.auraParticles = null;
      
      console.log('✨ Emma Avatar destroyed');
    }

    // ============================================
    // GETTERS
    // ============================================

    /**
     * Get current voice amplitude
     */
    get currentAmplitude() {
      return this.voiceAmplitude;
    }

    /**
     * Get group position
     */
    get position() {
      return this.group ? this.group.position : new THREE.Vector3();
    }

    /**
     * Check if currently speaking
     */
    get speaking() {
      return this.isSpeaking;
    }
  }

  // ============================================
  // FACTORY FUNCTION
  // ============================================

  /**
   * Create Emma avatar with optional auto-configuration
   * 
   * @param {THREE.Scene} scene
   * @param {Object} options
   * @returns {EmmaAvatar}
   */
  function createEmmaAvatar(scene, options = {}) {
    const emma = new EmmaAvatar(scene, options);
    
    // Auto-apply industry preset if available
    if (window.INDUSTRY_PRESETS && window.detectIndustry) {
      const industry = window.detectIndustry();
      const preset = window.INDUSTRY_PRESETS[industry];
      if (preset) {
        emma.applyPreset(preset);
      }
    }
    
    return emma;
  }

  // ============================================
  // INITIALIZATION
  // ============================================

  function initialize() {
    // Export class and factory
    window.EmmaAvatar = EmmaAvatar;
    window.createEmmaAvatar = createEmmaAvatar;
    
    console.log('✨ Emma Avatar System initialized');
    
    // Dispatch ready event
    window.dispatchEvent(new CustomEvent('sw:emmaAvatarReady'));
  }

  // Wait for THREE.js then initialize
  waitForThree(initialize);

})();



  // Verify enhancement modules loaded
    var modules = {
    INDUSTRY_PRESETS: typeof window.INDUSTRY_PRESETS !== 'undefined',
    AdaptiveQualitySystem: typeof window.AdaptiveQualitySystem !== 'undefined',
    MorphEngine: typeof window.MorphEngine !== 'undefined',
    ParticleSystem: typeof window.ParticleSystem !== 'undefined',
    OrbitalFlowSystem: typeof window.OrbitalFlowSystem !== 'undefined',
    ParticleIntelligenceSystem: typeof window.ParticleIntelligenceSystem !== 'undefined',
    TextCollisionManager: typeof window.TextCollisionManager !== 'undefined',
    EmmaAvatar: typeof window.EmmaAvatar !== 'undefined'
  };
  console.log('[Shockwave] Enhancement modules:', modules);
  
  // Count loaded modules
  var loadedCount = Object.values(modules).filter(Boolean).length;
  console.log('[Shockwave] Loaded ' + loadedCount + '/' + Object.keys(modules).length + ' modules');
})();
</script>

<!-- ═══════════════════════════════════════════════════════════════════════════
     BLOCK 4: CORE DEMO LOGIC
     UI, chat, voice, webhooks - original live-demo functionality
     (live-demo-core.js + live-demo.js)
     ═══════════════════════════════════════════════════════════════════════════ -->
<script>
(function() {
  'use strict';
  
// ═══ LIVE DEMO CORE ENGINE ═══
// sections/live-demo-core.js
// ShockwaveHQ — Live Demo Core Engine
// Voice background, real-time listener, polling listener, proof bar, amplitude calibration & shared utilities

(function () {
  'use strict';

  const Core = {};

  // ============================================
  // DEBUG FLAG (silent by default)
  // ============================================
  
  const SW_DEBUG_CORE = window.SW_DEBUG_CORE === true;

  function debugLog(...args) {
    if (SW_DEBUG_CORE) {
      console.log('[live-demo-core]', ...args);
    }
  }

  /* ============================================
     ANALYTICS SHIM (SHARED)
     ============================================ */

  function trackEvent(name, payload = {}) {
    try {
      if (window.dataLayer && Array.isArray(window.dataLayer)) {
        window.dataLayer.push({ event: name, ...payload });
      } else if (typeof window.gtag === 'function') {
        window.gtag('event', name, payload);
      } else {
        debugLog('analytics event:', name, payload);
      }
    } catch (e) {
      debugLog('analytics error:', e);
    }
  }

  Core.trackEvent = trackEvent;

  /* ============================================
     VOICE AMPLITUDE CALIBRATION
     ============================================ */

  /**
   * Calibrate raw amplitude from backend/microphone
   * Normalizes and applies curve for natural feel
   * 
   * @param {number} rawAmplitude - Raw amplitude (0-1 or higher)
   * @param {Object} options - Calibration options
   * @returns {number} - Calibrated amplitude (0-1)
   */
  function calibrateAmplitude(rawAmplitude, options = {}) {
    const {
      minThreshold = 0.05,    // Below this = silence
      maxClamp = 1.0,         // Maximum value
      curve = 0.7,            // Power curve (< 1 = soften peaks)
      smoothing = 0.15        // Smoothing factor (not applied here, for reference)
    } = options;

    // Clamp to valid range
    let normalized = Math.max(0, Math.min(maxClamp, rawAmplitude));

    // Apply threshold (ignore noise floor)
    if (normalized < minThreshold) {
      normalized = 0;
    } else {
      // Remap above threshold to 0-1
      normalized = (normalized - minThreshold) / (maxClamp - minThreshold);
    }

    // Apply power curve to soften peaks
    normalized = Math.pow(normalized, curve);

    return Math.max(0, Math.min(1, normalized));
  }

  /**
   * Create a smoothed amplitude tracker
   * Returns object with update() method for frame-by-frame smoothing
   */
  function createAmplitudeTracker(smoothingFactor = 0.15) {
    let currentValue = 0;
    let targetValue = 0;

    return {
      update(rawAmplitude) {
        targetValue = calibrateAmplitude(rawAmplitude);
        currentValue += (targetValue - currentValue) * smoothingFactor;
        return currentValue;
      },
      
      getValue() {
        return currentValue;
      },
      
      getTarget() {
        return targetValue;
      },
      
      reset() {
        currentValue = 0;
        targetValue = 0;
      }
    };
  }

  /**
   * Broadcast calibrated amplitude to particle system and Emma
   */
  function broadcastAmplitude(amplitude) {
    const calibrated = typeof amplitude === 'number' ? amplitude : 0;
    
    try {
      window.dispatchEvent(new CustomEvent('voiceAmplitude', {
        detail: { amplitude: calibrated }
      }));
      
      window.dispatchEvent(new CustomEvent('sw:voiceAmplitude', {
        detail: { amplitude: calibrated }
      }));
    } catch (e) {
      debugLog('broadcastAmplitude error:', e);
    }
  }

  Core.calibrateAmplitude = calibrateAmplitude;
  Core.createAmplitudeTracker = createAmplitudeTracker;
  Core.broadcastAmplitude = broadcastAmplitude;

  /* ============================================
     VOICE-REACTIVE BACKGROUND SYSTEM
     (Auto-switches between Simulated, Polling, and Real-Time)
     ============================================ */

  class VoiceReactiveBackground {
    constructor(container) {
      this.container = container;
      this.canvas = document.createElement('canvas');
      this.canvas.className = 'live-demo-sonic-canvas';
      this.ctx = this.canvas.getContext('2d');

      // Particle overlay
      this.particleLayer = document.createElement('div');
      this.particleLayer.className = 'live-demo-particle-layer';

      // Insert as first children of bg-wrap
      this.container.insertBefore(this.canvas, this.container.firstChild);
      this.container.insertBefore(this.particleLayer, this.container.firstChild);

      this.config = {
        barCount: window.innerWidth <= 768 ? 40 : 60,
        barWidth: 4,
        barGap: 2,
        maxBarHeight: 0.7,
        colors: {
          IDLE: { primary: 'rgba(100, 116, 139, 0.4)', glow: 'rgba(139, 92, 246, 0.1)' },
          AI_SPEAKING: { primary: 'rgba(139, 92, 246, 0.8)', glow: 'rgba(139, 92, 246, 0.3)' },
          USER_SPEAKING: { primary: 'rgba(16, 185, 129, 0.8)', glow: 'rgba(16, 185, 129, 0.3)' },
          SILENCE: { primary: 'rgba(100, 116, 139, 0.2)', glow: 'rgba(100, 116, 139, 0.05)' }
        },
        amplitudes: {
          IDLE: { min: 0.05, max: 0.15 },
          AI_SPEAKING: { min: 0.3, max: 0.8 },
          USER_SPEAKING: { min: 0.4, max: 0.9 },
          SILENCE: { min: 0.02, max: 0.08 }
        }
      };

      this.voiceState = 'IDLE';
      this.bars = [];
      this.animationFrame = null;
      this.voiceController = null;
      
      // Amplitude tracker for smooth values
      this.amplitudeTracker = createAmplitudeTracker(0.12);
      this.lastBroadcastTime = 0;
      this.broadcastInterval = 50; // ms between broadcasts

      this.resize();
      this.initBars();
      this.animate();

      window.addEventListener('resize', () => this.resize());
    }

    resize() {
      const rect = this.container.getBoundingClientRect();
      this.canvas.width = rect.width || this.container.offsetWidth || 1200;
      this.canvas.height = rect.height || this.container.offsetHeight || 600;
    }

    initBars() {
      this.bars = [];
      const totalWidth = this.config.barCount * (this.config.barWidth + this.config.barGap);
      const startX = (this.canvas.width - totalWidth) / 2;

      for (let i = 0; i < this.config.barCount; i++) {
        this.bars.push({
          x: startX + i * (this.config.barWidth + this.config.barGap),
          targetHeight: Math.random() * 0.15,
          currentHeight: 0,
          velocity: 0,
          frequency: 0.02 + Math.random() * 0.03
        });
      }
    }

    setVoiceState(newState) {
      if (this.config.amplitudes[newState]) {
        this.voiceState = newState;
        this.container.setAttribute('data-voice-state', newState);
      }
    }

    /**
     * Set raw amplitude from external source (n8n, VAPI, etc.)
     * Will be calibrated and broadcast
     */
    setRawAmplitude(rawAmplitude) {
      const smoothed = this.amplitudeTracker.update(rawAmplitude);
      
      // Throttle broadcasts
      const now = performance.now();
      if (now - this.lastBroadcastTime > this.broadcastInterval) {
        broadcastAmplitude(smoothed);
        this.lastBroadcastTime = now;
      }
      
      return smoothed;
    }

    animate() {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

      const colors = this.config.colors[this.voiceState];
      const ampRange = this.config.amplitudes[this.voiceState];
      const centerY = this.canvas.height / 2;

      // Get current smoothed amplitude for particle system sync
      const currentAmp = this.amplitudeTracker.getValue();

      this.bars.forEach((bar, i) => {
        const randomFactor = Math.sin(Date.now() * bar.frequency + i) * 0.5 + 0.5;
        bar.targetHeight = ampRange.min + (ampRange.max - ampRange.min) * randomFactor;

        // Add amplitude influence
        bar.targetHeight *= (0.7 + currentAmp * 0.6);

        const diff = bar.targetHeight - bar.currentHeight;
        bar.velocity += diff * 0.02;
        bar.velocity *= 0.85;
        bar.currentHeight += bar.velocity;

        const barHeight = bar.currentHeight * this.canvas.height * this.config.maxBarHeight;

        this.ctx.shadowBlur = 20;
        this.ctx.shadowColor = colors.glow;
        this.ctx.fillStyle = colors.primary;

        this.ctx.fillRect(
          bar.x,
          centerY - barHeight / 2,
          this.config.barWidth,
          barHeight
        );
      });

      this.ctx.shadowBlur = 0;

      this.animationFrame = requestAnimationFrame(() => this.animate());
    }

    startConversation(callId = null) {
      if (this.voiceController) return;

      const pollUrl = window.SW_VOICE_POLL_URL || null;
      
      if (pollUrl) {
        debugLog('POLLING MODE via n8n');
        this.voiceController = new PollingVoiceListener(this, callId, pollUrl);
        this.container.setAttribute('data-voice-mode', 'poll');
        this.voiceController.start();
        return;
      }

      const useRealTime = this.isRealTimeAvailable();

      if (useRealTime) {
        debugLog('REAL-TIME MODE activated');
        this.voiceController = new RealTimeVoiceListener(this, callId);
        this.container.setAttribute('data-voice-mode', 'realtime');
      } else {
        debugLog('SIMULATED MODE activated');
        this.voiceController = new ConversationSimulator(this);
        this.container.setAttribute('data-voice-mode', 'simulated');
      }

      this.voiceController.start();
    }

    stopConversation() {
      if (this.voiceController) {
        this.voiceController.stop();
        this.voiceController = null;
      }
      this.setVoiceState('IDLE');
      this.amplitudeTracker.reset();
      broadcastAmplitude(0);
      this.container.removeAttribute('data-voice-mode');
    }

    isRealTimeAvailable() {
      return typeof EventSource !== 'undefined' &&
        window.VOICE_API_ENABLED === true;
    }

    destroy() {
      if (this.animationFrame) cancelAnimationFrame(this.animationFrame);
      this.stopConversation();
      this.canvas.remove();
      this.particleLayer.remove();
    }
  }

  /* ============================================
     CONVERSATION SIMULATOR (LOCAL FALLBACK)
     ============================================ */

  class ConversationSimulator {
    constructor(voiceBackground) {
      this.voiceBackground = voiceBackground;
      this.isRunning = false;
      this.timeoutId = null;
      this.amplitudeInterval = null;

      this.durations = {
        AI_SPEAKING: { min: 3000, max: 5000 },
        USER_SPEAKING: { min: 5000, max: 8000 },
        SILENCE: { min: 500, max: 1500 }
      };

      this.sequence = ['AI_SPEAKING', 'SILENCE', 'USER_SPEAKING', 'SILENCE'];
      this.currentIndex = 0;
    }

    start() {
      if (this.isRunning) return;
      this.isRunning = true;
      this.currentIndex = 0;
      this.runNextState();
      this.startAmplitudeSimulation();
    }

    stop() {
      this.isRunning = false;
      if (this.timeoutId) {
        clearTimeout(this.timeoutId);
        this.timeoutId = null;
      }
      if (this.amplitudeInterval) {
        clearInterval(this.amplitudeInterval);
        this.amplitudeInterval = null;
      }
      this.voiceBackground.setVoiceState('IDLE');
      broadcastAmplitude(0);
    }

    runNextState() {
      if (!this.isRunning) return;

      const state = this.sequence[this.currentIndex];
      const duration = this.getRandomDuration(state);

      this.voiceBackground.setVoiceState(state);

      this.timeoutId = setTimeout(() => {
        this.currentIndex = (this.currentIndex + 1) % this.sequence.length;
        this.runNextState();
      }, duration);
    }

    startAmplitudeSimulation() {
      // Simulate amplitude updates at 60fps-ish
      this.amplitudeInterval = setInterval(() => {
        if (!this.isRunning) return;
        
        const state = this.voiceBackground.voiceState;
        let amplitude = 0;
        
        if (state === 'AI_SPEAKING') {
          amplitude = 0.4 + Math.random() * 0.4 + Math.sin(Date.now() * 0.01) * 0.15;
        } else if (state === 'USER_SPEAKING') {
          amplitude = 0.5 + Math.random() * 0.35 + Math.sin(Date.now() * 0.012) * 0.1;
        } else if (state === 'SILENCE') {
          amplitude = Math.random() * 0.08;
        } else {
          amplitude = Math.random() * 0.05;
        }
        
        this.voiceBackground.setRawAmplitude(amplitude);
      }, 50);
    }

    getRandomDuration(state) {
      const range = this.durations[state];
      return range.min + Math.random() * (range.max - range.min);
    }
  }

  /* ============================================
     REAL-TIME VOICE LISTENER (SSE)
     ============================================ */

  class RealTimeVoiceListener {
    constructor(voiceBackground, callId) {
      this.voiceBackground = voiceBackground;
      this.callId = callId || this.generateCallId();
      this.eventSource = null;
      this.reconnectAttempts = 0;
      this.maxReconnectAttempts = 3;
      this.lastHeartbeat = Date.now();
      this.heartbeatInterval = null;
    }

    generateCallId() {
      return `call_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    start() {
      const apiUrl = `/api/voice-events/${this.callId}`;
      debugLog(`Connecting to ${apiUrl}...`);

      try {
        this.eventSource = new EventSource(apiUrl);

        this.eventSource.addEventListener('open', () => {
          debugLog('Connected');
          this.reconnectAttempts = 0;
          this.startHeartbeatMonitor();
        });

        this.eventSource.addEventListener('ai_speaking', () => {
          this.voiceBackground.setVoiceState('AI_SPEAKING');
          this.lastHeartbeat = Date.now();
        });

        this.eventSource.addEventListener('user_speaking', () => {
          this.voiceBackground.setVoiceState('USER_SPEAKING');
          this.lastHeartbeat = Date.now();
        });

        this.eventSource.addEventListener('silence', () => {
          this.voiceBackground.setVoiceState('SILENCE');
          this.lastHeartbeat = Date.now();
        });

        // Amplitude data from backend
        this.eventSource.addEventListener('amplitude', (e) => {
          try {
            const data = JSON.parse(e.data || '{}');
            if (typeof data.value === 'number') {
              this.voiceBackground.setRawAmplitude(data.value);
            }
          } catch (err) {
            debugLog('amplitude parse error:', err);
          }
          this.lastHeartbeat = Date.now();
        });

        this.eventSource.addEventListener('call_ended', () => {
          debugLog('Call ended');
          this.voiceBackground.setVoiceState('IDLE');
          this.stop();
          try {
            window.dispatchEvent(
              new CustomEvent('sw:voiceStatus', {
                detail: { callId: this.callId, status: 'ended' }
              })
            );
          } catch (e) {}
        });

        this.eventSource.addEventListener('ping', () => {
          this.lastHeartbeat = Date.now();
        });

        this.eventSource.addEventListener('transcript', (e) => {
          try {
            const data = JSON.parse(e.data || '{}');
            if (data && data.text) {
              window.dispatchEvent(
                new CustomEvent('sw:voiceTranscript', {
                  detail: {
                    callId: this.callId,
                    role: data.role || 'assistant',
                    text: data.text,
                    timestamp: data.timestamp || Date.now()
                  }
                })
              );
            }
          } catch (err) {
            debugLog('transcript parse error:', err);
          }
          this.lastHeartbeat = Date.now();
        });

        this.eventSource.addEventListener('error', (e) => {
          console.error('[live-demo-core] SSE connection error', e);
          if (this.eventSource.readyState === EventSource.CLOSED) {
            this.handleDisconnect();
          }
        });

      } catch (error) {
        console.error('[live-demo-core] Failed to connect', error);
        this.fallbackToSimulated();
      }
    }

    startHeartbeatMonitor() {
      this.heartbeatInterval = setInterval(() => {
        const delta = Date.now() - this.lastHeartbeat;
        if (delta > 45000) {
          console.warn('[live-demo-core] Heartbeat timeout, reconnecting…');
          this.handleDisconnect();
        }
      }, 5000);
    }

    handleDisconnect() {
      this.stop();

      if (this.reconnectAttempts < this.maxReconnectAttempts) {
        this.reconnectAttempts++;
        const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 10000);
        debugLog(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`);
        setTimeout(() => this.start(), delay);
      } else {
        console.error('[live-demo-core] Max reconnect attempts, falling back to simulated');
        this.fallbackToSimulated();
      }
    }

    fallbackToSimulated() {
      debugLog('Switching to simulated mode…');
      this.stop();

      const simulator = new ConversationSimulator(this.voiceBackground);
      this.voiceBackground.voiceController = simulator;
      this.voiceBackground.container.setAttribute('data-voice-mode', 'simulated');
      simulator.start();
    }

    stop() {
      if (this.heartbeatInterval) {
        clearInterval(this.heartbeatInterval);
        this.heartbeatInterval = null;
      }
      if (this.eventSource) {
        this.eventSource.close();
        this.eventSource = null;
      }
    }
  }

  /* ============================================
     POLLING VOICE LISTENER (n8n/GHL)
     ============================================ */

  class PollingVoiceListener {
    constructor(voiceBackground, callId, pollUrl) {
      this.voiceBackground = voiceBackground;
      this.callId = callId || this.generateCallId();
      this.pollUrl = pollUrl;
      this.intervalId = null;
      this.isRunning = false;
      this.lastTs = 0;
      this.pollIntervalMs = 2000;
    }

    generateCallId() {
      return `poll_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    start() {
      if (!this.pollUrl || this.isRunning) return;
      this.isRunning = true;
      this.voiceBackground.setVoiceState('SILENCE');

      this.pollOnce();
      this.intervalId = setInterval(() => this.pollOnce(), this.pollIntervalMs);
    }

    stop() {
      this.isRunning = false;
      if (this.intervalId) {
        clearInterval(this.intervalId);
        this.intervalId = null;
      }
      this.voiceBackground.setVoiceState('IDLE');
      broadcastAmplitude(0);
    }

    async pollOnce() {
      if (!this.isRunning) return;

      try {
        const url = new URL(this.pollUrl);
        url.searchParams.set('callId', this.callId);
        if (this.lastTs) {
          url.searchParams.set('since', String(this.lastTs));
        }

        const res = await fetch(url.toString(), { method: 'GET' });
        if (!res.ok) throw new Error(`Polling non-200: ${res.status}`);

        const data = await res.json();
        const status = data.status || 'live';
        const messages = Array.isArray(data.messages) ? data.messages : [];
        const amplitude = typeof data.amplitude === 'number' ? data.amplitude : null;

        // Handle amplitude from backend
        if (amplitude !== null) {
          this.voiceBackground.setRawAmplitude(amplitude);
        }

        if (messages.length) {
          let lastRole = null;

          messages.forEach((m) => {
            const role = m.role === 'user' ? 'user' : 'assistant';
            const text = String(m.text || '');
            const ts = Number(m.timestamp) || Date.now();

            if (ts > this.lastTs) {
              this.lastTs = ts;
            }
            lastRole = role;

            try {
              window.dispatchEvent(
                new CustomEvent('sw:voiceTranscript', {
                  detail: {
                    callId: this.callId,
                    role,
                    text,
                    timestamp: ts,
                  }
                })
              );
            } catch (e) {}
          });

          if (lastRole === 'assistant') {
            this.voiceBackground.setVoiceState('AI_SPEAKING');
          } else if (lastRole === 'user') {
            this.voiceBackground.setVoiceState('USER_SPEAKING');
          }
        } else {
          this.voiceBackground.setVoiceState('SILENCE');
        }

        if (status === 'ended' || status === 'error') {
          this.stop();
          try {
            window.dispatchEvent(
              new CustomEvent('sw:voiceStatus', {
                detail: { callId: this.callId, status }
              })
            );
          } catch (e) {}
        }

      } catch (err) {
        console.error('[live-demo-core] poll error:', err);
      }
    }
  }

  // Export voice classes
  Core.VoiceReactiveBackground = VoiceReactiveBackground;
  Core.ConversationSimulator = ConversationSimulator;
  Core.RealTimeVoiceListener = RealTimeVoiceListener;
  Core.PollingVoiceListener = PollingVoiceListener;

  Core.createVoiceBackground = function (containerEl) {
    if (!containerEl) return null;
    return new VoiceReactiveBackground(containerEl);
  };

  /* ============================================
     ROI HELPERS (SHARED WITH ROI CALCULATOR)
     ============================================ */

  function getROIData() {
    try {
      const raw = sessionStorage.getItem('sw_roi_calculator_results');
      if (!raw) return null;
      return JSON.parse(raw);
    } catch (e) {
      debugLog('ROI data parse error:', e);
      return null;
    }
  }

  Core.getROIData = getROIData;

 // ─────────────────────────────────────────────
// Proof Bar Model (Projection)
// Override any of these at runtime via window.ShockwaveProofConfig
// Example: window.ShockwaveProofConfig = { companyCount: 50, leadsPerCompanyPerDay: 22, bookingRate: 0.15, avgDealValue: 629 }
// ─────────────────────────────────────────────

const DEFAULT_PROOF_MODEL = {
  companyCount: 50,
  leadsPerCompanyPerDay: 22,
  bookingRate: 0.15,
  avgDealValue: 255,        // $3.8M target
  variance: 0.06,           // ±6% gives $3.57M-$4.03M range
  responseMultiplier: 2.3
};


function getProofModel() {
  const cfg = (window.ShockwaveProofConfig && typeof window.ShockwaveProofConfig === 'object')
    ? window.ShockwaveProofConfig
    : {};

  const m = Object.assign({}, DEFAULT_PROOF_MODEL, cfg);

  // Guardrails
  m.companyCount = clampNumber(m.companyCount, 1, 1000, DEFAULT_PROOF_MODEL.companyCount);
  m.leadsPerCompanyPerDay = clampNumber(m.leadsPerCompanyPerDay, 1, 500, DEFAULT_PROOF_MODEL.leadsPerCompanyPerDay);
  m.bookingRate = clampNumber(m.bookingRate, 0.01, 0.6, DEFAULT_PROOF_MODEL.bookingRate);
  m.avgDealValue = clampNumber(m.avgDealValue, 25, 50000, DEFAULT_PROOF_MODEL.avgDealValue);
  m.variance = clampNumber(m.variance, 0, 0.25, DEFAULT_PROOF_MODEL.variance);
  m.responseMultiplier = clampNumber(m.responseMultiplier, 0.5, 10, DEFAULT_PROOF_MODEL.responseMultiplier);

  return m;
}

function clampNumber(val, min, max, fallback) {
  const n = Number(val);
  if (!isFinite(n)) return fallback;
  return Math.max(min, Math.min(max, n));
}

function formatCompactMoney(val) {
  if (!isFinite(val) || val <= 0) return '$0';
  if (val >= 1_000_000) return '$' + (val / 1_000_000).toFixed(1) + 'M';
  return '$' + Math.round(val / 1000).toLocaleString() + 'K';
}

  const proofTargets = {
    revenue: 0,
    avgResp: 0,
    responses: 0,
    clients: 0,
    _avgRespAnimatedOnce: false
  };
  let proofAnimationReady = false;
  let proofAnimationPlayed = false;

  function seededRandom(seed) {
    const x = Math.sin(seed) * 10000;
    return x - Math.floor(x);
  }

  function getSyncedCounterValue(key) {
  // Check both selector patterns (Hero uses data-daily-counter, other sections may use data-sync-counter)
  let el = document.querySelector('[data-sync-counter="' + key + '"]');
  if (!el) {
    el = document.querySelector('[data-daily-counter="' + key + '"]');
  }
  if (!el) return 0;
  
  const raw = (el.textContent || '').replace(/,/g, '').replace(/s$/, '').trim();
  const num = parseFloat(raw);
  return isNaN(num) ? 0 : num;
}


  function animateNumber(el, from, to, durationMs, formatter) {
    if (!el) return;
    if (!isFinite(from)) from = 0;
    if (!isFinite(to)) to = 0;

    const start = performance.now();
    const diff = to - from;
    const dur = durationMs || 900;

    function frame(now) {
      const t = Math.min(1, (now - start) / dur);
      const eased = 1 - Math.pow(1 - t, 3);
      const current = from + diff * eased;

      el.textContent = formatter
        ? formatter(current)
        : Math.round(current).toLocaleString();

      if (t < 1) {
        requestAnimationFrame(frame);
      } else {
        el.textContent = formatter
          ? formatter(to)
          : Math.round(to).toLocaleString();
      }
    }

    requestAnimationFrame(frame);
  }

    function updateProofBarFromCounters() {
  try {
    const m = getProofModel();

    // ===== READ FROM HERO COUNTERS (data-daily-counter) =====
    function getHeroCounterValue(key) {
      const el = document.querySelector('[data-daily-counter="' + key + '"]');
      if (!el) return 0;
      
      const raw = (el.textContent || '').replace(/,/g, '').replace(/s$/, '').trim();
      const num = parseFloat(raw);
      return isNaN(num) ? 0 : num;
    }

    // Get values from Hero section counters
    const heroLeads = getHeroCounterValue('leads_today');
    const heroResponses = getHeroCounterValue('responses_sent');
    const heroAvgResponse = getHeroCounterValue('avg_response_time');

    const today = new Date();
    const seed = today.getFullYear() * 10000 + (today.getMonth() + 1) * 100 + today.getDate();
    const randomFactor = seededRandom(seed) * 2 - 1;
    const dailyScale = 1 + (m.variance * randomFactor);

    // Use Hero values if available, otherwise project
    const projectedLeads = Math.round(m.companyCount * m.leadsPerCompanyPerDay * dailyScale);
// Always use full-day projection for revenue calculation
// Hero counters show partial day, but revenue should reflect 90-day portfolio potential
const leadsToday = projectedLeads;
    const projectedResponses = Math.round(leadsToday * m.responseMultiplier);
    const responsesToday = heroResponses > 0 ? heroResponses : projectedResponses;

    // Avg response: use Hero value or fallback to 1.8s
    const avgResponseTime = heroAvgResponse > 0 ? heroAvgResponse : 1.8;

    // 90-day revenue projection
    const conversionsPerDay = leadsToday * m.bookingRate;
    const projected90 = conversionsPerDay * m.avgDealValue * 90;

    // Store targets
    proofTargets.revenue = projected90;
    proofTargets.responses = responsesToday;
    proofTargets.clients = m.companyCount;
    proofTargets.avgResp = avgResponseTime;

    // ===== UPDATE PROOF BAR ELEMENTS =====
    
    // Revenue
    const revenueEl = document.querySelector('[data-live-demo-proof-recovered]');
    if (revenueEl) {
      revenueEl.dataset.prevNumeric = String(projected90);
      if (proofAnimationPlayed) {
        revenueEl.textContent = formatCompactMoney(projected90);
      }
    }

    // Client count
    const clientCountEl = document.querySelector('[data-live-demo-client-count]');
    if (clientCountEl && proofAnimationPlayed) {
      clientCountEl.textContent = String(m.companyCount);
    }

    // Avg response time
    const avgRespEl = document.querySelector('[data-live-demo-avg-response]');
    if (avgRespEl) {
      if (!proofAnimationPlayed && !proofTargets._avgRespAnimatedOnce) {
        proofTargets._avgRespAnimatedOnce = true;
        animateNumber(avgRespEl, 0, avgResponseTime, 700, (val) => val.toFixed(1));
      } else if (proofAnimationPlayed) {
        avgRespEl.textContent = avgResponseTime.toFixed(1);
      }
    }

    // Responses (sync counter in proof bar)
    const responsesEl = document.querySelector('.sw-live-proof-secondary .secondary-value');
    if (responsesEl && proofAnimationPlayed) {
      responsesEl.textContent = responsesToday.toLocaleString();
    }

    proofAnimationReady = true;

    debugLog('Proof bar updated:', {
      leadsToday,
      responsesToday,
      avgResp: avgResponseTime,
      revenue90: projected90
    });

  } catch (err) {
    console.error('[live-demo-core] Proof bar update failed:', err);
  }
}

  function playProofAnimations() {
  const revenueEl = document.querySelector('[data-live-demo-proof-recovered]');
  const avgRespEl = document.querySelector('[data-live-demo-avg-response]');
  const responsesEl = document.querySelector('.sw-live-proof-secondary .secondary-value');
  const clientCountEl = document.querySelector('[data-live-demo-client-count]');

  if (revenueEl && isFinite(proofTargets.revenue) && proofTargets.revenue > 0) {
    animateNumber(revenueEl, 0, proofTargets.revenue, 1200, formatCompactMoney);
  }

  if (avgRespEl && isFinite(proofTargets.avgResp) && proofTargets.avgResp > 0) {
    animateNumber(avgRespEl, 0, proofTargets.avgResp, 800, (val) => val.toFixed(1));
  }

  if (responsesEl && isFinite(proofTargets.responses) && proofTargets.responses > 0) {
    animateNumber(responsesEl, 0, proofTargets.responses, 1000);
  }

  if (clientCountEl && isFinite(proofTargets.clients) && proofTargets.clients > 0) {
    animateNumber(clientCountEl, 0, proofTargets.clients, 900);
  }

  proofAnimationPlayed = true;
}

  function initProofObserver() {
    const proofContainer = document.querySelector('.sw-live-demo-proof-container');
    if (!proofContainer) return;

    if (typeof IntersectionObserver === 'undefined') {
      proofAnimationPlayed = true;
      updateProofBarFromCounters();
      return;
    }

    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (!entry.isIntersecting || proofAnimationPlayed) return;

        if (!proofAnimationReady) {
          updateProofBarFromCounters();
        }

        playProofAnimations();
        observer.disconnect();
      });
    }, {
      threshold: 0.35,
    });

    observer.observe(proofContainer);
  }

  Core.updateProofBarFromCounters = updateProofBarFromCounters;
  Core.initProofObserver = initProofObserver;
  Core.animateNumber = animateNumber;

  /* ============================================
     POINTER TRACKING (FOR PARALLAX)
     ============================================ */

  let globalPointer = { x: 0, y: 0 };
  let pointerInitialized = false;

  function initGlobalPointerTracking() {
    if (pointerInitialized) return;
    pointerInitialized = true;

    document.addEventListener('mousemove', (e) => {
      globalPointer.x = (e.clientX / window.innerWidth) * 2 - 1;
      globalPointer.y = -((e.clientY / window.innerHeight) * 2 - 1);
    });

    // Touch support
    document.addEventListener('touchmove', (e) => {
      if (e.touches.length > 0) {
        const touch = e.touches[0];
        globalPointer.x = (touch.clientX / window.innerWidth) * 2 - 1;
        globalPointer.y = -((touch.clientY / window.innerHeight) * 2 - 1);
      }
    }, { passive: true });
  }

  function getGlobalPointer() {
    return { x: globalPointer.x, y: globalPointer.y };
  }

  Core.initGlobalPointerTracking = initGlobalPointerTracking;
  Core.getGlobalPointer = getGlobalPointer;

  /* ============================================
     INITIALIZATION
     ============================================ */

  try {
    updateProofBarFromCounters();
    initProofObserver();
    initGlobalPointerTracking();

    setInterval(updateProofBarFromCounters, 300000);

    window.addEventListener('sw:counters:updated', updateProofBarFromCounters);
    window.addEventListener('swCountersUpdated', updateProofBarFromCounters);
  } catch (err) {
    debugLog('Proof bar init failed:', err);
  }

  // Expose core on window
  window.ShockwaveLiveCore = Core;

  debugLog('Core engine initialized');
})();

// ═══ LIVE DEMO MAIN LOGIC ═══
// sections/live-demo.js
// ShockwaveHQ — Hybrid Interactive AI Demo (Emma Chat + Voice Console + 3D Particles)
//
// Elite implementation with:
// - Full-field ellipsoid particle distribution
// - Industry-aware icon & word morphing
// - Double-click explosion effects
// - 3D rings with pointer tilt
// - Emma holographic avatar with halo
// - Voice-reactive particle field
// - Text collision avoidance
// - Decision tree visualization
// - Performance monitoring
//
// Assumes:
//  - three-particles-v2.js loaded (window.EnhancedParticleSystem)
//  - industry-presets.js loaded (window.INDUSTRY_PRESETS, getNextWord, etc.)
//  - particle-morph-lib.js loaded (window.ParticleMorpher)
//  - text-collision.js loaded (window.TextCollisionManager)
//  - emma-avatar.js loaded (window.EmmaAvatar)
//  - live-demo-core.js loaded (window.ShockwaveLiveCore)
//  - roiEngine.js exports on window
//  - Optional: D3.js for decision tree visualization

'use strict';

/*************************************************
 * DEBUG FLAGS (set via URL params or manually)
 *************************************************/

var SW_DEBUG = (function() {
  try {
    var params = new URLSearchParams(window.location.search);
    return {
      demo: params.get('debug_demo') === '1',
      particles: params.get('debug_particles') === '1',
      collision: params.get('debug_collision') === '1',
      verbose: params.get('debug_verbose') === '1'
    };
  } catch (e) {
    return { demo: false, particles: false, collision: false, verbose: false };
  }
})();

function debugLog(category, args) {
  if (SW_DEBUG[category] || SW_DEBUG.verbose) {
    var logArgs = ['[live-demo:' + category + ']'];
    for (var i = 1; i < arguments.length; i++) {
      logArgs.push(arguments[i]);
    }
    console.log.apply(console, logArgs);
  }
}

/*************************************************
 * CONFIG & GLOBALS
 *************************************************/

var SECTION_ID = 'live-ai-demo';

// Allow external override via window.ShockwaveDemoConfig
var DefaultDemoConfig = {
  chatWebhook: 'https://YOUR_N8N_INSTANCE/webhook/emma-chat',
  voiceStartWebhook: 'https://YOUR_N8N_INSTANCE/webhook/demo-voice-start',
  voicePollWebhook: 'https://YOUR_N8N_INSTANCE/webhook/demo-voice-poll',
  saveDemoWebhook: 'https://YOUR_N8N_INSTANCE/webhook/save-demo',
};

var UserDemoConfig =
  (typeof window !== 'undefined' &&
    window.ShockwaveDemoConfig &&
    typeof window.ShockwaveDemoConfig === 'object')
    ? window.ShockwaveDemoConfig
    : {};

var DemoConfig = {};
for (var key in DefaultDemoConfig) {
  DemoConfig[key] = UserDemoConfig[key] || DefaultDemoConfig[key];
}

var DemoFeatures = {
  chatEnabled:
    !!DemoConfig.chatWebhook &&
    DemoConfig.chatWebhook.indexOf('YOUR_N8N') === -1,
  voiceStartEnabled:
    !!DemoConfig.voiceStartWebhook &&
    DemoConfig.voiceStartWebhook.indexOf('YOUR_N8N') === -1,
  voicePollingEnabled:
    !!DemoConfig.voicePollWebhook &&
    DemoConfig.voicePollWebhook.indexOf('YOUR_N8N') === -1,
  saveDemoEnabled:
    !!DemoConfig.saveDemoWebhook &&
    DemoConfig.saveDemoWebhook.indexOf('YOUR_N8N') === -1,
};

var N8N_CHAT_WEBHOOK_URL = DemoConfig.chatWebhook;
var N8N_VAPI_WEBHOOK_URL = DemoConfig.voiceStartWebhook;
var N8N_VOICE_POLL_URL = DemoConfig.voicePollWebhook;
var N8N_SAVE_DEMO_WEBHOOK_URL = DemoConfig.saveDemoWebhook;

// Expose poll URL for live-demo-core PollingVoiceListener
window.SW_VOICE_POLL_URL = DemoFeatures.voicePollingEnabled
  ? N8N_VOICE_POLL_URL
  : null;

// Pull in core engine
var Core = window.ShockwaveLiveCore || {};
var trackEvent = Core.trackEvent || function(name, payload) {
  debugLog('demo', 'analytics:', name, payload || {});
};

/*************************************************
 * DOM UTILITIES
 *************************************************/

function qs(root, sel) {
  return (root || document).querySelector(sel);
}

function qsa(root, sel) {
  return Array.prototype.slice.call((root || document).querySelectorAll(sel));
}

function setHidden(el, hidden) {
  if (!el) return;
  if (hidden) {
    el.hidden = true;
    el.setAttribute('aria-hidden', 'true');
  } else {
    el.hidden = false;
    el.removeAttribute('aria-hidden');
  }
}

function escapeHtml(str) {
  return String(str || '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}

function addClass(el, className) {
  if (el && className) el.classList.add(className);
}

function removeClass(el, className) {
  if (el && className) el.classList.remove(className);
}

function hasClass(el, className) {
  return el && el.classList && el.classList.contains(className);
}

/*************************************************
 * ENUMS & CONSTANTS
 *************************************************/

var DEMO_STATES = {
  IDLE: 'idle',
  CHAT_ACTIVE: 'chat_active',
  READY_FOR_VOICE: 'ready_for_voice',
  VOICE_CONNECTING: 'voice_connecting',
  VOICE_LIVE: 'voice_live',
  VOICE_SUMMARY: 'voice_summary',
  VOICE_ERROR: 'voice_error',
};

var DEFAULT_INDUSTRY = 'dental';

// Typewriter suggestions per industry
var INDUSTRY_SUGGESTIONS = {
  dental: [
    '"Hi, I\'m a new patient. Do you have any openings this week for a cleaning?"',
    '"Do you take Delta Dental and what will my copay be for whitening?"',
    '"Can I book a consultation for Invisalign and get an estimate?"',
    '"What\'s your soonest appointment for a toothache? It\'s pretty urgent."',
    '"Do you offer payment plans for bigger treatments like implants?"',
  ],
  hvac: [
    '"Hi, my AC just stopped working and it\'s 95 out. How soon can you send someone?"',
    '"Do you do 24/7 emergency service and what does it usually cost?"',
    '"Can you give me a ballpark price to replace a 3-ton AC unit?"',
    '"Our heat went out — do you have availability today or tomorrow?"',
    '"If I book maintenance, do you offer any membership or tune-up plans?"',
  ],
  law: [
    '"I was in a car accident last week. Do you offer free consultations?"',
    '"I just got a DUI — can I talk to an attorney today?"',
    '"Do I pay anything upfront, or do you only get paid if you win?"',
    '"How long do I have to file a personal injury claim?"',
    '"Can you tell me if my case is worth pursuing before I come in?"',
  ],
  legal: [
    '"I was in a car accident last week. Do you offer free consultations?"',
    '"I just got a DUI — can I talk to an attorney today?"',
    '"Do I pay anything upfront, or do you only get paid if you win?"',
    '"How long do I have to file a personal injury claim?"',
    '"Can you tell me if my case is worth pursuing before I come in?"',
  ],
  plumbing: [
    '"I have a burst pipe in my basement — how fast can you get here?"',
    '"Do you charge extra for weekend or after-hours emergencies?"',
    '"Can you give me a rough estimate to replace a water heater?"',
    '"We have slow drains all over the house — do you do whole-home inspections?"',
    '"Do you offer any maintenance plans to help prevent emergencies?"',
  ],
  medspa: [
    '"I\'m interested in Botox — what do you charge per unit?"',
    '"Do you have any openings for facials this week?"',
    '"Can you recommend treatments for acne scars or texture?"',
    '"Do you offer memberships or packages for regular treatments?"',
    '"Is there any downtime after your most popular procedures?"',
  ],
  pest: [
    '"I think we have termites — can you do an inspection and quote?"',
    '"Do you offer same-day service for ants in the kitchen?"',
    '"How much is a quarterly pest control plan for a 3-bedroom house?"',
    '"Are your treatments safe for pets and kids?"',
    '"Do you guarantee your bed bug treatments?"',
  ],
  default: [
    '"Can you show me how you\'d handle a new caller asking about pricing?"',
    '"If someone calls after hours, can you still capture them and book something?"',
    '"How would you respond if a lead asks about discounts or cheaper options?"',
    '"Can you qualify a caller and send the details straight into my CRM?"',
    '"What would you say to recover a lead that ghosted after the first call?"',
  ],
};

/*************************************************
 * INTERNAL STATE
 *************************************************/

var currentState = DEMO_STATES.IDLE;
var selectedIndustry = DEFAULT_INDUSTRY;
var chatSessionId = null;
var chatHistory = [];
var lastROIFromChat = null;
var voiceCallId = null;
var liveCallSeconds = 0;
var liveCallTimerId = null;

// Transcript state
var voiceTranscript = [];

// Unified session snapshot
var demoSession = null;

// Typewriter state
var chatSuggestEl;
var chatSuggestTextEl;
var typewriterTimeoutId = null;
var emmaSpeakingTimeoutId = null;
var typewriterSuggestionIndex = 0;
var typewriterCharIndex = 0;
var typewriterCurrentSet = [];

// DOM refs (will be populated by cacheDomRefs)
var sectionEl;
var bgWrapEl;
var voiceBgInstance;

// Header / proof
var proofContainerEl;

// Chat DOM
var chatWidgetEl;
var chatMessagesEl;
var chatIndustryButtons;
var chatInputEl;
var chatSendBtnEl;
var chatSystemNextEl;
var chatStartDemoBannerEl;
var chatAvatarEl;

// Modal DOM
var modalOverlayEl;
var modalFormEl;
var modalContactMethodRadios;
var modalPhoneGroupEl;
var modalEmailGroupEl;
var modalPhoneInputEl;
var modalEmailInputEl;
var modalFirstNameInputEl;

// Console DOM
var consoleEl;
var consoleStepsEls;
var consoleStatusTextEl;
var consoleTimerEl;
var consoleDecisionsEl;
var consoleTranscriptEl;
var consoleTranscriptBodyEl;
var consoleSummaryEl;
var consoleSummaryBodyEl;
var consolePrimaryCtaEl;
var consoleSecondaryCtaEl;
var consoleTestAnotherEl;
var consoleScenarioTextEl;

// Voice overlay DOM
var voiceOverlayEl;
var voiceStatusTextEl;
var voiceWaveCanvas;
var voiceWaveCtx;
var voiceWaveAnimId = null;
var voiceWaveState = 'idle';
var voiceEndBtnEl;

// Demo complete recap card
var completeCardEl;
var completeIndustryEl;
var completeAtRiskEl;
var completeRecoveredEl;
var completeRoiEl;
var completeTierNameEl;
var completeTierPriceEl;
var completeTierTaglineEl;
var completePrimaryCtaEl;
var completeSecondaryCtaEl;

// Decision tree
var currentReasoningTree = [];

// Pointer tracking for parallax
var pointerState = { x: 0, y: 0, targetX: 0, targetY: 0 };

// Parallax internal state
var parallaxRAF = null;
var parallaxEnabled = true;
var parallaxTargetX = 0;
var parallaxTargetY = 0;
var parallaxCurrentX = 0;
var parallaxCurrentY = 0;

// Morph state tracking
var isMorphing = false;
var isExplosionActive = false;

// Click timing for double-click detection
var lastClickTime = 0;
var DOUBLE_CLICK_THRESHOLD = 350;

// Performance monitoring
var performanceMonitorEl = null;
var fpsHistory = [];

/*************************************************
 * SESSION HELPERS
 *************************************************/

function generateSessionId() {
  return 'demo_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8);
}

function createInitialDemoSession() {
  return {
    id: chatSessionId,
    industry: selectedIndustry,
    state: currentState,
    startedAt: null,
    finishedAt: null,
    chatHistory: chatHistory,
    voiceTranscript: voiceTranscript,
    roiContext: null,
    reasoningSteps: [],
  };
}

function updateDemoSessionState(newState) {
  if (!demoSession) return;

  demoSession.state = newState;
  demoSession.industry = selectedIndustry;
  demoSession.id = chatSessionId;

  if (!demoSession.startedAt && newState === DEMO_STATES.CHAT_ACTIVE) {
    demoSession.startedAt = new Date().toISOString();
  }

  if (
    !demoSession.finishedAt &&
    (newState === DEMO_STATES.VOICE_SUMMARY ||
      newState === DEMO_STATES.VOICE_ERROR)
  ) {
    demoSession.finishedAt = new Date().toISOString();
  }
}

function emitDemoStateChange(newState) {
  try {
    window.dispatchEvent(
      new CustomEvent('sw:demoStateChange', {
        detail: {
          state: newState,
          industry: selectedIndustry,
          sessionId: chatSessionId,
        },
      })
    );
  } catch (e) {
    debugLog('demo', 'emitDemoStateChange failed', e);
  }
}

/*************************************************
 * INDUSTRY BUS HELPERS
 *************************************************/

var CANON_KEYS = ['general', 'dental', 'hvac', 'legal', 'medspa', 'plumbing', 'pest'];

function normalizeCanonIndustry(val) {
  if (!val) return null;
  val = String(val).toLowerCase().trim();
  if (val === 'law') return 'legal';
  if (val === 'pestcontrol' || val === 'pest control') return 'pest';
  return CANON_KEYS.indexOf(val) !== -1 ? val : null;
}

function canonFromLiveKey(liveKey) {
  var k = String(liveKey || '').toLowerCase();
  if (k === 'law') return 'legal';
  if (k === 'pest') return 'pest';
  if (CANON_KEYS.indexOf(k) !== -1) return k;
  return null;
}

function liveFromCanon(canonKey) {
  var k = normalizeCanonIndustry(canonKey);
  if (!k) return null;
  if (k === 'legal') return 'law';
  if (k === 'pest') return 'pest';
  if (k === 'general') return null;
  return k;
}

function initIndustryBusBridge() {
  try {
    if (
      !window.ShockwaveIndustryBus ||
      typeof window.ShockwaveIndustryBus.subscribe !== 'function'
    ) {
      return;
    }

    window.ShockwaveIndustryBus.subscribe(function(canonKey, source) {
      if (!canonKey || source === 'demo') return;
      var liveKey = liveFromCanon(canonKey);
      if (!liveKey) return;

      if (
        window.ShockwaveLiveDemo &&
        typeof window.ShockwaveLiveDemo.setIndustry === 'function'
      ) {
        window.ShockwaveLiveDemo.setIndustry(liveKey);
      } else {
        setIndustryInternal(liveKey);
      }
    });
  } catch (e) {
    debugLog('demo', 'IndustryBus subscription failed', e);
  }
}

/*************************************************
 * ROI + TIER CONTEXT
 *************************************************/

function pickTierForRisk(monthlyAtRisk) {
  try {
    if (typeof swPickTierForRisk === 'function') {
      return swPickTierForRisk(monthlyAtRisk);
    }
  } catch (e) {
    debugLog('demo', 'swPickTierForRisk failed', e);
  }

  return {
    id: 'core',
    key: 'core',
    name: 'Shockwave AI',
    tagline: null,
    description: 'AI-powered revenue recovery tuned to your volume and complexity.',
    priceLabel: '$3,000–$4,000/mo',
  };
}

function estimateFallbackROI() {
  // ROI calculator
  try {
    var roiData = Core.getROIData ? Core.getROIData() : null;
    if (roiData) {
      if (typeof roiData.revenueAtRiskAnnual === 'number') {
        return roiData.revenueAtRiskAnnual / 12;
      }
      if (typeof roiData.totalValueDelivered === 'number') {
        return roiData.totalValueDelivered / 12;
      }
    }
  } catch (e) {
    debugLog('demo', 'fallback ROI using ROI data failed', e);
  }

  // Benchmarks per vertical
  try {
    if (
      typeof getTierRecoveryBenchmarks === 'function' &&
      typeof swGetTierPositioning === 'function'
    ) {
      var verticalKey = selectedIndustry === 'law' ? 'legal' : selectedIndustry;
      var bm = getTierRecoveryBenchmarks(verticalKey, 'core');
      var tierPos = swGetTierPositioning('core');
      if (
        bm &&
        typeof bm.typical === 'number' &&
        tierPos &&
        typeof tierPos.recoveryRate === 'number' &&
        tierPos.recoveryRate > 0
      ) {
        var recoveredMonthly = bm.typical;
        var atRisk = recoveredMonthly / tierPos.recoveryRate;
        if (isFinite(atRisk) && atRisk > 0) {
          return atRisk;
        }
      }
    }
  } catch (e) {
    debugLog('demo', 'fallback ROI from benchmarks failed', e);
  }

  // Hard-coded defaults
  var defaults = {
    dental: 8000,
    hvac: 12000,
    law: 15000,
    legal: 15000,
    plumbing: 7000,
    medspa: 9000,
    pest: 6000,
  };
  return defaults[selectedIndustry] || 5000;
}

function getConsoleROIContext() {
  var roiData = null;
  try {
    roiData = Core.getROIData ? Core.getROIData() : null;
  } catch (e) {
    debugLog('demo', 'Core.getROIData failed', e);
  }

  var source = 'fallback';
  var monthlyAtRisk = null;
  var monthlyRecovered = null;
  var recoveryRate = null;
  var roiPercent = null;

  // ROI calculator
  if (roiData && typeof roiData.revenueAtRiskAnnual === 'number') {
    monthlyAtRisk = roiData.revenueAtRiskAnnual / 12;

    if (typeof roiData.monthlyRecovered === 'number') {
      monthlyRecovered = roiData.monthlyRecovered;
    } else if (
      roiData.normalized &&
      typeof roiData.normalized.monthlyRecovered === 'number'
    ) {
      monthlyRecovered = roiData.normalized.monthlyRecovered;
    }

    if (typeof roiData.aiRecoveryRate === 'number') {
      recoveryRate = roiData.aiRecoveryRate;
    }

    if (typeof roiData.roiPercent === 'number') {
      roiPercent = roiData.roiPercent;
    } else if (
      roiData.normalized &&
      typeof roiData.normalized.roiPercent === 'number'
    ) {
      roiPercent = roiData.normalized.roiPercent;
    }

    source = 'roi_calculator';
  }

  // Chat-only estimate
  if (!monthlyAtRisk && lastROIFromChat && lastROIFromChat > 0) {
    monthlyAtRisk = lastROIFromChat;

    try {
      if (typeof swGetTierPositioning === 'function') {
        var baseTier = swGetTierPositioning('core');
        recoveryRate =
          baseTier && typeof baseTier.recoveryRate === 'number'
            ? baseTier.recoveryRate
            : 0.6;
      } else {
        recoveryRate = 0.6;
      }
    } catch (e) {
      recoveryRate = 0.6;
    }

    monthlyRecovered = monthlyAtRisk * (recoveryRate || 0.6);
    source = 'chat';
  }

  // Fallback
  if (!monthlyAtRisk) {
    monthlyAtRisk = estimateFallbackROI();

    try {
      if (typeof swGetTierPositioning === 'function') {
        var baseTier2 = swGetTierPositioning('core');
        recoveryRate =
          baseTier2 && typeof baseTier2.recoveryRate === 'number'
            ? baseTier2.recoveryRate
            : 0.6;
      } else {
        recoveryRate = 0.6;
      }
    } catch (e) {
      recoveryRate = 0.6;
    }

    monthlyRecovered = monthlyAtRisk * (recoveryRate || 0.6);
    source = 'fallback';
  }

  var tier = pickTierForRisk(monthlyAtRisk);

  var ctx = {
    monthlyAtRisk: monthlyAtRisk,
    monthlyRecovered: monthlyRecovered,
    recoveryRate: recoveryRate,
    roiPercent: roiPercent,
    tier: tier,
    source: source,
  };

  if (demoSession) {
    demoSession.roiContext = ctx;
  }

  return ctx;
}

/*************************************************
 * TEMPLATE MARKUP
 *************************************************/

function getLiveDemoTemplateHTML() {
  return '\
<section id="' + SECTION_ID + '" class="live-demo" data-live-demo-root aria-labelledby="live-demo-heading">\
  <div class="live-demo-bg-wrap">\
    <canvas id="particle-canvas" class="sw-particle-background"></canvas>\
\
    <div class="live-demo-inner">\
      \
      <!-- System Status Bar -->\
      <div class="live-demo-system-status" aria-label="Live AI system stats">\
        <div class="live-demo-system-left">\
          <span class="live-demo-status-dot"></span>\
          <span class="live-demo-status-text">AI Agent Online</span>\
        </div>\
        <span class="live-demo-status-divider">•</span>\
        <div class="live-demo-status-metric">\
          <strong><span data-sync-counter="leads_today">0</span></strong>\
          <span class="live-demo-status-label">leads captured today</span>\
        </div>\
        <span class="live-demo-status-divider">•</span>\
        <div class="live-demo-status-metric">\
          <span class="live-demo-status-label">Avg response:</span>\
          <strong><span data-sync-counter="avg_response_time">0.0</span>s</strong>\
        </div>\
      </div>\
\
      <!-- Header -->\
      <header class="live-demo-header">\
        <p class="eyebrow">🎤 LIVE RESPONSE AI / REVENUE AI DEMO</p>\
        <h2 id="live-demo-heading" class="live-demo-title">\
          Talk to Emma and See How Much Revenue You\'re Leaking.\
        </h2>\
        <p class="live-demo-subtitle">\
          Choose your industry, ask Emma real questions about your calls and no‑shows, and watch her\
          estimate how much Response AI or Revenue AI could recover for your business.\
        </p>\
        <p class="live-demo-subsubtitle">\
          This is the same engine we deploy for <strong>Response AI</strong> (core recovery)\
          and <strong>Revenue AI</strong> (multi‑channel growth) clients.\
        </p>\
\
        <!-- Trust Bar -->\
        <div class="live-demo-trust-strip">\
          <span>✅ Built for Dental, HVAC, Legal & Home Services</span>\
          <span>• Live Response AI / Revenue AI engine</span>\
          <span>• Designed for 5×+ ROI at your current volume</span>\
        </div>\
\
        <!-- ROI chip pulled from calculator -->\
        <p class="live-demo-roi-chip" data-sw-live-roi-chip hidden>\
          From your ROI calculator: <strong data-sw-live-roi-chip-value>$0/mo at risk</strong>\
        </p>\
\
        <p class="sw-demo-why-now">\
          In 2–3 minutes you\'ll see exactly how much you\'re leaving on the table —\
          and which Shockwave tier makes the most sense for your business.\
        </p>\
\
        <!-- Proof Bar -->\
        <div class="sw-live-demo-proof-container">\
          <div class="sw-live-proof-top">\
            <div class="sw-live-proof-label">Avg AI response</div>\
            <div class="sw-live-proof-top-value">\
              <span data-live-demo-avg-response>0.0</span>s\
            </div>\
          </div>\
\
          <div class="sw-live-proof-context">Live Portfolio Revenue</div>\
          <div class="sw-live-proof-bar" data-live-demo-proof-recovered>$0.0M</div>\
          <div class="sw-live-proof-footnote">\
            <span data-live-demo-client-count>0</span> active clients\
            <span class="bullet">·</span>\
            Dental, Med Spa, Legal & Home Services\
            <span class="bullet">·</span>\
            Last 90 days\
          </div>\
\
          <div class="sw-live-proof-secondary">\
            <div class="secondary-value" data-sync-counter="responses_sent">0</div>\
            <div class="secondary-label">Automated responses today</div>\
          </div>\
        </div>\
\
        <!-- Interaction hint -->\
        <div class="sw-demo-interaction-hint" data-sw-interaction-hint>\
          <span class="hint-icon">👆</span>\
          <span class="hint-text">Click background to see industry words • Double-click for explosion effect</span>\
        </div>\
\
      </header>\
\
      <!-- BODY: Mini steps + Emma Chat + Console -->\
      <div class="sw-demo-body">\
\
        <!-- Mini steps -->\
        <div class="sw-demo-mini-steps">\
          <span class="sw-demo-mini-step sw-demo-mini-step--active">1. Chat with Emma</span>\
          <span class="sw-demo-mini-step">2. (Optional) Voice call preview</span>\
        </div>\
\
        <!-- Emma Chat Widget -->\
        <section class="sw-demo-chat" data-sw-demo-chat>\
          <header class="sw-demo-chat-header">\
  <div class="sw-demo-chat-avatar" data-avatar-state="idle">\
    <div class="sw-chat-avatar-orbit">\
      <div class="sw-chat-avatar-core">\
        <svg class="sw-chat-avatar-glyph" viewBox="0 0 24 24" role="img" aria-label="Shockwave"><path d="M13 2L4 14h6l-2 8 12-14h-6l2-6z"></path></svg>\
        <span class="sw-chat-avatar-glow" aria-hidden="true"></span>\
      </div>\
    </div>\
    <span class="sw-chat-avatar-status-dot" aria-hidden="true"></span>\
    <span class="sw-sr-only">Emma, Shockwave AI Agent, online</span>\
  </div>\
  <div class="sw-demo-chat-meta">\
    <div class="sw-demo-chat-name">Emma · Shockwave AI Agent</div>\
    <div class="sw-demo-chat-status">Online • Replies in &lt;60s</div>\
  </div>\
</header>\
\
          <div class="sw-demo-chat-messages" data-sw-demo-chat-messages aria-live="polite">\
            <div class="sw-demo-chat-message sw-demo-chat-message--assistant">\
              <div class="sw-demo-chat-bubble">\
                Hi! I\'m Emma, Shockwave\'s AI agent.\
                I\'m the same brain we use for Response AI and Revenue AI clients to recover missed revenue\
                from calls, texts, and web leads.\
                <br><br>\
                <strong>First, which industry are you in?</strong> Then I\'ll ask a couple of quick questions\
                about your call volume so I can estimate how much you\'re leaving on the table.\
              </div>\
            </div>\
\
            <div class="sw-demo-chat-industry-select" data-sw-demo-chat-industry-select>\
              <button type="button" class="sw-demo-chip" data-sw-industry="dental">🦷 Dental</button>\
              <button type="button" class="sw-demo-chip" data-sw-industry="hvac">🏠 HVAC</button>\
              <button type="button" class="sw-demo-chip" data-sw-industry="law">⚖️ Law (DUI/PI)</button>\
              <button type="button" class="sw-demo-chip" data-sw-industry="plumbing">🔧 Plumbing</button>\
              <button type="button" class="sw-demo-chip" data-sw-industry="medspa">💆 MedSpa</button>\
              <button type="button" class="sw-demo-chip" data-sw-industry="pest">🐜 Pest Control</button>\
            </div>\
          </div>\
\
          <div class="sw-demo-chat-footer">\
            <input\
              type="text"\
              class="sw-demo-chat-input"\
              placeholder="Ask Emma a question about your calls, no-shows, or follow-up..."\
              data-sw-demo-chat-input\
            />\
            <button type="button" class="sw-demo-chat-send" data-sw-demo-chat-send>\
              Send\
            </button>\
          </div>\
\
          <!-- Typewriter suggestions -->\
          <div class="sw-demo-chat-suggest" data-sw-demo-chat-suggest>\
            <span class="sw-demo-chat-suggest-label">Try saying:</span>\
            <span class="sw-demo-chat-suggest-text" data-sw-demo-chat-suggest-text></span>\
          </div>\
\
          <div class="sw-demo-chat-next" data-sw-demo-chat-next>\
            👉 Next: Emma will estimate your monthly recovered revenue and offer a 60s voice preview.\
          </div>\
\
          <div class="sw-demo-chat-cta-banner" data-sw-demo-chat-cta-banner hidden>\
            <div class="sw-demo-chat-cta-text">\
              Ready to see how this would feel as your 24/7 front desk?\
              <strong>Emma can call you in ~60 seconds.</strong>\
            </div>\
            <button type="button" class="sw-demo-chat-cta-btn" data-sw-demo-start-voice>\
              Start Voice Preview →\
            </button>\
          </div>\
        </section>\
\
        <!-- Console -->\
        <section class="sw-demo-console" data-sw-demo-console hidden aria-label="Live AI call console">\
          <div class="sw-demo-console-header">\
            <div class="sw-demo-console-title-block">\
              <div class="sw-demo-console-title">Live Voice Preview</div>\
              <div class="sw-demo-console-scenario">\
                Scenario: <span data-sw-demo-console-scenario-text>Service inquiry</span>\
              </div>\
            </div>\
            <div class="sw-demo-console-steps" data-sw-demo-console-steps>\
              <span class="sw-step sw-step--active" data-step="connect">1. Connect</span>\
              <span class="sw-step" data-step="call">2. Calling</span>\
              <span class="sw-step" data-step="live">3. Live</span>\
              <span class="sw-step" data-step="summary">4. Summary</span>\
            </div>\
          </div>\
\
          <div class="sw-demo-console-body">\
            <div class="sw-demo-console-status">\
              <div class="sw-console-status-label" data-sw-demo-console-status-text>\
                Preparing your AI agent...\
              </div>\
              <div class="sw-console-timer">\
                <span>Call duration:</span>\
                <strong data-sw-demo-console-timer>0:00</strong>\
              </div>\
            </div>\
\
            <div class="sw-demo-console-decisions" data-sw-demo-console-decisions>\
              <div class="sw-console-decision" data-status="pending">\
                <span class="sw-console-decision-icon">○</span>\
                <span class="sw-console-decision-text">Understanding caller intent</span>\
              </div>\
              <div class="sw-console-decision" data-status="pending">\
                <span class="sw-console-decision-icon">○</span>\
                <span class="sw-console-decision-text">Extracting key details (value, timing, contact)</span>\
              </div>\
              <div class="sw-console-decision" data-status="pending">\
                <span class="sw-console-decision-icon">○</span>\
                <span class="sw-console-decision-text">Checking availability & business rules</span>\
              </div>\
              <div class="sw-console-decision" data-status="pending">\
                <span class="sw-console-decision-icon">○</span>\
                <span class="sw-console-decision-text">Generating natural response</span>\
              </div>\
            </div>\
\
            <!-- Transcript snapshot -->\
            <div class="sw-demo-console-transcript" data-sw-demo-console-transcript hidden>\
              <div class="sw-demo-console-transcript-title">Conversation snapshot</div>\
              <div class="sw-demo-console-transcript-body" data-sw-demo-console-transcript-body></div>\
            </div>\
\
            <div class="sw-demo-console-summary" data-sw-demo-console-summary hidden>\
              <h3>Here\'s what the AI captured from your call:</h3>\
              <div class="sw-demo-console-summary-body" data-sw-demo-console-summary-body></div>\
            </div>\
          </div>\
\
          <div class="sw-demo-console-footer">\
            <button type="button" class="sw-demo-console-primary" data-sw-demo-console-primary>\
              Book My Shockwave AI Strategy Call →\
            </button>\
            <button type="button" class="sw-demo-console-secondary" data-sw-demo-console-secondary>\
              See Response / Revenue AI Pricing & ROI →\
            </button>\
            <button type="button" class="sw-demo-console-ghost" data-sw-demo-console-test-another>\
              Test another industry\
            </button>\
          </div>\
        </section>\
\
        <!-- Demo Complete Recap Card -->\
        <section class="sw-demo-complete-card" data-sw-demo-complete hidden>\
          <div class="sw-demo-complete-inner">\
            <h3 class="sw-demo-complete-title">\
              You just saw how Shockwave would handle your leads.\
            </h3>\
            <p class="sw-demo-complete-sub">\
              Here\'s what that means for <span data-sw-complete-industry>your business</span>\
              based on your ROI numbers.\
            </p>\
\
            <div class="sw-demo-complete-stats">\
              <div class="sw-demo-complete-stat">\
                <div class="sw-complete-stat-label">Monthly revenue at risk</div>\
                <div class="sw-complete-stat-value" data-sw-complete-at-risk>$0</div>\
              </div>\
              <div class="sw-demo-complete-stat">\
                <div class="sw-complete-stat-label">Recoverable with AI</div>\
                <div class="sw-complete-stat-value" data-sw-complete-recovered>$0</div>\
              </div>\
              <div class="sw-demo-complete-stat">\
                <div class="sw-complete-stat-label">Projected ROI</div>\
                <div class="sw-complete-stat-value" data-sw-complete-roi>–</div>\
              </div>\
            </div>\
\
            <div class="sw-demo-complete-tier" data-sw-complete-tier>\
              <div class="sw-complete-tier-label">Recommended starting tier</div>\
              <div class="sw-complete-tier-main">\
                <span class="sw-complete-tier-name" data-sw-complete-tier-name>Response AI</span>\
                <span class="sw-complete-tier-price" data-sw-complete-tier-price>$3,000–$4,000/mo</span>\
              </div>\
              <div class="sw-complete-tier-tagline" data-sw-complete-tier-tagline></div>\
            </div>\
\
            <!-- Decision tree visualization -->\
            <div id="sw-decision-tree" class="sw-decision-tree"></div>\
\
            <div class="sw-demo-complete-ctas">\
              <button type="button" class="sw-demo-complete-primary" data-sw-complete-primary-cta>\
                Book My Shockwave Strategy Call →\
              </button>\
              <button type="button" class="sw-demo-complete-secondary" data-sw-complete-secondary-cta>\
                See Full Pricing & ROI Details →\
              </button>\
            </div>\
          </div>\
        </section>\
\
      </div>\
\
    </div>\
  </div>\
\
  <!-- Voice Bubble Overlay -->\
  <div class="sw-voice-overlay" data-sw-voice-overlay hidden>\
    <div class="sw-voice-overlay-inner">\
      <div class="sw-voice-bubble">\
        <div class="sw-voice-header">\
          <div class="sw-voice-avatar-block">\
            <div class="sw-voice-avatar"></div>\
            <div class="sw-voice-status">\
              <span class="sw-voice-status-dot"></span>\
              <span class="sw-voice-status-text" data-sw-voice-status-text>\
                Preparing your AI agent...\
              </span>\
            </div>\
          </div>\
          <div class="sw-voice-waveform-wrap">\
            <canvas id="sw-voice-wave" width="400" height="60"></canvas>\
          </div>\
        </div>\
\
        <div class="sw-voice-overlay-transcript" data-sw-voice-overlay-transcript>\
          <div class="sw-demo-console-transcript-line">\
            <span class="sw-demo-console-transcript-speaker">Emma:</span>\
            <span class="sw-demo-console-transcript-text">\
              I\'ll give you a quick preview of how I\'d handle your calls. Once you\'re on the line, tell me what type of calls you miss most and what an average job is worth.\
            </span>\
          </div>\
        </div>\
\
        <div class="sw-voice-controls">\
          <button type="button" class="sw-voice-end-btn" data-sw-voice-end-btn>\
            End Demo\
          </button>\
        </div>\
      </div>\
    </div>\
  </div>\
\
  <!-- Modal: Lead Capture -->\
  <div class="sw-demo-modal-overlay" data-sw-demo-modal-overlay hidden>\
    <div class="sw-demo-modal" role="dialog" aria-modal="true" aria-labelledby="sw-demo-modal-title">\
      <button type="button" class="sw-demo-modal-close" data-sw-demo-modal-close aria-label="Close demo form">×</button>\
\
      <div class="sw-demo-modal-icon">📞</div>\
      <h3 id="sw-demo-modal-title" class="sw-demo-modal-title">Get Your AI Agent Preview</h3>\
      <p class="sw-demo-modal-sub">\
        You can have Emma call you now or email you a short AI plan and ROI snapshot—no spam, no pressure.\
      </p>\
\
      <form class="sw-demo-modal-form" data-sw-demo-modal-form novalidate>\
        <div class="sw-demo-form-group">\
          <span class="sw-demo-form-label">How should Emma reach you?</span>\
          <div class="sw-demo-form-radio-row">\
            <label class="sw-demo-form-radio">\
              <input type="radio" name="swContactMethod" value="phone" checked />\
              <span>📞 Call Me Now</span>\
            </label>\
            <label class="sw-demo-form-radio">\
              <input type="radio" name="swContactMethod" value="email" />\
              <span>📧 Email Me a Custom AI Plan</span>\
            </label>\
          </div>\
        </div>\
\
        <div class="sw-demo-form-group" data-sw-demo-phone-group>\
          <label class="sw-demo-form-label" for="sw-demo-phone">Phone Number <span class="sw-demo-required" data-required-for="phone">*</span></label>\
          <input\
            type="tel"\
            id="sw-demo-phone"\
            class="sw-demo-form-input"\
            placeholder="+1 (555) 123-4567"\
            data-sw-demo-phone\
            required\
          />\
        </div>\
\
        <div class="sw-demo-form-group" data-sw-demo-email-group hidden>\
          <label class="sw-demo-form-label" for="sw-demo-email">Business Email <span class="sw-demo-required" data-required-for="email">*</span></label>\
          <input\
            type="email"\
            id="sw-demo-email"\
            class="sw-demo-form-input"\
            placeholder="you@company.com"\
            data-sw-demo-email\
          />\
          <p class="sw-demo-form-hint">\
            💡 Business emails get priority in the planning queue.\
          </p>\
        </div>\
\
        <div class="sw-demo-form-group">\
          <label class="sw-demo-form-label" for="sw-demo-firstname">First Name <span class="sw-demo-required">*</span></label>\
          <input\
            type="text"\
            id="sw-demo-firstname"\
            class="sw-demo-form-input"\
            placeholder="Alex"\
            data-sw-demo-firstname\
            required\
          />\
        </div>\
\
        <div class="sw-demo-trust-row">\
          <span>🔒 Secure & Private</span>\
          <span>• 📞 No Spam</span>\
          <span>• ⏱️ &lt;60s Response</span>\
        </div>\
\
        <button type="submit" class="sw-demo-modal-submit" data-sw-demo-modal-submit>\
          Start My Live Call →\
        </button>\
\
        <p class="sw-demo-modal-dismiss">\
          Not ready? <button type="button" data-sw-demo-modal-close class="sw-demo-modal-dismiss-link">Continue browsing</button>\
        </p>\
      </form>\
    </div>\
  </div>\
\
</section>\
';
}

/*************************************************
 * STATE MANAGEMENT
 *************************************************/

function setState(newState) {
  currentState = newState;

  // Mode state for CSS hooks
  if (sectionEl) {
    if (
      newState === DEMO_STATES.CHAT_ACTIVE ||
      newState === DEMO_STATES.READY_FOR_VOICE
    ) {
      sectionEl.setAttribute('data-demo-mode', 'chat');
    } else if (
      newState === DEMO_STATES.VOICE_CONNECTING ||
      newState === DEMO_STATES.VOICE_LIVE ||
      newState === DEMO_STATES.VOICE_SUMMARY
    ) {
      sectionEl.setAttribute('data-demo-mode', 'voice');
    } else {
      sectionEl.removeAttribute('data-demo-mode');
    }
  }

  switch (newState) {
    case DEMO_STATES.IDLE:
      break;
    case DEMO_STATES.CHAT_ACTIVE:
      break;
    case DEMO_STATES.READY_FOR_VOICE:
      if (chatStartDemoBannerEl) setHidden(chatStartDemoBannerEl, false);
      break;
    case DEMO_STATES.VOICE_CONNECTING:
      enterConsole();
      updateConsoleSteps('connect');
      setConsoleStatus('Preparing your AI agent...');
      startVoiceBackground();
      openVoiceOverlay();
      setVoiceOverlayStatus('Connecting your AI preview...', 'connecting');
      triggerParticleVoiceMode(true);
      break;
        case DEMO_STATES.VOICE_LIVE:
      updateConsoleSteps('live');
      setConsoleStatus(
        'You\'re now talking to the AI. Try asking about pricing, next available time, or what happens after-hours.'
      );
      startLiveCallTimer();
      simulateAIDecisions();
      setVoiceOverlayStatus('Emma is live. Talk like a real caller would.', 'ai');
      break;
    case DEMO_STATES.VOICE_SUMMARY:
      updateConsoleSteps('summary');
      stopVoiceBackground();
      stopLiveCallTimer();
      fillConsoleTranscript();
      fillConsoleSummary();
      renderDemoCompleteCard();
      closeVoiceOverlay();
      triggerParticleVoiceMode(false);
      // Trigger celebratory ring burst
      triggerCelebratoryRings();
      break;
      case DEMO_STATES.VOICE_ERROR:
      updateConsoleSteps(null);
      setConsoleStatus('We couldn\'t complete the call. Try again or book a strategy call.');
      stopVoiceBackground();
      stopLiveCallTimer();
      setVoiceOverlayStatus('We couldn\'t complete the call. Please try again.', 'idle');
      setTimeout(closeVoiceOverlay, 1500);
      triggerParticleVoiceMode(false);
      break;
  }

  updateDemoSessionState(newState);
  emitDemoStateChange(newState);

  trackEvent('live_demo_state_changed', {
    state: newState,
    industry: selectedIndustry,
  });

  debugLog('demo', 'State changed to:', newState);
}

/*************************************************
 * PARTICLE SYSTEM INTEGRATION HELPERS
 *************************************************/

/**
 * Get the enhanced particle system instance
 */
function getParticleSystem() {
  return window.enhancedParticleSystem || window.swParticleSystem || window.particleSystem || null;
}

/**
 * Trigger voice mode on particles
 */
function triggerParticleVoiceMode(active) {
  var ps = getParticleSystem();
  if (!ps) return;
  
  // The voice background will handle amplitude via events
  // Just ensure Emma reacts appropriately
  if (ps.emmaAvatar) {
    if (active) {
      ps.emmaAvatar.startSpeaking(0.4);
    } else {
      ps.emmaAvatar.stopSpeaking();
    }
  }
}

/**
 * Apply industry to particle system
 */
  
function applyIndustryToParticles(industryKey) {
  var ps = getParticleSystem();
  if (!ps) return;

  try {
    // 1) Apply visual preset (colors, motion, Emma tuning)
    if (typeof window.applyIndustryPreset === 'function') {
      window.applyIndustryPreset(ps, industryKey);
    } else if (typeof ps.applyIndustryPreset === 'function') {
      ps.applyIndustryPreset(industryKey);
    }

    // 2) If OrbitalFlow is active, route ICON morph to the RIGHT side only
    if (window.demoOrbitalFlow && typeof window.demoOrbitalFlow.setIndustry === 'function') {
      window.demoOrbitalFlow.setIndustry(industryKey);

      var icon = typeof window.mapIndustryToIconShape === 'function'
        ? window.mapIndustryToIconShape(industryKey)
        : industryKey;

      // RIGHT: drive OrbitalFlow icon lane
      if (typeof window.demoOrbitalFlow.morphIcon === 'function') {
        window.demoOrbitalFlow.morphIcon(icon);
      }

      // Broadcast for any other listeners
      window.dispatchEvent(new CustomEvent('sw:morphIcon', {
        detail: { icon: icon }
      }));

    } else {
      // 3) Legacy center morph ONLY when OrbitalFlow does not exist
      var iconShape = typeof window.mapIndustryToIconShape === 'function'
        ? window.mapIndustryToIconShape(industryKey)
        : industryKey;

      var morpher = window.morphEngine || window.particleMorpher;
      if (morpher && typeof morpher.morphToShape === 'function') {
        morpher.morphToShape(ps, iconShape, { duration: 1600, fluid: true });
      } else if (typeof ps.morphToShape === 'function') {
        ps.morphToShape(iconShape, 1600);
      }
    }

    debugLog('demo', 'Applied industry to particles:', industryKey);
  } catch (e) {
    debugLog('demo', 'applyIndustryToParticles error', e);
  }
}

/**
 * Handle background click for word morphing
 */
function handleBackgroundClick(e) {
  if (isClickOnUI(e.target)) return;
  
  var now = Date.now();
  var timeSinceLastClick = now - lastClickTime;
  lastClickTime = now;
  
  // Double-click for explosion
  if (timeSinceLastClick < DOUBLE_CLICK_THRESHOLD) {
    handleBackgroundDoubleClick(e);
    return;
  }
  
  // Single click triggers dual morph
  triggerDualMorph();
}

function triggerDualMorph() {
  if (!window.demoOrbitalFlow) {
    debugLog('demo', 'OrbitalFlow not available');
    return;
  }

  var flow = window.demoOrbitalFlow;
  
  // Get next word and icon
  var word = typeof flow.getNextWord === 'function' 
    ? flow.getNextWord() 
    : (typeof window.getNextWord === 'function' ? window.getNextWord(selectedIndustry) : 'GROW');
    
  var icon = typeof flow.getNextIcon === 'function'
    ? flow.getNextIcon()
    : (typeof window.mapIndustryToIconShape === 'function' ? window.mapIndustryToIconShape(selectedIndustry) : selectedIndustry);

  debugLog('demo', 'triggerDualMorph:', { word: word, icon: icon });

  // Trigger LEFT lane (word) immediately
  var wordSuccess = flow.morphWord(word);
  debugLog('demo', 'morphWord result:', wordSuccess);

  // Trigger RIGHT lane (icon) with slight delay for visual sequence
  setTimeout(function() {
    var iconSuccess = flow.morphIcon(icon);
    debugLog('demo', 'morphIcon result:', iconSuccess);
  }, 150);
}

/**
 * Morph to next word (left side only) - kept for compatibility
 */
function morphToNextWord() {
  triggerDualMorph();
}

/**
 * Handle double-click for explosion effect
 */
function handleBackgroundDoubleClick(e) {
  var ps = getParticleSystem();
  if (!ps) return;
  
  // Get click position in world space
  var rect = bgWrapEl.getBoundingClientRect();
  var ndcX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  var ndcY = -((e.clientY - rect.top) / rect.height) * 2 + 1;
  
  // Approximate world position
  var worldX = ndcX * 40;
  var worldY = ndcY * 25;
  
  triggerExplosion(worldX, worldY, 0);
}

/**
 * Check if click target is a UI element
 */
function isClickOnUI(target) {
  if (!target) return false;
  
  var uiSelectors = [
    '.sw-demo-chat',
    '.sw-demo-console',
    '.sw-demo-modal',
    '.sw-voice-overlay',
    '.sw-demo-complete-card',
    '.live-demo-header',
    '.live-demo-system-status',
    '.sw-live-demo-proof-container',
    '.sw-demo-mini-steps',
    'button',
    'input',
    'a'
  ];
  
  for (var i = 0; i < uiSelectors.length; i++) {
    if (target.closest(uiSelectors[i])) return true;
  }
  
  return false;
}

/**
 * Morph to next word for current industry
 */
function morphToNextWord() {
  var word = typeof window.getNextWord === 'function'
    ? window.getNextWord(selectedIndustry)
    : 'GROW';

  var iconKey = typeof window.mapIndustryToIconShape === 'function'
    ? window.mapIndustryToIconShape(selectedIndustry)
    : selectedIndustry;

  debugLog('demo', 'morphToNextWord called:', { word: word, icon: iconKey, hasOrbitalFlow: !!window.demoOrbitalFlow });

  // Check if OrbitalFlow exists (isEnabled defaults to true)
  if (window.demoOrbitalFlow) {
    // Word goes LEFT
    if (typeof window.demoOrbitalFlow.morphWord === 'function') {
      window.demoOrbitalFlow.morphWord(word);
      debugLog('demo', 'Called OrbitalFlow.morphWord:', word);
    }
    // Icon goes RIGHT  
    if (typeof window.demoOrbitalFlow.morphIcon === 'function') {
      window.demoOrbitalFlow.morphIcon(iconKey);
      debugLog('demo', 'Called OrbitalFlow.morphIcon:', iconKey);
    }
  } else {
    debugLog('demo', 'OrbitalFlow not available, using legacy morph');
    // Fallback to legacy center morph
    var ps = getParticleSystem();
    var morpher = window.morphEngine || window.particleMorpher;

    if (ps && morpher && typeof morpher.morphToWord === 'function') {
      morpher.morphToWord(ps, word.toUpperCase(), { duration: 1500, fluid: true });
    }
  }

  // Dispatch events for any listeners
  window.dispatchEvent(new CustomEvent('sw:morphWord', {
    detail: { word: word }
  }));
  window.dispatchEvent(new CustomEvent('sw:morphIcon', {
    detail: { icon: iconKey }
  }));

  debugLog('demo', 'morphToNextWord complete');
}

/**
 * Trigger explosion effect
 * Delegates to EnhancedParticleSystem.triggerExplosion to keep logic in one place
 */
function triggerExplosion(x, y, z) {
  var ps = getParticleSystem();
  if (!ps || typeof ps.triggerExplosion !== 'function') return;

  isExplosionActive = true;

  // Normalize args
  var ex = typeof x === 'number' ? x : 0;
  var ey = typeof y === 'number' ? y : 0;
  var ez = typeof z === 'number' ? z : 0;

  ps.triggerExplosion(ex, ey, ez);

  debugLog('demo', 'Explosion triggered at:', ex, ey, ez);

  trackEvent('live_demo_explosion', {
    industry: selectedIndustry
  });

  // Let the particle system clear its own uniforms/state;
  // we just reset our local flag slightly after its duration.
  setTimeout(function() {
    isExplosionActive = false;
  }, 2000);
}

/**
 * Show temporary morph indicator badge
 */
function showMorphIndicator(shapeName) {
  // Find or create indicator
  var indicator = document.querySelector('.sw-morph-indicator');
  
  if (!indicator) {
    indicator = document.createElement('div');
    indicator.className = 'sw-morph-indicator';
    
    var container = document.querySelector('.live-demo-bg-wrap');
    if (container) {
      container.appendChild(indicator);
    }
  }
  
  // Shape icons
  var shapeIcons = {
    'tooth': '🦷',
    'dental': '🦷',
    'thermostat': '🌡️',
    'hvac': '🌡️',
    'gavel': '⚖️',
    'legal': '⚖️',
    'law': '⚖️',
    'wrench': '🔧',
    'plumbing': '🔧',
    'sparkle': '✨',
    'medspa': '✨',
    'shield': '🛡️',
    'pest': '🛡️'
  };
  
  var icon = shapeIcons[shapeName.toLowerCase()] || '🔄';
  var name = shapeName.charAt(0).toUpperCase() + shapeName.slice(1);
  
  indicator.innerHTML = '<span class="shape-icon">' + icon + '</span>' + name;
  indicator.classList.add('visible');
  
  // Hide after 2 seconds
  setTimeout(function() {
    indicator.classList.remove('visible');
  }, 2000);
}

/*************************************************
 * INITIALIZATION
 *************************************************/

function initLiveDemoSection() {
  // Prevent double-init if script is included twice or navigation reuses the page
  if (window.__SW_LIVE_DEMO_INITED__) {
    debugLog('demo', 'initLiveDemoSection called but already initialized, skipping');
    return;
  }
  window.__SW_LIVE_DEMO_INITED__ = true;

  // Root container
  var root =
    document.getElementById(SECTION_ID) ||
    document.querySelector('[data-live-demo-root]');

  if (!root) {
    root = document.createElement('div');
    document.body.appendChild(root);
  }

  root.innerHTML = getLiveDemoTemplateHTML();

  sectionEl = qs(root, '[data-live-demo-root]') || root;
  bgWrapEl = qs(sectionEl, '.live-demo-bg-wrap');
  proofContainerEl = qs(sectionEl, '.sw-live-demo-proof-container');

  // Voice-reactive background
  if (bgWrapEl && Core.createVoiceBackground) {
    voiceBgInstance = Core.createVoiceBackground(bgWrapEl);
  }

  // Proof bar engine
  if (Core.updateProofBarFromCounters) {
    try {
      Core.updateProofBarFromCounters();
    } catch (e) {
      debugLog('demo', 'proof bar update failed', e);
    }
  }
  if (Core.initProofObserver) {
    try {
      Core.initProofObserver();
    } catch (e) {
      debugLog('demo', 'proof observer failed', e);
    }
  }

  cacheDomRefs();
  bindEvents();
  initPointerTracking();
  initIndustryBusBridge();

  chatSessionId = generateSessionId();
  demoSession = createInitialDemoSession();

  if (sectionEl) {
    sectionEl.setAttribute('data-demo-mode', 'chat');
    sectionEl.setAttribute('data-industry', selectedIndustry);
  }

  updateConsoleScenario();
  setState(DEMO_STATES.CHAT_ACTIVE);
  startTypewriterForIndustry(null);
  updateHeroROIChip();

  // Wait for particle system to be ready, then apply initial industry
  waitForParticleSystem(function(ps) {
    applyIndustryToParticles(selectedIndustry);
  });

  // Initialize enhancements after a short delay
  setTimeout(initEnhancements, 500);

  trackEvent('live_demo_section_viewed', {
    section: 'live_demo',
    timestamp: new Date().toISOString(),
  });

  debugLog('demo', 'Live demo section initialized');
}

/**
 * Wait for particle system to be ready
 */
function waitForParticleSystem(callback, maxAttempts) {
  maxAttempts = maxAttempts || 50;
  var attempts = 0;
  
  var check = function() {
    attempts++;
    var ps = getParticleSystem();
    
    if (ps && ps.particles) {
      callback(ps);
    } else if (attempts < maxAttempts) {
      setTimeout(check, 100);
    } else {
      debugLog('demo', 'Particle system not available after waiting');
    }
  };
  
  check();
}

// Initialize on DOM ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initLiveDemoSection);
} else {
  initLiveDemoSection();
}

/*************************************************
 * DOM REFS & EVENT BINDING
 *************************************************/

function cacheDomRefs() {
  // Chat
  chatWidgetEl = qs(sectionEl, '[data-sw-demo-chat]');
  chatMessagesEl = qs(sectionEl, '[data-sw-demo-chat-messages]');
  chatIndustryButtons = qsa(sectionEl, '[data-sw-industry]');
  chatInputEl = qs(sectionEl, '[data-sw-demo-chat-input]');
  chatSendBtnEl = qs(sectionEl, '[data-sw-demo-chat-send]');
  chatSystemNextEl = qs(sectionEl, '[data-sw-demo-chat-next]');
  chatStartDemoBannerEl = qs(sectionEl, '[data-sw-demo-chat-cta-banner]');
  chatAvatarEl = qs(sectionEl, '.sw-demo-chat-avatar');

  // Typewriter
  chatSuggestEl = qs(sectionEl, '[data-sw-demo-chat-suggest]');
  chatSuggestTextEl = qs(sectionEl, '[data-sw-demo-chat-suggest-text]');

  // Modal
  modalOverlayEl = qs(sectionEl, '[data-sw-demo-modal-overlay]');
  modalFormEl = qs(sectionEl, '[data-sw-demo-modal-form]');
  modalContactMethodRadios = qsa(sectionEl, 'input[name="swContactMethod"]');
  modalPhoneGroupEl = qs(sectionEl, '[data-sw-demo-phone-group]');
  modalEmailGroupEl = qs(sectionEl, '[data-sw-demo-email-group]');
  modalPhoneInputEl = qs(sectionEl, '[data-sw-demo-phone]');
  modalEmailInputEl = qs(sectionEl, '[data-sw-demo-email]');
  modalFirstNameInputEl = qs(sectionEl, '[data-sw-demo-firstname]');

  // Console
  consoleEl = qs(sectionEl, '[data-sw-demo-console]');
  consoleStepsEls = qsa(sectionEl, '[data-sw-demo-console-steps] .sw-step');
  consoleStatusTextEl = qs(sectionEl, '[data-sw-demo-console-status-text]');
  consoleTimerEl = qs(sectionEl, '[data-sw-demo-console-timer]');
  consoleDecisionsEl = qs(sectionEl, '[data-sw-demo-console-decisions]');
  consoleTranscriptEl = qs(sectionEl, '[data-sw-demo-console-transcript]');
  consoleTranscriptBodyEl = qs(sectionEl, '[data-sw-demo-console-transcript-body]');
  consoleSummaryEl = qs(sectionEl, '[data-sw-demo-console-summary]');
  consoleSummaryBodyEl = qs(sectionEl, '[data-sw-demo-console-summary-body]');
  consolePrimaryCtaEl = qs(sectionEl, '[data-sw-demo-console-primary]');
  consoleSecondaryCtaEl = qs(sectionEl, '[data-sw-demo-console-secondary]');
  consoleTestAnotherEl = qs(sectionEl, '[data-sw-demo-console-test-another]');
  consoleScenarioTextEl = qs(sectionEl, '[data-sw-demo-console-scenario-text]');

  // Voice overlay
  voiceOverlayEl = qs(sectionEl, '[data-sw-voice-overlay]');
  voiceStatusTextEl = qs(sectionEl, '[data-sw-voice-status-text]');
  voiceWaveCanvas = document.getElementById('sw-voice-wave');
  voiceEndBtnEl = qs(sectionEl, '[data-sw-voice-end-btn]');

  // Demo complete recap
  completeCardEl = qs(sectionEl, '[data-sw-demo-complete]');
  completeIndustryEl = qs(sectionEl, '[data-sw-complete-industry]');
  completeAtRiskEl = qs(sectionEl, '[data-sw-complete-at-risk]');
  completeRecoveredEl = qs(sectionEl, '[data-sw-complete-recovered]');
  completeRoiEl = qs(sectionEl, '[data-sw-complete-roi]');
  completeTierNameEl = qs(sectionEl, '[data-sw-complete-tier-name]');
  completeTierPriceEl = qs(sectionEl, '[data-sw-complete-tier-price]');
  completeTierTaglineEl = qs(sectionEl, '[data-sw-complete-tier-tagline]');
  completePrimaryCtaEl = qs(sectionEl, '[data-sw-complete-primary-cta]');
  completeSecondaryCtaEl = qs(sectionEl, '[data-sw-complete-secondary-cta]');
}

function bindEvents() {
  // Industry selection
  if (chatIndustryButtons && chatIndustryButtons.length) {
    chatIndustryButtons.forEach(function(btn) {
      btn.addEventListener('click', function() {
        var key = btn.getAttribute('data-sw-industry');
        onIndustrySelected(key);
      });
    });
  }

        // Chat send with debouncing
  if (chatSendBtnEl && chatInputEl) {
    var lastChatSendTime = 0;
    var CHAT_DEBOUNCE_MS = 1000; // 1 second between sends
    var isSendingChat = false;

    var performChatSend = function() {
      var now = Date.now();
      
      // Debounce check
      if (now - lastChatSendTime < CHAT_DEBOUNCE_MS) {
        debugLog('demo', 'Chat send debounced, too soon');
        return;
      }
      
      // Prevent double-sends while processing
      if (isSendingChat) {
        debugLog('demo', 'Chat send blocked, already sending');
        return;
      }
      
      var text = (chatInputEl.value || '').trim();
      if (!text) return;
      
      // Update state
      lastChatSendTime = now;
      isSendingChat = true;
      
      // Disable button temporarily
      chatSendBtnEl.disabled = true;
      chatSendBtnEl.textContent = '...';
      
      // Send message
      handleUserMessage(text);
      chatInputEl.value = '';
      
      // Re-enable after debounce period
      setTimeout(function() {
        isSendingChat = false;
        chatSendBtnEl.disabled = false;
        chatSendBtnEl.textContent = 'Send';
      }, CHAT_DEBOUNCE_MS);
    };

    chatSendBtnEl.addEventListener('click', performChatSend);

    chatInputEl.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        performChatSend();
      }
    });

    chatInputEl.addEventListener('focus', function() {
      stopTypewriter();
    });
    chatInputEl.addEventListener('blur', function() {
      startTypewriterForIndustry(selectedIndustry);
    });
  }


  // Start voice preview
  var startVoiceBtn = qs(sectionEl, '[data-sw-demo-start-voice]');
  if (startVoiceBtn) {
    startVoiceBtn.addEventListener('click', function() {
      openModal();
      trackEvent('live_demo_voice_cta_clicked', {
        source: 'chat_banner',
        industry: selectedIndustry,
      });
    });
  }

  // Modal contact method
  if (modalContactMethodRadios && modalContactMethodRadios.length) {
    modalContactMethodRadios.forEach(function(radio) {
      radio.addEventListener('change', onContactMethodChange);
    });
  }

  // Modal submit
  if (modalFormEl) {
    modalFormEl.addEventListener('submit', onModalSubmit);
  }

  // Modal close
  if (modalOverlayEl) {
    var closeAll = function(e) {
      e.preventDefault();
      closeModal();
    };
    qsa(sectionEl, '[data-sw-demo-modal-close]').forEach(function(el) {
      el.addEventListener('click', closeAll);
    });
    modalOverlayEl.addEventListener('click', function(e) {
      if (e.target === modalOverlayEl) {
        closeModal();
      }
    });
  }

  // Console CTAs
  if (consolePrimaryCtaEl) {
    consolePrimaryCtaEl.addEventListener('click', function() {
      trackEvent('live_demo_console_cta', {
        type: 'primary_rollout',
        industry: selectedIndustry,
      });
      navigateToBooking();
    });
  }

  if (consoleSecondaryCtaEl) {
    consoleSecondaryCtaEl.addEventListener('click', function() {
      trackEvent('live_demo_console_cta', {
        type: 'secondary_pricing',
        industry: selectedIndustry,
      });
      navigateToPricingOrROI();
    });
  }

  if (consoleTestAnotherEl) {
    consoleTestAnotherEl.addEventListener('click', function() {
      trackEvent('live_demo_console_cta', {
        type: 'test_another',
        industry: selectedIndustry,
      });
      resetDemoState();
    });
  }

  // Voice overlay end button
  if (voiceEndBtnEl) {
    voiceEndBtnEl.addEventListener('click', function() {
      trackEvent('live_demo_voice_overlay_end_clicked', {
        state: currentState,
        industry: selectedIndustry,
      });
      if (
        currentState === DEMO_STATES.VOICE_CONNECTING ||
        currentState === DEMO_STATES.VOICE_LIVE
      ) {
        setState(DEMO_STATES.VOICE_SUMMARY);
      } else {
        closeVoiceOverlay();
      }
    });
  }

  // Background click for word morph / explosion
  if (bgWrapEl) {
    bgWrapEl.addEventListener('click', handleBackgroundClick);
  }

  // Voice transcript events
  window.addEventListener('sw:voiceTranscript', onVoiceTranscriptEvent);

  // Voice status events
  window.addEventListener('sw:voiceStatus', function(e) {
    var detail = (e && e.detail) || {};
    if (!detail || !detail.status) return;
    if (detail.status === 'ended' && currentState === DEMO_STATES.VOICE_LIVE) {
      setState(DEMO_STATES.VOICE_SUMMARY);
    }
    if (detail.status === 'error') {
      setState(DEMO_STATES.VOICE_ERROR);
    }
  });

  // Voice amplitude events
  window.addEventListener('voiceAmplitude', handleVoiceAmplitude);
  window.addEventListener('sw:voiceAmplitude', handleVoiceAmplitude);

  // Complete card CTAs
  if (completePrimaryCtaEl) {
    completePrimaryCtaEl.addEventListener('click', function() {
      trackEvent('live_demo_complete_cta', {
        type: 'primary',
        industry: selectedIndustry
      });
      navigateToBooking();
    });
  }

  if (completeSecondaryCtaEl) {
    completeSecondaryCtaEl.addEventListener('click', function() {
      trackEvent('live_demo_complete_cta', {
        type: 'secondary',
        industry: selectedIndustry
      });
      navigateToPricingOrROI();
    });
  }
}

/**
 * Handle voice amplitude events
 */
function handleVoiceAmplitude(e) {
  var amplitude = (e.detail && e.detail.amplitude) || 0;
  
  // Forward to enhanced particle system
  var ps = getParticleSystem();
  if (ps && typeof ps.setVoiceAmplitude === 'function') {
    ps.setVoiceAmplitude(amplitude);
  }
  
  // Update section attribute for CSS hooks
  if (sectionEl) {
    sectionEl.setAttribute('data-voice-active', amplitude > 0.1 ? 'true' : 'false');
  }
}

/*************************************************
 * POINTER TRACKING FOR PARALLAX
 *************************************************/

function initPointerTracking() {
  if (!sectionEl) return;

  // Check for reduced motion preference
  try {
    var mq = window.matchMedia
      ? window.matchMedia('(prefers-reduced-motion: reduce)')
      : null;
    if (mq && mq.matches) {
      parallaxEnabled = false;
      return;
    }
  } catch (e) {
    // ignore
  }

  parallaxEnabled = true;

  // Mouse move handler
  sectionEl.addEventListener('mousemove', function(e) {
    if (!parallaxEnabled) return;
    
    var rect = sectionEl.getBoundingClientRect();
    if (!rect.width || !rect.height) return;

    // Normalized -1 to 1
    var nx = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    var ny = -((e.clientY - rect.top) / rect.height) * 2 + 1;

    pointerState.targetX = nx;
    pointerState.targetY = ny;

    // Update CSS custom properties for gradient parallax
    parallaxTargetX = nx * 40;
    parallaxTargetY = ny * 30;

    if (!parallaxRAF) {
      parallaxRAF = requestAnimationFrame(updateParallax);
    }

    // Update particle system pointer
    updateParticlePointer(nx, ny);
  });

  // Mouse leave - reset
  sectionEl.addEventListener('mouseleave', function() {
    pointerState.targetX = 0;
    pointerState.targetY = 0;
    parallaxTargetX = 0;
    parallaxTargetY = 0;
    updateParticlePointer(0, 0);
  });
}

function updateParallax() {
  if (!sectionEl) {
    parallaxRAF = null;
    return;
  }

  parallaxCurrentX += (parallaxTargetX - parallaxCurrentX) * 0.08;
  parallaxCurrentY += (parallaxTargetY - parallaxCurrentY) * 0.08;

  sectionEl.style.setProperty('--ld-parallax-x', parallaxCurrentX.toFixed(1) + 'px');
  sectionEl.style.setProperty('--ld-parallax-y', parallaxCurrentY.toFixed(1) + 'px');

  var dx = parallaxTargetX - parallaxCurrentX;
  var dy = parallaxTargetY - parallaxCurrentY;
  var dist = Math.sqrt(dx * dx + dy * dy);

  if (dist > 0.2) {
    parallaxRAF = requestAnimationFrame(updateParallax);
  } else {
    parallaxRAF = null;
  }
}

function updateParticlePointer(x, y) {
  var ps = getParticleSystem();
  if (!ps) return;

  // Store pointer on particle system
  if (!ps.pointer) {
    ps.pointer = { x: 0, y: 0 };
  }
  ps.pointer.x = x;
  ps.pointer.y = y;

  // Update shader uniforms if available
  if (ps.particleMaterial && ps.particleMaterial.uniforms) {
    if (ps.particleMaterial.uniforms.uPointer) {
      ps.particleMaterial.uniforms.uPointer.value.set(x, y);
    }
  }

  // Update explosion ring system pointer for tilt
  if (ps.ringSystem && typeof ps.ringSystem.setPointer === 'function') {
    ps.ringSystem.setPointer(x, y);
  }

  // Update hero rings parallax (Phase 5)
  if (window.demoHeroRings && typeof window.demoHeroRings.setParallax === 'function') {
    window.demoHeroRings.setParallax(x * 0.6, -y * 0.6);
  }
}

/*************************************************
 * TYPEWRITER SUGGESTIONS
 *************************************************/

function startTypewriterForIndustry(industryKey) {
  if (!chatSuggestEl || !chatSuggestTextEl) return;

  stopTypewriter();

  var key =
    industryKey && INDUSTRY_SUGGESTIONS[industryKey]
      ? industryKey
      : 'default';

  typewriterCurrentSet =
    INDUSTRY_SUGGESTIONS[key] || INDUSTRY_SUGGESTIONS.default;
  if (!typewriterCurrentSet.length) return;

  typewriterSuggestionIndex = 0;
  typewriterCharIndex = 0;

  runTypewriterFrame();
}

function stopTypewriter() {
  if (typewriterTimeoutId) {
    clearTimeout(typewriterTimeoutId);
    typewriterTimeoutId = null;
  }
}

function runTypewriterFrame() {
  if (!chatSuggestTextEl || !typewriterCurrentSet.length) return;

  var full = typewriterCurrentSet[typewriterSuggestionIndex] || '';
  var isDoneTyping = typewriterCharIndex > full.length;

  if (!isDoneTyping) {
    chatSuggestTextEl.textContent = full.slice(0, typewriterCharIndex);
    typewriterCharIndex += 1;
    typewriterTimeoutId = setTimeout(runTypewriterFrame, 50);
    return;
  }

  typewriterTimeoutId = setTimeout(function() {
    chatSuggestTextEl.textContent = '';
    typewriterCharIndex = 0;
    typewriterSuggestionIndex =
      (typewriterSuggestionIndex + 1) % typewriterCurrentSet.length;
    typewriterTimeoutId = setTimeout(runTypewriterFrame, 300);
  }, 1600);
}

/*************************************************
 * CHAT LOGIC
 *************************************************/
function setChatAvatarState(state) {
  if (!chatAvatarEl) return;
  chatAvatarEl.setAttribute('data-avatar-state', state);
}

function indicateEmmaSpeaking() {
  setChatAvatarState('speaking');
  if (emmaSpeakingTimeoutId) clearTimeout(emmaSpeakingTimeoutId);
  emmaSpeakingTimeoutId = setTimeout(function() {
    setChatAvatarState('idle');
  }, 1600);
}

function indicateEmmaListening() {
  if (!chatAvatarEl) return;
  var current = chatAvatarEl.getAttribute('data-avatar-state');
  if (current === 'speaking') return;
  setChatAvatarState('listening');
}

function appendMessage(role, content, options) {
  options = options || {};
  if (!chatMessagesEl) return;

  var msgEl = document.createElement('div');
  msgEl.className =
    'sw-demo-chat-message ' +
    (role === 'assistant'
      ? 'sw-demo-chat-message--assistant'
      : 'sw-demo-chat-message--user');

  var bubble = document.createElement('div');
  bubble.className = 'sw-demo-chat-bubble';

  if (options.html) {
    bubble.innerHTML = options.html;
  } else {
    bubble.textContent = content;
  }

  msgEl.appendChild(bubble);
  chatMessagesEl.appendChild(msgEl);

  // Avatar reactions
if (role === 'assistant') {
  indicateEmmaSpeaking();
} else if (role === 'user') {
  indicateEmmaListening();
}

  // Notify text collision system
  try {
    window.dispatchEvent(
      new CustomEvent('sw:chatMessage', {
        detail: { role: role, content: content }
      })
    );
  } catch (e) {
    // ignore
  }

  chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
}

function formatIndustryLabel(key) {
  var labels = {
    dental: 'dental practice',
    hvac: 'HVAC company',
    law: 'law firm',
    legal: 'law firm',
    plumbing: 'plumbing business',
    medspa: 'medical spa',
    pest: 'pest control company',
  };
  return labels[key] || 'your business';
}

function getScenarioLabelForIndustry(key) {
  switch (key) {
    case 'dental':
      return 'Dental · New patient / whitening inquiry';
    case 'hvac':
      return 'HVAC · Emergency repair & same-day booking';
    case 'law':
    case 'legal':
      return 'Law · Injury / DUI intake & qualification';
    case 'plumbing':
      return 'Plumbing · Burst pipe & after-hours emergency';
    case 'medspa':
      return 'MedSpa · Botox / aesthetics consultation';
    case 'pest':
      return 'Pest Control · Inspection & urgent treatment';
    default:
      return 'Service inquiry · New or returning lead';
  }
}

function updateConsoleScenario() {
  if (!consoleScenarioTextEl) return;
  consoleScenarioTextEl.textContent = getScenarioLabelForIndustry(selectedIndustry);
}

// Internal industry setter
function setIndustryInternal(key) {
  if (!key) return;
  
  var previousIndustry = selectedIndustry;
  selectedIndustry = key;

  if (sectionEl) {
    sectionEl.setAttribute('data-industry', selectedIndustry);
  }

  // Highlight chip
  if (chatIndustryButtons && chatIndustryButtons.length) {
    chatIndustryButtons.forEach(function(btn) {
      var bKey = btn.getAttribute('data-sw-industry');
      btn.classList.toggle('sw-demo-chip--active', bKey === selectedIndustry);
    });
  }

  startTypewriterForIndustry(selectedIndustry);
  updateConsoleScenario();

  // Apply to particle system
  applyIndustryToParticles(selectedIndustry);

  // Reset voice readiness if industry changed mid-chat
  // This allows the voice CTA to appear again after user explores different industries
  if (previousIndustry && previousIndustry !== selectedIndustry) {
    readyForVoiceTriggered = false;
    chatTurnCount = 0;
    
    // Hide the voice CTA banner if visible (user is exploring)
    if (chatStartDemoBannerEl && currentState === DEMO_STATES.READY_FOR_VOICE) {
      setHidden(chatStartDemoBannerEl, true);
      setState(DEMO_STATES.CHAT_ACTIVE);
    }
    
    debugLog('demo', 'Industry changed, reset voice trigger state');
  }
}

// Public entrypoint when user clicks
function onIndustrySelected(key) {
  if (!key) return;

  setIndustryInternal(key);

  // Broadcast to global IndustryBus
  try {
    if (
      window.ShockwaveIndustryBus &&
      typeof window.ShockwaveIndustryBus.setIndustry === 'function'
    ) {
      var canon = canonFromLiveKey(key);
      if (canon) {
        window.ShockwaveIndustryBus.setIndustry(canon, 'demo');
      }
    }
  } catch (e) {
    debugLog('demo', 'IndustryBus setIndustry failed', e);
  }

  trackEvent('live_demo_industry_selected', {
    industry: selectedIndustry,
    source: 'chat_widget',
  });

  setState(DEMO_STATES.CHAT_ACTIVE);

  // NEW: treat industry selection as a real user message + send to webhook
  var userText = "I'm in a " + formatIndustryLabel(selectedIndustry) + ".";
  handleUserMessage(userText);
}

function handleUserMessage(text) {
  appendMessage('user', text);
  chatHistory.push({ role: 'user', content: text });

  trackEvent('live_demo_chat_user_message', {
    length: text.length,
    industry: selectedIndustry,
  });

  sendChatToEmma(text);
}

function sendChatToEmma(latestUserMessage) {
  if (!DemoFeatures.chatEnabled) {
    var fallback = getFallbackEmmaResponse(latestUserMessage);
    appendMessage('assistant', fallback);
    maybeMarkReadyForVoice();
    return;
  }

  var payload = {
    sessionId: chatSessionId,
    industry: selectedIndustry,
    history: chatHistory,
    latestUserMessage: latestUserMessage,
  };

  fetch(N8N_CHAT_WEBHOOK_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload),
  })
    .then(function(res) {
      if (!res.ok) throw new Error('Non-200 from n8n chat webhook');
      return res.json();
    })
    .then(function(data) {
      var reply =
        (data && data.reply) ||
        'Got it. Here\'s how this plays out for your business...';
      var roiEstimate =
        typeof data.roiEstimate === 'number' ? data.roiEstimate : null;

      appendMessage('assistant', reply);
      chatHistory.push({ role: 'assistant', content: reply });

      if (roiEstimate && roiEstimate > 0) {
        lastROIFromChat = roiEstimate;
        appendMessage(
          'assistant',
          'Based on what you shared, you\'re likely leaving roughly $' + 
          Math.round(roiEstimate).toLocaleString() + 
          '/month on the table. Shockwave Response AI typically recovers around 60% of that for ' + 
          formatIndustryLabel(selectedIndustry) + 's.'
        );
      }

      maybeMarkReadyForVoice();

      trackEvent('live_demo_chat_emma_reply', {
        industry: selectedIndustry,
        has_roi_estimate: !!roiEstimate,
      });
    })
    .catch(function(err) {
      debugLog('demo', 'Emma chat error', err);
      appendMessage(
        'assistant',
        'My live brain is a bit overloaded right now. Roughly speaking, Shockwave Response AI usually recovers 10-30% extra revenue from missed calls and slow follow-up. We can show you on a quick voice preview.'
      );
      maybeMarkReadyForVoice();
    });
}

/*************************************************
 * READY FOR VOICE DETECTION
 *************************************************/

var chatTurnCount = 0;
var readyForVoiceTriggered = false;

function maybeMarkReadyForVoice() {
  // Only trigger once per session
  if (readyForVoiceTriggered) return;
  
  // Count user messages
  var userMessages = chatHistory.filter(function(m) {
    return m.role === 'user';
  });
  
  chatTurnCount = userMessages.length;
  
  // After 2+ user messages, show the voice CTA
  if (chatTurnCount >= 2 && currentState === DEMO_STATES.CHAT_ACTIVE) {
    setState(DEMO_STATES.READY_FOR_VOICE);
    readyForVoiceTriggered = true;
    
    trackEvent('live_demo_ready_for_voice', {
      turns: chatTurnCount,
      industry: selectedIndustry
    });
  }
}



function getFallbackEmmaResponse(latestUserMessage) {
  var lower = (latestUserMessage || '').toLowerCase();
  if (lower.indexOf('miss') !== -1 || lower.indexOf('no-show') !== -1 || lower.indexOf('no show') !== -1) {
    return 'That\'s exactly where AI shines. For ' + formatIndustryLabel(selectedIndustry) + 
      's, Shockwave typically recovers 10-30% of revenue that would\'ve been lost to missed calls and no-shows. If you give me a sense of your daily inquiries, I can estimate your monthly recovery.';
  }
  if (lower.indexOf('price') !== -1 || lower.indexOf('cost') !== -1 || lower.indexOf('pricing') !== -1) {
    return 'Pricing depends on volume and complexity, but most ' + formatIndustryLabel(selectedIndustry) + 
      's see at least a 5x ROI on Response AI alone. Tell me roughly how many new inquiries you get per day and your average ticket value - I\'ll estimate your recovered revenue.';
  }
  return 'Got it. Think of me as a 24/7 front desk that never forgets to follow up, never misses a call, and always logs the details. Tell me how many new inquiries you get per day and what an average job is worth - I\'ll estimate your monthly recovered revenue.';
}

/*************************************************
 * MODAL LOGIC
 *************************************************/

function openModal() {
  if (!modalOverlayEl) return;
  setHidden(modalOverlayEl, false);

  // Ensure fields + asterisks match the currently selected radio
  syncContactMethodUI();

  if (modalFirstNameInputEl) modalFirstNameInputEl.focus();
}

function closeModal() {
  if (!modalOverlayEl) return;
  setHidden(modalOverlayEl, true);
}

function syncContactMethodUI() {
  if (!modalPhoneGroupEl || !modalEmailGroupEl) return;

  var checked = sectionEl.querySelector('input[name="swContactMethod"]:checked');
  var method = checked ? checked.value : 'phone';

  // Show/hide groups
  setHidden(modalPhoneGroupEl, method !== 'phone');
  setHidden(modalEmailGroupEl, method !== 'email');

  // Required attributes
  if (modalPhoneInputEl) {
    modalPhoneInputEl.required = (method === 'phone');
    method === 'phone'
      ? modalPhoneInputEl.setAttribute('required', 'required')
      : modalPhoneInputEl.removeAttribute('required');
  }

  if (modalEmailInputEl) {
    modalEmailInputEl.required = (method === 'email');
    method === 'email'
      ? modalEmailInputEl.setAttribute('required', 'required')
      : modalEmailInputEl.removeAttribute('required');
  }

  // Toggle visible asterisks
  sectionEl.querySelectorAll('[data-required-for]').forEach(function(star) {
    var forMethod = star.getAttribute('data-required-for');
    setHidden(star, forMethod !== method);
  });

  // Button copy
  var submitBtn = qs(sectionEl, '[data-sw-demo-modal-submit]');
  if (submitBtn) {
    submitBtn.textContent = (method === 'phone')
      ? 'Start My Live Call →'
      : 'Email Me My AI Plan →';
  }
}

function onContactMethodChange() {
  syncContactMethodUI();
}


function validateModalForm() {
  if (!modalFormEl) return false;

  var contactMethodEl = null;
  for (var i = 0; i < modalContactMethodRadios.length; i++) {
    if (modalContactMethodRadios[i].checked) {
      contactMethodEl = modalContactMethodRadios[i];
      break;
    }
  }
  var method = contactMethodEl ? contactMethodEl.value : 'phone';
  var firstName =
    (modalFirstNameInputEl && modalFirstNameInputEl.value.trim()) || '';
  var phone = modalPhoneInputEl ? modalPhoneInputEl.value.trim() : '';
  var email = modalEmailInputEl ? modalEmailInputEl.value.trim() : '';

  if (!firstName) return false;
  if (method === 'phone' && !phone) return false;
  if (method === 'email' && !email) return false;

  return { method: method, firstName: firstName, phone: phone, email: email };
}

function buildEmailPlanSummary(firstName, industryKey, roiCtx) {
  var name = firstName || 'there';
  var ind = formatIndustryLabel(industryKey);
  var lines = [];

  lines.push('Hi ' + name + ',');
  lines.push('');
  lines.push('Here\'s your Shockwave AI snapshot for your ' + ind + ':');
  lines.push('');

  if (roiCtx && roiCtx.monthlyAtRisk && roiCtx.monthlyRecovered) {
    lines.push(
      '- Est. at-risk revenue: ~$' + Math.round(roiCtx.monthlyAtRisk).toLocaleString() + '/mo'
    );
    lines.push(
      '- Recoverable with AI: ~$' + Math.round(roiCtx.monthlyRecovered).toLocaleString() + '/mo'
    );
  }

  if (roiCtx && roiCtx.tier) {
    lines.push('');
    lines.push('Recommended tier: ' + roiCtx.tier.name + ' (' + roiCtx.tier.priceLabel + ')');
    if (roiCtx.tier.tagline) {
      lines.push('Why: ' + roiCtx.tier.tagline);
    }
  }

  lines.push('');
  lines.push('Next step: quick 15-20 minute call to confirm assumptions and map your first AI workflow.');
  lines.push('');
  lines.push('Talk soon,');
  lines.push('Emma - Shockwave AI Agent');

  return lines.join('\n');
}

function onModalSubmit(e) {
  e.preventDefault();

  var valid = validateModalForm();
  if (!valid) {
    alert('Please fill in the required fields so Emma knows how to reach you.');
    return;
  }

  var method = valid.method;
  var firstName = valid.firstName;
  var phone = valid.phone;
  var email = valid.email;

  var roiCtx = getConsoleROIContext();
  var emailPlanSummary = buildEmailPlanSummary(firstName, selectedIndustry, roiCtx);

  var payload = {
    type: 'startVoiceDemo',
    contactMethod: method,
    firstName: firstName,
    phone: method === 'phone' ? phone : null,
    email: method === 'email' ? email : null,
    industry: selectedIndustry,
    roiEstimate: lastROIFromChat || null,
    chatSummary: summarizeChatForBackend(),
    sessionId: chatSessionId,
    timestamp: new Date().toISOString(),
    voiceContext: {
      source: roiCtx.source,
      monthlyAtRisk: roiCtx.monthlyAtRisk || null,
      monthlyRecovered: roiCtx.monthlyRecovered || null,
      recoveryRate: roiCtx.recoveryRate || null,
      roiPercent: roiCtx.roiPercent || null,
      tier: roiCtx.tier
        ? {
            id: roiCtx.tier.id,
            key: roiCtx.tier.key,
            name: roiCtx.tier.name,
            priceLabel: roiCtx.tier.priceLabel,
            tagline: roiCtx.tier.tagline || null,
          }
        : null,
    },
    emailPlan: {
      summary: emailPlanSummary,
      industryLabel: formatIndustryLabel(selectedIndustry),
    },
  };

  trackEvent('live_demo_voice_form_submitted', {
    method: method,
    industry: selectedIndustry,
    has_roi: !!lastROIFromChat,
  });

  closeModal();

  // EMAIL PATH
  if (method === 'email') {
    appendMessage(
      'assistant',
      'Perfect, ' + firstName + '. I\'ll put together a short AI breakdown and ROI snapshot for your ' + 
      formatIndustryLabel(selectedIndustry) + ' and email it to ' + email + '. Check your inbox in a few minutes.'
    );

    trackEvent('live_demo_email_plan_requested', {
      industry: selectedIndustry,
      email: email,
      has_roi: !!lastROIFromChat,
    });

    if (!DemoFeatures.voiceStartEnabled) {
      return;
    }

    fetch(N8N_VAPI_WEBHOOK_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    }).catch(function(err) {
      debugLog('demo', 'demo-voice/email-plan webhook error', err);
    });

    return;
  }

  // PHONE PATH
  setState(DEMO_STATES.VOICE_CONNECTING);

  if (!DemoFeatures.voiceStartEnabled) {
    simulateCallLifecycle();
    return;
  }

  fetch(N8N_VAPI_WEBHOOK_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload),
  })
    .then(function(res) {
      if (!res.ok) throw new Error('Non-200 from demo-voice webhook');
      return res.json().catch(function() { return {}; });
    })
    .then(function(data) {
      voiceCallId = data.callId || null;

      trackEvent('live_demo_voice_call_started', {
        industry: selectedIndustry,
        contactMethod: method,
        callId: voiceCallId,
      });

      simulateCallLifecycle();
    })
    .catch(function(err) {
      debugLog('demo', 'demo-voice webhook error', err);
      setState(DEMO_STATES.VOICE_ERROR);
    });
}

function summarizeChatForBackend() {
  if (!chatHistory || !chatHistory.length) return null;
  var lastFew = chatHistory.slice(-6).map(function(m) { return m.role + ': ' + m.content; });
  return lastFew.join('\n');
}

/*************************************************
 * CONSOLE / VOICE DEMO LOGIC
 *************************************************/

function enterConsole() {
  if (!consoleEl) return;
  setHidden(consoleEl, false);
  updateConsoleSteps('connect');
  setConsoleStatus('Preparing your AI agent...');
  resetConsoleDecisions();
}

function startVoiceBackground() {
  if (voiceBgInstance && typeof voiceBgInstance.startConversation === 'function') {
    try {
      voiceBgInstance.startConversation(voiceCallId || null);
    } catch (e) {
      debugLog('demo', 'startConversation failed', e);
    }
  }
}

function stopVoiceBackground() {
  if (voiceBgInstance && typeof voiceBgInstance.stopConversation === 'function') {
    try {
      voiceBgInstance.stopConversation();
    } catch (e) {
      debugLog('demo', 'stopConversation failed', e);
    }
  }
}

function setConsoleStatus(text) {
  if (!consoleStatusTextEl) return;
  consoleStatusTextEl.textContent = text;
}

function updateConsoleSteps(stepKey) {
  if (!consoleStepsEls || !consoleStepsEls.length) return;

  consoleStepsEls.forEach(function(el) {
    var step = el.getAttribute('data-step');
    el.classList.toggle('sw-step--active', step === stepKey);
    el.classList.toggle(
      'sw-step--done',
      stepKey && step !== stepKey && isStepBefore(step, stepKey)
    );
  });
}

function isStepBefore(step, current) {
  var order = ['connect', 'call', 'live', 'summary'];
  var sIdx = order.indexOf(step);
  var cIdx = order.indexOf(current);
  return sIdx !== -1 && cIdx !== -1 && sIdx < cIdx;
}

function resetConsoleDecisions() {
  if (!consoleDecisionsEl) return;
  var items = qsa(consoleDecisionsEl, '.sw-console-decision');
  items.forEach(function(item) {
    item.setAttribute('data-status', 'pending');
    var icon = qs(item, '.sw-console-decision-icon');
    if (icon) icon.textContent = '○';
  });
}

function simulateCallLifecycle() {
  updateConsoleSteps('connect');
  setConsoleStatus('Preparing your AI agent...');

  setTimeout(function() {
    updateConsoleSteps('call');
    setConsoleStatus('Calling your number now. Emma will greet you and ask how she can help.');
  }, 1500);

  setTimeout(function() {
    setState(DEMO_STATES.VOICE_LIVE);
  }, 4000);

  var durationTarget = 45 + Math.floor(Math.random() * 16);
  setTimeout(function() {
    if (currentState === DEMO_STATES.VOICE_LIVE) {
      setState(DEMO_STATES.VOICE_SUMMARY);
    }
  }, durationTarget * 1000);
}

function startLiveCallTimer() {
  if (!consoleTimerEl) return;
  liveCallSeconds = 0;
  consoleTimerEl.textContent = '0:00';

  if (liveCallTimerId) clearInterval(liveCallTimerId);

  liveCallTimerId = setInterval(function() {
    liveCallSeconds += 1;
    var m = Math.floor(liveCallSeconds / 60);
    var s = liveCallSeconds % 60;
    consoleTimerEl.textContent = m + ':' + (s < 10 ? '0' : '') + s;
  }, 1000);
}

function stopLiveCallTimer() {
  if (liveCallTimerId) {
    clearInterval(liveCallTimerId);
    liveCallTimerId = null;
  }
}

function simulateAIDecisions() {
  if (!consoleDecisionsEl) return;
  var items = qsa(consoleDecisionsEl, '.sw-console-decision');
  if (!items.length) return;

  var delays = [400, 1100, 1800, 2600];
  items.forEach(function(item, idx) {
    setTimeout(function() {
      item.setAttribute('data-status', 'active');
      var icon = qs(item, '.sw-console-decision-icon');
      if (icon) icon.textContent = '●';
      setTimeout(function() {
        item.setAttribute('data-status', 'done');
        if (icon) icon.textContent = '✓';
      }, 350);
    }, delays[idx] || (idx + 1) * 800);
  });
}

function updateConsoleCTAsFromROI() {
  if (!consolePrimaryCtaEl && !consoleSecondaryCtaEl) return;

  var roiCtx = getConsoleROIContext();
  var tier = roiCtx.tier || null;
  var industryLabel = formatIndustryLabel(selectedIndustry);
  var recovered =
    roiCtx.monthlyRecovered && roiCtx.monthlyRecovered > 0
      ? '$' + Math.round(roiCtx.monthlyRecovered).toLocaleString() + '/mo'
      : null;
  var atRisk =
    roiCtx.monthlyAtRisk && roiCtx.monthlyAtRisk > 0
      ? '$' + Math.round(roiCtx.monthlyAtRisk).toLocaleString() + '/mo'
      : null;

  if (consolePrimaryCtaEl) {
    var copy;
    if (recovered) {
      copy = 'Lock in ~' + recovered + ' with ' + (tier ? tier.name : 'Shockwave AI') + ' →';
    } else {
      copy = 'Start ' + (tier ? tier.name : 'Shockwave AI') + ' for my ' + industryLabel + ' →';
    }
    consolePrimaryCtaEl.textContent = copy;
  }

  if (consoleSecondaryCtaEl) {
    var tierNameShort = tier ? tier.name : 'Response / Revenue AI';
    var copy2;
    if (atRisk) {
      copy2 = 'See how we turn ~' + atRisk + ' at risk into ROI →';
    } else {
      copy2 = 'See ' + tierNameShort + ' pricing & ROI →';
    }
    consoleSecondaryCtaEl.textContent = copy2;
  }
}

function fillConsoleTranscript() {
  if (!consoleTranscriptEl || !consoleTranscriptBodyEl) return;

  var linesSource =
    voiceTranscript && voiceTranscript.length ? voiceTranscript : null;

  if (!linesSource || !linesSource.length) {
    linesSource = chatHistory.slice(-4).map(function(m) {
      return {
        role: m.role === 'user' ? 'user' : 'assistant',
        text: m.content,
        ts: Date.now(),
      };
    });
  }

  if (!linesSource || !linesSource.length) {
    consoleTranscriptBodyEl.textContent =
      'Short transcript will appear here once you interact with the demo.';
    setHidden(consoleTranscriptEl, false);
    return;
  }

  var recent = linesSource.slice(-6);
  var htmlParts = recent.map(function(msg) {
    var cls =
      msg.role === 'user'
        ? 'sw-demo-console-transcript-line sw-demo-console-transcript-line--user'
        : 'sw-demo-console-transcript-line sw-demo-console-transcript-line--assistant';
    var speaker = msg.role === 'user' ? 'You' : 'Emma';
    return '<div class="' + cls + '">' +
      '<span class="sw-demo-console-transcript-speaker">' + speaker + ':</span>' +
      '<span class="sw-demo-console-transcript-text">' + escapeHtml(msg.text || '') + '</span>' +
      '</div>';
  });

  consoleTranscriptBodyEl.innerHTML = htmlParts.join('\n');
  setHidden(consoleTranscriptEl, false);
}

function fillConsoleSummary() {
  if (!consoleSummaryEl || !consoleSummaryBodyEl) return;
  setHidden(consoleSummaryEl, false);

  var approxDuration = liveCallSeconds || 45;
  var roiCtx = getConsoleROIContext();
  var monthlyAtRisk = roiCtx.monthlyAtRisk;
  var monthlyRecovered = roiCtx.monthlyRecovered;
  var recoveryRate = roiCtx.recoveryRate;
  var roiPercent = roiCtx.roiPercent;
  var tier = roiCtx.tier;

  var summaryLines = [];

  summaryLines.push(
    '<p>In about <strong>' + approxDuration + 's</strong>, the AI can:</p>'
  );
  summaryLines.push('<ul>');
  summaryLines.push(
    '<li>Greet the caller and understand why they\'re reaching out without a human picking up.</li>'
  );
  summaryLines.push(
    '<li>Capture the key details your team needs (service type, timing, value, contact info).</li>'
  );
  summaryLines.push(
    '<li>Push everything straight into your CRM, calendar, or follow-up workflows automatically.</li>'
  );
  summaryLines.push('</ul>');

  if (monthlyAtRisk && monthlyAtRisk > 0) {
    summaryLines.push(
      '<p>Based on your inputs, you\'re likely leaving around <strong>$' + 
      Math.round(monthlyAtRisk).toLocaleString() + 
      '/month</strong> on the table in missed or under-handled leads.</p>'
    );

    if (monthlyRecovered && monthlyRecovered > 0) {
      summaryLines.push(
        '<p>If Emma only recovers ~<strong>' + 
        Math.round((recoveryRate || 0) * 100) + 
        '%</strong> of that, that\'s roughly <strong>$' + 
        Math.round(monthlyRecovered).toLocaleString() + 
        '/month</strong> back into your ' + formatIndustryLabel(selectedIndustry) + 
        ' - without adding headcount.</p>'
      );
    }

    if (typeof roiPercent === 'number' && isFinite(roiPercent)) {
      var roundedROI = Math.round(roiPercent);
      if (roundedROI > 0) {
        summaryLines.push(
          '<p>That works out to an estimated <strong>' + roundedROI + 
          '% ROI</strong> on your Shockwave investment at current volumes.</p>'
        );
      }
    }
  } else {
    summaryLines.push(
      '<p>Typical ' + formatIndustryLabel(selectedIndustry) + 
      's recover thousands per month once AI handles missed calls, after-hours inquiries, and slow follow-up.</p>'
    );
  }

  if (tier) {
    summaryLines.push(
      '<div class="sw-demo-console-tier">' +
      '<div class="sw-demo-console-tier-label">Recommended starting tier</div>' +
      '<div class="sw-demo-console-tier-main">' +
      '<span class="sw-demo-console-tier-name">' + tier.name + '</span>' +
      '<span class="sw-demo-console-tier-price">' + tier.priceLabel + '</span>' +
      '</div>' +
      (tier.tagline ? '<div class="sw-demo-console-tier-tagline">' + tier.tagline + '</div>' : '') +
      '<div class="sw-demo-console-tier-note">' + tier.description + '</div>' +
      '</div>'
    );
  }

    // Advanced reasoning & upgrade paths
  var roiResult = null;
  try {
    if (Core.getROIData) {
      roiResult = Core.getROIData();
    }
  } catch (e) {
    debugLog('demo', 'Core.getROIData for reasoning failed', e);
  }

  if (
    roiResult &&
    typeof classifyScenario === 'function' &&
    typeof getUpgradePaths === 'function'
  ) {
    var scenarioClass = classifyScenario(roiResult);
    var suggestions = getUpgradePaths(roiResult) || [];

    var assumptions = [];
    if (typeof roiResult.leadsPerMonth === 'number') {
      assumptions.push(
        Math.round(roiResult.leadsPerMonth).toLocaleString() + ' leads/month'
      );
    }
    if (typeof roiResult.dealValue === 'number' && roiResult.dealValue > 0) {
      assumptions.push(
        '~$' + Math.round(roiResult.dealValue).toLocaleString() + ' per job'
      );
    }
    if (typeof roiResult.missedRatePct === 'number') {
      assumptions.push(Math.round(roiResult.missedRatePct) + '% missed/slow');
    }

    var scenarioLine = null;
    if (scenarioClass === 'profitable') {
      scenarioLine =
        'At these assumptions, Shockwave is projected to be <strong>profitable from month one</strong>.';
    } else if (scenarioClass === 'breakeven') {
      scenarioLine =
        'At these assumptions, you\'re roughly at <strong>break-even</strong>. Small improvements in volume or pricing push this into very strong ROI.';
    } else if (scenarioClass === 'unprofitable') {
      scenarioLine =
        'At these assumptions, this tier may be <strong>overkill</strong> until your volume or pricing grows. Emma will still catch revenue, but we\'d adjust the configuration or tier before going live.';
    }

    var reasoningLines = [];

    reasoningLines.push(
      '<div class="sw-demo-console-reasoning">' +
      '<div class="sw-demo-console-reasoning-title">How Emma evaluated this for you</div>' +
      '<ul class="sw-demo-console-reasoning-list">'
    );

    if (assumptions.length) {
      reasoningLines.push(
        '<li>Used your inputs (' + assumptions.join(' - ') +
        ') to estimate revenue at risk and recovered value.</li>'
      );
    } else {
      reasoningLines.push(
        '<li>Estimated your at-risk revenue based on your industry and the volumes you shared.</li>'
      );
    }

    if (scenarioLine) {
      reasoningLines.push('<li>' + scenarioLine + '</li>');
    }

    if (suggestions.length) {
      var top = suggestions.slice(0, 2);
      top.forEach(function(s) {
        if (s.type === 'leads') {
          reasoningLines.push(
            '<li>To make this a no-brainer, aim for around <strong>' + s.target.toLocaleString() + ' ' +
            s.unit + '</strong> at your current pricing/close rate.</li>'
          );
        } else if (s.type === 'dealValue') {
          reasoningLines.push(
            '<li>If your average job value increases to about <strong>$' + s.target.toLocaleString() +
            '</strong>, this configuration becomes highly profitable.</li>'
          );
        } else if (s.type === 'closeRate') {
          reasoningLines.push(
            '<li>At roughly <strong>' + s.target + '% close rate</strong>, this setup hits the ROI bar we usually target for ' +
            formatIndustryLabel(selectedIndustry) + 's.</li>'
          );
        }
      });
    }

    reasoningLines.push('</ul></div>');

    summaryLines.push(reasoningLines.join('\n'));

    // Visualize reasoning steps if present
    if (Array.isArray(roiResult.reasoningSteps) && roiResult.reasoningSteps.length) {
      try {
        renderDecisionTree(roiResult.reasoningSteps);
      } catch (e) {
        debugLog('demo', 'renderDecisionTree failed', e);
      }
    }

    // Keep session reasoningSteps in sync
    if (demoSession && Array.isArray(roiResult.reasoningSteps)) {
      demoSession.reasoningSteps = roiResult.reasoningSteps;
    }
  } else if (roiResult && (SW_DEBUG.demo || SW_DEBUG.verbose)) {
    // Helpful debug log if reasoning helpers are missing
    debugLog(
      'demo',
      'ROI reasoning helpers not available; skipping scenario classification/upgrade paths',
      {
        hasClassifyScenario: typeof classifyScenario === 'function',
        hasGetUpgradePaths: typeof getUpgradePaths === 'function'
      }
    );
  }

  consoleSummaryBodyEl.innerHTML = summaryLines.join('\n');
  updateConsoleCTAsFromROI();

  trackEvent('live_demo_voice_summary_shown', {
    industry: selectedIndustry,
    duration: approxDuration,
    monthly_at_risk: monthlyAtRisk || null,
    monthly_recovered: monthlyRecovered || null,
    tier_id: tier ? tier.id : null,
    roi_source: roiCtx.source,
  });
}

/*************************************************
 * HERO ROI CHIP
 *************************************************/

function updateHeroROIChip() {
  var chip = qs(sectionEl, '[data-sw-live-roi-chip]');
  var valueEl = qs(sectionEl, '[data-sw-live-roi-chip-value]');
  if (!chip || !valueEl) return;

  try {
    var roiData = Core.getROIData ? Core.getROIData() : null;
    if (!roiData || typeof roiData.revenueAtRiskAnnual !== 'number') return;

    var monthlyAtRisk = roiData.revenueAtRiskAnnual / 12;
    if (!monthlyAtRisk || !isFinite(monthlyAtRisk)) return;

    valueEl.textContent =
      '$' + Math.round(monthlyAtRisk).toLocaleString() + '/mo at risk';
    setHidden(chip, false);
  } catch (e) {
    debugLog('demo', 'updateHeroROIChip failed', e);
  }
}

/*************************************************
 * VOICE OVERLAY HELPERS
 *************************************************/

function openVoiceOverlay() {
  if (!voiceOverlayEl) return;
  setHidden(voiceOverlayEl, false);
  startVoiceWaveform();
  renderVoiceOverlayTranscript();
}

function closeVoiceOverlay() {
  if (!voiceOverlayEl) return;
  setHidden(voiceOverlayEl, true);
  stopVoiceWaveform();
}

function setVoiceOverlayStatus(text, state) {
  if (voiceStatusTextEl) {
    voiceStatusTextEl.textContent = text;
  }
  voiceWaveState = state || 'idle';
}

function startVoiceWaveform() {
  if (!voiceWaveCanvas) return;
  voiceWaveCtx = voiceWaveCanvas.getContext('2d');

  if (voiceWaveAnimId) cancelAnimationFrame(voiceWaveAnimId);

  var barCount = 40;

  function render() {
    var ctx = voiceWaveCtx;
    if (!ctx) return;
    var w = voiceWaveCanvas.width;
    var h = voiceWaveCanvas.height;

    ctx.clearRect(0, 0, w, h);

    var time = Date.now() * 0.001;
    var barWidth = w / barCount;
    var centerY = h / 2;

    for (var i = 0; i < barCount; i++) {
      var barHeight = 4;

      if (voiceWaveState === 'ai') {
        barHeight = 15 + Math.sin(i * 0.3 + time * 2.2) * 24;
        ctx.fillStyle = '#D12E1F';
      } else if (voiceWaveState === 'connecting') {
        barHeight = 8 + Math.sin(i * 0.6 + time * 3) * 10;
        ctx.fillStyle = '#F97316';
      } else {
        barHeight = 4 + Math.sin(i * 0.5 + time) * 2;
        ctx.fillStyle = 'rgba(148, 163, 184, 0.5)';
      }

      var x = i * barWidth + barWidth * 0.2;
      var y = centerY - barHeight / 2;
      ctx.fillRect(x, y, barWidth * 0.6, barHeight);
    }

    voiceWaveAnimId = requestAnimationFrame(render);
  }

  voiceWaveAnimId = requestAnimationFrame(render);
}

function stopVoiceWaveform() {
  if (voiceWaveAnimId) cancelAnimationFrame(voiceWaveAnimId);
  voiceWaveAnimId = null;
}

function renderVoiceOverlayTranscript() {
  var container = qs(sectionEl, '[data-sw-voice-overlay-transcript]');
  if (!container) return;

  var lines = voiceTranscript && voiceTranscript.length ? voiceTranscript : null;
  if (!lines || !lines.length) {
    lines = chatHistory.slice(-4).map(function(m) {
      return {
        role: m.role === 'user' ? 'user' : 'assistant',
        text: m.content,
      };
    });
  }

  if (!lines || !lines.length) {
    container.textContent = 'Transcript will appear here once you interact with the demo.';
    return;
  }

  var recent = lines.slice(-8);
  var html = recent
    .map(function(msg) {
      var speaker = msg.role === 'user' ? 'You' : 'Emma';
      return '<div class="sw-demo-console-transcript-line">' +
        '<span class="sw-demo-console-transcript-speaker">' + speaker + ':</span>' +
        '<span class="sw-demo-console-transcript-text">' + escapeHtml(msg.text || '') + '</span>' +
        '</div>';
    })
    .join('\n');

  container.innerHTML = html;
}

/*************************************************
 * TRANSCRIPT EVENT HANDLING
 *************************************************/

function onVoiceTranscriptEvent(e) {
  var detail = (e && e.detail) || {};
  if (!detail || !detail.text) return;

  var role = detail.role === 'user' ? 'user' : 'assistant';

  voiceTranscript.push({
    role: role,
    text: String(detail.text),
    ts: detail.timestamp || Date.now(),
  });

  renderVoiceOverlayTranscript();
}

/*************************************************
 * DEMO COMPLETE RECAP CARD
 *************************************************/

function renderDemoCompleteCard() {
  if (!completeCardEl) return;

  var roiCtx = getConsoleROIContext();
  var monthlyAtRisk = roiCtx.monthlyAtRisk;
  var monthlyRecovered = roiCtx.monthlyRecovered;
  var roiPercent = roiCtx.roiPercent;
  var tier = roiCtx.tier;

  if (completeIndustryEl) {
    completeIndustryEl.textContent = formatIndustryLabel(selectedIndustry);
  }

  if (completeAtRiskEl && monthlyAtRisk) {
    completeAtRiskEl.textContent = '$' + Math.round(monthlyAtRisk).toLocaleString();
  }

  if (completeRecoveredEl && monthlyRecovered) {
    completeRecoveredEl.textContent = '$' + Math.round(monthlyRecovered).toLocaleString();
  }

  if (completeRoiEl) {
    if (typeof roiPercent === 'number' && isFinite(roiPercent)) {
      completeRoiEl.textContent = Math.round(roiPercent) + '%';
    } else {
      completeRoiEl.textContent = '–';
    }
  }

  if (tier) {
    if (completeTierNameEl) completeTierNameEl.textContent = tier.name;
    if (completeTierPriceEl) completeTierPriceEl.textContent = tier.priceLabel;
    if (completeTierTaglineEl && tier.tagline) {
      completeTierTaglineEl.textContent = tier.tagline;
    }
  }

  setHidden(completeCardEl, false);

  try {
    saveDemoForReplay();
  } catch (e) {
    debugLog('demo', 'saveDemoForReplay failed silently', e);
  }
}

/*************************************************
 * DECISION TREE RENDERER
 *************************************************/

function renderDecisionTree(steps) {
  currentReasoningTree = steps || [];
  var container = document.getElementById('sw-decision-tree');
  if (!container || !currentReasoningTree.length) return;
  
  if (typeof d3 === 'undefined') {
    debugLog('demo', 'D3 not loaded; skipping decision tree render');
    return;
  }

  container.innerHTML = '';

  var width = container.clientWidth || 320;
  var dx = 18;
  var dy = 160;

  var root = d3
    .stratify()
    .id(function(d) { return d.id; })
    .parentId(function(d) { return d.parentId; })(currentReasoningTree);

  var treeLayout = d3.tree().nodeSize([dx, dy]);
  treeLayout(root);

  var svg = d3
    .select(container)
    .append('svg')
    .attr('viewBox', [-dy / 2, -dx, width, dx * (root.height + 3)])
    .style('max-width', '100%')
    .style('height', 'auto');

  var g = svg
    .append('g')
    .attr('font-family', 'system-ui')
    .attr('font-size', 11);

  g.append('g')
    .attr('fill', 'none')
    .attr('stroke', '#4b5563')
    .attr('stroke-opacity', 0.6)
    .attr('stroke-width', 1)
    .selectAll('path')
    .data(root.links())
    .join('path')
    .attr(
      'd',
      d3
        .linkHorizontal()
        .x(function(d) { return d.y; })
        .y(function(d) { return d.x; })
    );

  var node = g
    .append('g')
    .attr('stroke-linejoin', 'round')
    .attr('stroke-width', 1)
    .selectAll('g')
    .data(root.descendants())
    .join('g')
    .attr('transform', function(d) { return 'translate(' + d.y + ',' + d.x + ')'; });

  node
    .append('circle')
    .attr('r', 5)
    .attr('fill', function(d) { return d.depth === 0 ? '#d12e1f' : '#6b7280'; });

  node
    .append('text')
    .attr('dy', '0.32em')
    .attr('x', function(d) { return d.children ? -8 : 8; })
    .attr('text-anchor', function(d) { return d.children ? 'end' : 'start'; })
    .attr('fill', '#e5e7eb')
    .text(function(d) { return d.data.label; })
    .clone(true)
    .lower()
    .attr('stroke', 'rgba(15,23,42,0.9)')
    .attr('stroke-width', 3);
}

/*************************************************
 * SAVE DEMO FOR REPLAY
 *************************************************/

function saveDemoForReplay() {
  if (!DemoFeatures.saveDemoEnabled) return;

  var roiCtx = getConsoleROIContext();

  if (!demoSession) {
    demoSession = createInitialDemoSession();
  }

  demoSession.roiContext = demoSession.roiContext || roiCtx;
  demoSession.chatHistory = chatHistory.slice();
  demoSession.voiceTranscript =
    voiceTranscript && voiceTranscript.length
      ? voiceTranscript.slice()
      : demoSession.voiceTranscript || [];
  demoSession.industry = selectedIndustry;
  demoSession.id = chatSessionId;

  if (!demoSession.startedAt) {
    demoSession.startedAt = new Date().toISOString();
  }
  if (!demoSession.finishedAt) {
    demoSession.finishedAt = new Date().toISOString();
  }

  fetch(N8N_SAVE_DEMO_WEBHOOK_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(demoSession),
  })
    .then(function(r) { return r.json().catch(function() { return {}; }); })
    .then(function(data) {
      if (!data || !data.demoId) return;
      var shareUrl = window.location.origin + '/demo-replay?demoId=' + encodeURIComponent(data.demoId);
      window.latestDemoShareUrl = shareUrl;
      debugLog('demo', 'replay link prepared:', shareUrl);
    })
    .catch(function(err) {
      debugLog('demo', 'saveDemoForReplay error', err);
    });
}

/*************************************************
 * RESET & NAVIGATION
 *************************************************/

function resetDemoState() {
  // Reset chat UI back to initial prompt + industry chips
  if (chatMessagesEl) {
    chatMessagesEl.innerHTML = 
      '<div class="sw-demo-chat-message sw-demo-chat-message--assistant">' +
      '<div class="sw-demo-chat-bubble">' +
      'Hi! I\'m Emma, Shockwave\'s AI agent. ' +
      'I\'m the same brain we use for Response AI and Revenue AI clients to recover missed revenue ' +
      'from calls, texts, and web leads.<br><br>' +
      '<strong>First, which industry are you in?</strong> Then I\'ll ask a couple of quick questions ' +
      'about your call volume so I can estimate how much you\'re leaving on the table.' +
      '</div></div>' +
      '<div class="sw-demo-chat-industry-select" data-sw-demo-chat-industry-select>' +
      '<button type="button" class="sw-demo-chip" data-sw-industry="dental">🦷 Dental</button>' +
      '<button type="button" class="sw-demo-chip" data-sw-industry="hvac">🏠 HVAC</button>' +
      '<button type="button" class="sw-demo-chip" data-sw-industry="law">⚖️ Law (DUI/PI)</button>' +
      '<button type="button" class="sw-demo-chip" data-sw-industry="plumbing">🔧 Plumbing</button>' +
      '<button type="button" class="sw-demo-chip" data-sw-industry="medspa">💆 MedSpa</button>' +
      '<button type="button" class="sw-demo-chip" data-sw-industry="pest">🐜 Pest Control</button>' +
      '</div>';

    // Re-bind industry buttons
    chatIndustryButtons = qsa(sectionEl, '[data-sw-industry]');
    if (chatIndustryButtons && chatIndustryButtons.length) {
      chatIndustryButtons.forEach(function(btn) {
        btn.addEventListener('click', function() {
          var key = btn.getAttribute('data-sw-industry');
          onIndustrySelected(key);
        });
      });
    }
  }

  // Reset internal state
  chatHistory = [];
  lastROIFromChat = null;
  chatSessionId = generateSessionId();
  voiceTranscript = [];

  // Reset ready-for-voice state
  chatTurnCount = 0;
  readyForVoiceTriggered = false;

  // Reset industry back to default and update DOM/preset
  selectedIndustry = DEFAULT_INDUSTRY;
  if (sectionEl) {
    sectionEl.setAttribute('data-industry', selectedIndustry);
  }

  // Reset particles & apply default industry preset
  var ps = getParticleSystem();
  if (ps) {
    if (typeof ps.resetMorph === 'function') {
      ps.resetMorph(1000);
    } else if (window.particleMorpher && typeof window.particleMorpher.resetMorph === 'function') {
      window.particleMorpher.resetMorph(ps, 1000);
    }

    try {
      applyIndustryToParticles(selectedIndustry);
    } catch (e) {
      debugLog('demo', 'applyIndustryToParticles on reset failed', e);
    }
  }

  // Reset demo session
  demoSession = createInitialDemoSession();

  // Restart typewriter on generic suggestions until they pick an industry again
  startTypewriterForIndustry(null);

  // Hide console/recap and stop any voice/visual background
  if (consoleEl) setHidden(consoleEl, true);
  if (completeCardEl) setHidden(completeCardEl, true);
  stopVoiceBackground();
  stopLiveCallTimer();
  closeVoiceOverlay();

  if (chatStartDemoBannerEl) setHidden(chatStartDemoBannerEl, true);

  // Reset word indices for the (new) selected industry
  if (typeof window.resetWordIndex === 'function') {
    window.resetWordIndex(selectedIndustry);
  }

  // Return to chat-active state
  setState(DEMO_STATES.CHAT_ACTIVE);
}

function navigateToBooking() {
  var target =
    document.querySelector('#demo-booking, [data-booking-section]') || null;
  if (target && typeof target.scrollIntoView === 'function') {
    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }
}

function navigateToPricingOrROI() {
  var roi =
    document.querySelector('#roi-calculator, [data-roi-calculator]') || null;
  var pricing =
    document.querySelector('#pricing, [data-pricing-section]') || null;
  var target = roi || pricing;
  if (target && typeof target.scrollIntoView === 'function') {
    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }
}

/*************************************************
 * ENHANCEMENT LAYER - INITIALIZATION
 *************************************************/

/**
 * Initialize Enhanced Particle System
 * Integrates with existing live demo functionality
 */
function initEnhancedParticleSystem() {
  // Check if enhancement files are loaded
  var hasEnhancedSystem = typeof window.EnhancedParticleSystem !== 'undefined';
  var hasTextCollision = typeof window.TextCollisionManager !== 'undefined';
  var hasMorpher = typeof window.ParticleMorpher !== 'undefined';
  var hasEmma = typeof window.EmmaAvatar !== 'undefined';
  var hasPresets = typeof window.INDUSTRY_PRESETS !== 'undefined';
  
  debugLog('particles', 'Checking enhanced particle system dependencies...');
  debugLog('particles', 'EnhancedParticleSystem:', hasEnhancedSystem ? '✅' : '❌');
  debugLog('particles', 'TextCollisionManager:', hasTextCollision ? '✅' : '❌');
  debugLog('particles', 'ParticleMorpher:', hasMorpher ? '✅' : '❌');
  debugLog('particles', 'EmmaAvatar:', hasEmma ? '✅' : '❌');
  debugLog('particles', 'INDUSTRY_PRESETS:', hasPresets ? '✅' : '❌');
  
  if (!hasEnhancedSystem) {
    debugLog('particles', 'Enhanced particle system not loaded, using legacy system');
    return false;
  }

  // Prefer an existing instance if one has already been created
  if (window.enhancedParticleSystem instanceof window.EnhancedParticleSystem) {
    debugLog('particles', 'Reusing existing EnhancedParticleSystem instance');
    var container = document.querySelector('.live-demo-bg-wrap');
    if (container) {
      container.classList.add('v2-active');
      container.setAttribute('data-particles-ready', 'true');
    }
    if (!window.swParticleSystem) {
      window.swParticleSystem = window.enhancedParticleSystem;
    }
    return true;
  }

  if (
    window.swParticleSystem instanceof window.EnhancedParticleSystem &&
    !window.enhancedParticleSystem
  ) {
    debugLog('particles', 'Linking swParticleSystem → enhancedParticleSystem');
    window.enhancedParticleSystem = window.swParticleSystem;
    var container2 = document.querySelector('.live-demo-bg-wrap');
    if (container2) {
      container2.classList.add('v2-active');
      container2.setAttribute('data-particles-ready', 'true');
    }
    return true;
  }
  
  // Find container
  var container3 = document.querySelector('.live-demo-bg-wrap');
  if (!container3) {
    debugLog('particles', '.live-demo-bg-wrap not found, cannot initialize particles');
    return false;
  }
  
  // Check for existing legacy canvas and mark for replacement
  var legacyCanvas = container3.querySelector('canvas:not(.sw-particle-canvas-v2)');
  if (legacyCanvas) {
    debugLog('particles', 'Found legacy particle canvas, will be replaced');
  }
  
  // Mark container as v2 active
  container3.classList.add('v2-active');
  
  // Add loading indicator
  var loadingEl = document.createElement('div');
  loadingEl.className = 'sw-particles-loading';
  loadingEl.innerHTML = 
    '<div class="sw-particles-loading-spinner"></div>' +
    '<div class="sw-particles-loading-text">Initializing AI visualization...</div>';
  container3.appendChild(loadingEl);
  
  // Initialize enhanced system
  try {
    window.enhancedParticleSystem = new window.EnhancedParticleSystem(container3, {
      isMobile: window.innerWidth < 768,
      debug: SW_DEBUG.particles
    });
    
    // Also expose via swParticleSystem for convenience
    if (!window.swParticleSystem) {
      window.swParticleSystem = window.enhancedParticleSystem;
    }

    // Remove loading indicator
    setTimeout(function() {
      loadingEl.classList.add('hidden');
      setTimeout(function() { loadingEl.remove(); }, 500);
    }, 800);
    
    // Mark section as ready
    if (sectionEl) {
      sectionEl.setAttribute('data-particles-ready', 'true');
    }
    
    debugLog('particles', 'Enhanced particle system initialized');
    return true;
    
  } catch (err) {
    debugLog('particles', 'Enhanced particle system initialization failed:', err);
    loadingEl.remove();
    container3.classList.remove('v2-active');
    return false;
  }
}

/**
 * Wire up Emma speaking events to particle morphing
 */
function wireEmmaToMorphing() {
  if (!window.enhancedParticleSystem || !window.particleMorpher) return;
  
  // Keyword to shape mapping
  var morphKeywords = {
    'revenue': null,
    'money': null,
    'calls': null,
    'recovery': null,
    'impact': null,
    'roi': null,
    'profit': null,
    'growth': null,
    'dental': 'tooth',
    'tooth': 'tooth',
    'hvac': 'thermostat',
    'heating': 'thermostat',
    'cooling': 'thermostat',
    'legal': 'gavel',
    'law': 'gavel',
    'attorney': 'gavel',
    'plumbing': 'wrench',
    'pipe': 'wrench',
    'water': 'wrench',
    'spa': 'sparkle',
    'beauty': 'sparkle',
    'treatment': 'sparkle',
    'pest': 'shield',
    'bug': 'shield',
    'protect': 'shield'
  };
  
  // Debounce to prevent rapid morphing
  var lastMorphTime = 0;
  var morphCooldown = 3000;
  
  var handleEmmaSpeak = function(e) {
    var text = ((e.detail && e.detail.text) || '').toLowerCase();
    var now = Date.now();
    
    if (now - lastMorphTime < morphCooldown) return;
    
    // Check for keywords
    for (var keyword in morphKeywords) {
      if (text.indexOf(keyword) !== -1) {
        var shape = morphKeywords[keyword];
        var targetShape = shape || selectedIndustry || 'dental';
        
        window.enhancedParticleSystem.morphToShape(targetShape, 2000);
        lastMorphTime = now;
        
        debugLog('demo', 'Emma triggered morph:', targetShape, '(keyword:', keyword + ')');
        
        showMorphIndicator(targetShape);
        
        break;
      }
    }
  };
  
  window.addEventListener('emmaSpeak', handleEmmaSpeak);
  window.addEventListener('sw:emmaSpeak', handleEmmaSpeak);
  
  debugLog('demo', 'Emma speech wired to particle morphing');
}

/**
 * Wire demo state changes to particle effects
 */
function wireDemoStateToParticles() {
  if (!window.enhancedParticleSystem) return;
  
  // The setState function already handles particle effects
  // This is for any additional wiring needed
  
  debugLog('demo', 'Demo states wired to particle effects');
}

/**
 * Add click-to-spawn-rings functionality
 */
function enableClickRings() {
  if (!window.enhancedParticleSystem) return;
  
  var container = document.querySelector('.live-demo-bg-wrap');
  if (!container) return;
  
  // Already handled by handleBackgroundClick, but add visual indicator
  container.addEventListener('click', function(e) {
    if (isClickOnUI(e.target)) return;
    
    // Create visual ripple indicator
    var ripple = document.createElement('div');
    ripple.className = 'sw-ring-click-indicator';
    
    var rect = container.getBoundingClientRect();
    ripple.style.left = (e.clientX - rect.left - 20) + 'px';
    ripple.style.top = (e.clientY - rect.top - 20) + 'px';
    
    container.appendChild(ripple);
    
    // Trigger animation
    requestAnimationFrame(function() {
      ripple.classList.add('active');
    });
    
    // Remove after animation
    setTimeout(function() { ripple.remove(); }, 600);
  });
  
  debugLog('demo', 'Click-to-ring enabled');
}

/**
 * Setup performance monitoring (debug mode)
 */
function setupPerformanceMonitor() {
  if (!SW_DEBUG.particles) return;
  if (!window.enhancedParticleSystem) return;
  
  // Create monitor element
  performanceMonitorEl = document.createElement('div');
  performanceMonitorEl.className = 'sw-performance-monitor visible';
  performanceMonitorEl.innerHTML = 
    '<div>FPS: <span class="fps">--</span></div>' +
    '<div>Particles: <span class="particles">--</span></div>';
  document.body.appendChild(performanceMonitorEl);
  
  // Update every second
  setInterval(function() {
    if (!window.enhancedParticleSystem) return;
    
    var fps = typeof window.enhancedParticleSystem.getFPS === 'function' 
      ? window.enhancedParticleSystem.getFPS() 
      : '--';
    var fpsEl = performanceMonitorEl.querySelector('.fps');
    var particlesEl = performanceMonitorEl.querySelector('.particles');
    
    if (fpsEl) fpsEl.textContent = fps;
    if (particlesEl) particlesEl.textContent = window.enhancedParticleSystem.particleCount || '--';
    
    // Color code FPS
    if (fpsEl) {
      fpsEl.classList.remove('warning', 'critical');
      if (fps < 30) {
        fpsEl.classList.add('critical');
      } else if (fps < 50) {
        fpsEl.classList.add('warning');
      }
    }
  }, 1000);
  
  debugLog('demo', 'Performance monitor enabled');
}

/**
 * Handle reduced motion preference
 */
function handleReducedMotion() {
  try {
    var prefersReducedMotion = window.matchMedia && 
      window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    
    if (prefersReducedMotion) {
      debugLog('demo', 'Reduced motion preference detected');
      
      if (sectionEl) {
        sectionEl.classList.add('reduced-motion');
      }
      
      return true;
    }
  } catch (e) {
    // ignore
  }
  
  return false;
}

/**
 * Handle WebGL availability
 */
function checkWebGLSupport() {
  try {
    var canvas = document.createElement('canvas');
    var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    
    if (!gl) {
      debugLog('demo', 'WebGL not supported');
      
      if (sectionEl) {
        sectionEl.classList.add('webgl-fallback');
      }
      
      return false;
    }
    
    return true;
  } catch (e) {
    debugLog('demo', 'WebGL check failed:', e);
    return false;
  }
}

/**
 * Main enhancement initialization
 */
function initEnhancements() {
  debugLog('demo', '═══════════════════════════════════════');
  debugLog('demo', '   SHOCKWAVE LIVE DEMO ENHANCEMENTS');
  debugLog('demo', '═══════════════════════════════════════');
  
  // Check reduced motion
  if (handleReducedMotion()) {
    debugLog('demo', 'Enhancements skipped (reduced motion)');
    return;
  }
  
  // Check WebGL
  if (!checkWebGLSupport()) {
    debugLog('demo', 'Enhancements skipped (no WebGL)');
    return;
  }
  
  // Wait for dependencies to load
  var checkDependencies = function() {
    if (typeof window.EnhancedParticleSystem !== 'undefined') {
      // Initialize enhanced system (or reuse existing one)
      var success = initEnhancedParticleSystem();
      
      if (success) {
        // Wire up integrations
        wireEmmaToMorphing();
        wireDemoStateToParticles();
        enableClickRings();
        setupPerformanceMonitor();
        
        debugLog('demo', 'All enhancements active');
        debugLog('demo', '═══════════════════════════════════════');
      }
    } else {
      // Check again in 200ms
      setTimeout(checkDependencies, 200);
    }
  };
  
  // Start checking for dependencies
  setTimeout(checkDependencies, 300);
}

/*************************************************
 * PUBLIC API
 *************************************************/

window.ShockwaveLiveDemo = window.ShockwaveLiveDemo || {};

window.ShockwaveLiveDemo.reset = function resetLiveDemo() {
  try {
    resetDemoState();
    return true;
  } catch (err) {
    debugLog('demo', 'reset failed', err);
    return false;
  }
};

window.ShockwaveLiveDemo.setIndustry = function setIndustryExternal(liveKey) {
  try {
    if (!liveKey) return false;

    var key = String(liveKey).toLowerCase().trim();
    if (key === 'legal') key = 'law';
    if (key === 'pestcontrol') key = 'pest';

    var allowed = ['dental', 'hvac', 'law', 'plumbing', 'medspa', 'pest'];
    if (allowed.indexOf(key) === -1) return false;

    setIndustryInternal(key);

    trackEvent('live_demo_external_industry_set', { industry: selectedIndustry });

    return true;
  } catch (err) {
    debugLog('demo', 'setIndustry failed', err);
    return false;
  }
};

window.ShockwaveLiveDemo.setState = function setStateExternal(newState) {
  var validStates = [];
  for (var k in DEMO_STATES) {
    validStates.push(DEMO_STATES[k]);
  }
  if (validStates.indexOf(newState) === -1) {
    debugLog('demo', 'setState - invalid state', newState);
    return false;
  }
  setState(newState);
  return true;
};

window.ShockwaveLiveDemo.morphToWord = function morphToWordExternal(word) {
  if (!word) return false;
  
  var ps = getParticleSystem();
  if (!ps) return false;
  
  if (window.particleMorpher && typeof window.particleMorpher.morphToWord === 'function') {
    window.particleMorpher.morphToWord(ps, word.toUpperCase(), 1500);
    return true;
  }
  
  return false;
};

window.ShockwaveLiveDemo.morphToShape = function morphToShapeExternal(shape) {
  if (!shape) return false;
  
  var ps = getParticleSystem();
  if (ps && typeof ps.morphToShape === 'function') {
    ps.morphToShape(shape, 2000);
    return true;
  }
  
  return false;
};

window.ShockwaveLiveDemo.triggerExplosion = function triggerExplosionExternal(x, y, z) {
  triggerExplosion(x || 0, y || 0, z || 0);
  return true;
};

window.ShockwaveLiveDemo.spawnRing = function spawnRingExternal(x, y, z) {
  var ps = getParticleSystem();
  if (ps && ps.ringSystem) {
    ps.ringSystem.createRing(x || 0, y || 0, z || 0);
    return true;
  }
  return false;
};

window.ShockwaveLiveDemo.setVoiceAmplitude = function setVoiceAmplitudeExternal(amp) {
  var ps = getParticleSystem();
  if (ps && typeof ps.setVoiceAmplitude === 'function') {
    ps.setVoiceAmplitude(amp);
    return true;
  }
  return false;
};

window.ShockwaveLiveDemo.showEmma = function showEmmaExternal(visible) {
  var ps = getParticleSystem();
  if (ps && typeof ps.setEmmaVisible === 'function') {
    ps.setEmmaVisible(visible !== false);
    return true;
  }
  return false;
};

window.ShockwaveLiveDemo.initEnhancements = initEnhancements;

// Current state getters
Object.defineProperty(window.ShockwaveLiveDemo, 'currentIndustry', {
  get: function() { return selectedIndustry; }
});

Object.defineProperty(window.ShockwaveLiveDemo, 'currentState', {
  get: function() { return currentState; }
});

Object.defineProperty(window.ShockwaveLiveDemo, 'particleSystem', {
  get: function() { return getParticleSystem(); }
});

/*************************************************
 * DEBUG STATE LISTENER
 *************************************************/

if (!window.__SW_DEMO_STATE_LISTENER_ADDED__) {
  window.__SW_DEMO_STATE_LISTENER_ADDED__ = true;
  window.addEventListener('sw:demoStateChange', function(e) {
    try {
      if (!SW_DEBUG.demo && !SW_DEBUG.verbose) return;
      var d = e.detail || {};
      debugLog('demo', '[State Change]', d.state, '| industry:', d.industry, '| session:', d.sessionId);
    } catch (err) {
      // ignore
    }
  });
}

// Listen for enhanced particle system ready event
window.addEventListener('sw:enhancedParticleSystemReady', function() {
  debugLog('demo', 'Enhanced particle system module detected');
});


/*************************************************
 * CLEANUP FOR SPA NAVIGATION
 *************************************************/

/**
 * Full cleanup function for single-page app navigation
 * Call this before unmounting the live demo section
 */
function destroyLiveDemo() {
  debugLog('demo', 'Destroying live demo section...');
  
  // Stop all timers
  stopTypewriter();
  stopLiveCallTimer();
  
  // Stop voice systems
  if (voiceBgInstance) {
    try {
      if (typeof voiceBgInstance.stopConversation === 'function') {
        voiceBgInstance.stopConversation();
      }
      if (typeof voiceBgInstance.destroy === 'function') {
        voiceBgInstance.destroy();
      }
    } catch (e) {
      debugLog('demo', 'voiceBgInstance destroy failed', e);
    }
    voiceBgInstance = null;
  }

  // ---- Phase 5 teardown (do this BEFORE nuking the particle system) ----
  try {
    if (window.ringCoupling && typeof window.ringCoupling.destroy === 'function') {
      window.ringCoupling.destroy();
    }
  } catch (e) {
    debugLog('demo', 'ringCoupling destroy failed', e);
  }
  window.ringCoupling = null;

  try {
    if (window.metaballFusion && typeof window.metaballFusion.destroy === 'function') {
      window.metaballFusion.destroy();
    }
  } catch (e) {
    debugLog('demo', 'metaballFusion destroy failed', e);
  }
  window.metaballFusion = null;

  // Console helper + aliases
  window.demoParticles = null;
  window.textCollision = null;

  // Destroy particle system (this also destroys HeroRings, Emma, etc.)
  var ps = getParticleSystem();
  if (ps && typeof ps.destroy === 'function') {
    try {
      ps.destroy();
    } catch (e) {
      debugLog('demo', 'ParticleSystem destroy failed', e);
    }
  }
  
  // Clear global references
  if (window.enhancedParticleSystem) {
    window.enhancedParticleSystem = null;
  }
  if (window.swParticleSystem) {
    window.swParticleSystem = null;
  }
  if (window.textCollisionManager) {
    try {
      if (typeof window.textCollisionManager.destroy === 'function') {
        window.textCollisionManager.destroy();
      }
    } catch (e) {
      debugLog('demo', 'textCollisionManager destroy failed', e);
    }
    window.textCollisionManager = null;
  }
  if (window.particleMorpher) {
    window.particleMorpher = null;
  }
  
  // Remove event listeners
  window.removeEventListener('sw:voiceTranscript', onVoiceTranscriptEvent);
  
  // Cancel any pending animation frames
  if (parallaxRAF) {
    cancelAnimationFrame(parallaxRAF);
    parallaxRAF = null;
  }
  
  // Reset state
  currentState = DEMO_STATES.IDLE;
  chatHistory = [];
  voiceTranscript = [];
  demoSession = null;
  
  debugLog('demo', 'Live demo section destroyed');
}

// Expose cleanup on public API
window.ShockwaveLiveDemo.destroy = destroyLiveDemo;

// Auto-cleanup on page unload (for traditional navigation)
window.addEventListener('beforeunload', function() {
  try {
    destroyLiveDemo();
  } catch (e) {
    // Ignore errors during unload
  }
});

// Listen for SPA navigation events (if using a router)
window.addEventListener('sw:navigateAway', destroyLiveDemo);
document.addEventListener('turbo:before-visit', destroyLiveDemo); // Turbo
document.addEventListener('astro:before-swap', destroyLiveDemo); // Astro

/*************************************************
 * PHASE 5: PARTICLE SYSTEM INTEGRATION LAYER
 * Ring-Particle Coupling, Text Collision, Metaball Fusion, Demo Controls
 *************************************************/

// ============================================
// RING–HERO-RING COUPLING (Phase 5 v2)
// Particles interact with the 3 Hero Rings, flowing through
// ring 1 → ring 2 → ring 3 like a space specimen.
// ============================================

var RingParticleCoupling = (function() {
  'use strict';

  function RingParticleCoupling(particleSystem) {
    this.particleSystem = particleSystem || getParticleSystem();
    this.heroRings =
      (this.particleSystem && this.particleSystem.heroRings) ||
      window.demoHeroRings ||
      null;

    this.config = {
      specimenFraction: 0.18,     // % of particles treated as the “specimen”
      cycleSeconds: 9,            // full loop through all 3 rings
      maxInfluenceRadius: 40,     // how far from a ring center it still pulls
      centerPull: 0.06,           // pull toward origin (keeps specimen cohesive)
      ringPull: 0.18              // pull toward active ring
    };

    this.startTime = performance.now();
    this.specimenIndices = [];
    this._ringLocalCenters = [];

    // Temp vectors reused every frame
    this._tmpWorld = new THREE.Vector3();
    this._tmpLocal = new THREE.Vector3();
    this._origin = new THREE.Vector3(0, 0, 0);

    this._pickSpecimenIndices();

    debugLog('demo', 'RingParticleCoupling (hero) initialized', {
      hasHeroRings: !!this.heroRings
    });
  }

  // Choose a stable subset of particles to act as the "specimen"
  RingParticleCoupling.prototype._pickSpecimenIndices = function() {
    var ps = this.particleSystem || getParticleSystem();
    if (!ps || !ps.particleGeometry || !ps.particleGeometry.attributes.offset) return;

    var positions = ps.particleGeometry.attributes.offset;
    var count = positions.count;
    var targetCount = Math.max(1, Math.floor(count * this.config.specimenFraction));

    var used = Object.create(null);
    this.specimenIndices.length = 0;

    while (this.specimenIndices.length < targetCount) {
      var idx = Math.floor(Math.random() * count);
      if (!used[idx]) {
        used[idx] = true;
        this.specimenIndices.push(idx);
      }
    }
  };

  RingParticleCoupling.prototype._refreshHeroRings = function() {
    if (!this.heroRings) {
      var ps = this.particleSystem || getParticleSystem();
      this.heroRings =
        (ps && ps.heroRings) ||
        window.demoHeroRings ||
        null;
    }
  };

  // Main update – called every frame from extendedAnimationUpdate
  RingParticleCoupling.prototype.update = function(deltaTime) {
    this._refreshHeroRings();

    var ps = this.particleSystem || getParticleSystem();
    if (!ps || !ps.particleGeometry || !ps.particles) return;
    if (!this.heroRings || !this.heroRings.rings || !this.heroRings.rings.length) return;

    var positions = ps.particleGeometry.attributes.offset;
    if (!positions) return;

    var ringCount = this.heroRings.rings.length;
    if (ringCount === 0 || this.specimenIndices.length === 0) return;

    // Compute hero ring centers in PARTICLE LOCAL SPACE (so group rotation doesn't break it)
    this._ringLocalCenters.length = 0;
    for (var i = 0; i < ringCount; i++) {
      var ring = this.heroRings.rings[i];
      if (!ring) continue;

      // World position of ring center
      ring.getWorldPosition(this._tmpWorld);
      // Convert into the particle system's local space
      this._tmpLocal.copy(this._tmpWorld);
      ps.particles.worldToLocal(this._tmpLocal);
      this._ringLocalCenters.push(this._tmpLocal.clone());
    }

    if (this._ringLocalCenters.length === 0) return;

    // Determine which ring is currently "active" in the cycle
    var now = performance.now();
    var elapsedSec = (now - this.startTime) / 1000;
    var cycle = this.config.cycleSeconds;
    var phase = (elapsedSec % cycle) / cycle;       // 0..1 over full cycle
    var ringPhase = phase * ringCount;              // 0..ringCount
    var activeIndex = Math.floor(ringPhase) % ringCount;
    var localPhase = ringPhase - activeIndex;       // 0..1 within current ring segment

    // Smooth 0→1→0 weighting for the active ring
    var focus = Math.sin(localPhase * Math.PI);     // 0..1..0

    // Normalize forces to framerate
    var centerPull = this.config.centerPull * deltaTime * 60;
    var ringPull = this.config.ringPull * focus * deltaTime * 60;
    var maxRadius = this.config.maxInfluenceRadius;

    var center = this._origin;

    // Nudge specimen particles toward origin (cohesion) and active hero ring
    for (var s = 0; s < this.specimenIndices.length; s++) {
      var idx = this.specimenIndices[s];
      if (idx < 0 || idx >= positions.count) continue;

      var i3 = idx * 3;
      var px = positions.array[i3];
      var py = positions.array[i3 + 1];
      var pz = positions.array[i3 + 2];

      // 1) Gentle pull toward origin
      var dx0 = center.x - px;
      var dy0 = center.y - py;
      var dz0 = center.z - pz;
      px += dx0 * centerPull;
      py += dy0 * centerPull;
      pz += dz0 * centerPull;

      // 2) Stronger pull toward current hero ring center
      var ringCenter = this._ringLocalCenters[activeIndex];
      if (ringCenter) {
        var dx = ringCenter.x - px;
        var dy = ringCenter.y - py;
        var dz = ringCenter.z - pz;
        var dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1;

        // Falloff so only particles reasonably near are heavily influenced
        var falloff = Math.min(1, dist / maxRadius);
        var strength = ringPull * (1 - falloff); // strongest when near the ring

        px += (dx / dist) * strength * maxRadius;
        py += (dy / dist) * strength * maxRadius;
        pz += (dz / dist) * strength * maxRadius;
      }

      positions.array[i3]     = px;
      positions.array[i3 + 1] = py;
      positions.array[i3 + 2] = pz;
    }

    positions.needsUpdate = true;
  };

  // No-op portal modes kept for console helpers (demoParticles.portal())
  RingParticleCoupling.prototype.enablePortalMode = function() {};
  RingParticleCoupling.prototype.disablePortalMode = function() {};

  RingParticleCoupling.prototype.setPointer = function(x, y) {
    // Reserved for future tilt-based interactions if you want it.
  };

  RingParticleCoupling.prototype.destroy = function() {
    this.specimenIndices = [];
    this._ringLocalCenters = [];
    this.particleSystem = null;
    this.heroRings = null;
  };

  return RingParticleCoupling;
})();

// ============================================
// METABALL FUSION SYSTEM
// ============================================

/**
 * MetaballFusionSystem - Raymarched metaball shader visual
 * for the FUSED state, creating a liquid blob effect.
 */
var MetaballFusionSystem = (function() {
  'use strict';

  // Metaball fragment shader
  var METABALL_FRAG = '\n\
    precision highp float;\n\
    \n\
    uniform float uTime;\n\
    uniform vec3 uColor;\n\
    uniform float uFusionStrength;\n\
    uniform vec2 uResolution;\n\
    uniform vec3 uMetaballs[8];\n\
    uniform int uMetaballCount;\n\
    \n\
    // Smooth minimum for metaball fusion\n\
    float smoothMin(float d1, float d2, float k) {\n\
      float h = exp(-k * d1) + exp(-k * d2);\n\
      return -log(max(h, 0.0001)) / k;\n\
    }\n\
    \n\
    // Distance to sphere\n\
    float sdSphere(vec3 p, vec3 center, float radius) {\n\
      return length(p - center) - radius;\n\
    }\n\
    \n\
    // Scene distance function\n\
    float mapScene(vec3 p) {\n\
      float d = 1000.0;\n\
      for (int i = 0; i < 8; i++) {\n\
        if (i >= uMetaballCount) break;\n\
        float sphereDist = sdSphere(p, uMetaballs[i], 0.3);\n\
        d = smoothMin(d, sphereDist, uFusionStrength);\n\
      }\n\
      return d;\n\
    }\n\
    \n\
    // Calculate normal via gradient\n\
    vec3 calcNormal(vec3 p) {\n\
      float e = 0.001;\n\
      return normalize(vec3(\n\
        mapScene(p + vec3(e, 0, 0)) - mapScene(p - vec3(e, 0, 0)),\n\
        mapScene(p + vec3(0, e, 0)) - mapScene(p - vec3(0, e, 0)),\n\
        mapScene(p + vec3(0, 0, e)) - mapScene(p - vec3(0, 0, e))\n\
      ));\n\
    }\n\
    \n\
    void main() {\n\
      vec2 uv = (gl_FragCoord.xy - 0.5 * uResolution) / min(uResolution.x, uResolution.y);\n\
      \n\
      // Ray setup\n\
      vec3 ro = vec3(0.0, 0.0, 2.0);\n\
      vec3 rd = normalize(vec3(uv, -1.0));\n\
      \n\
      // Ray march\n\
      float t = 0.0;\n\
      float d;\n\
      vec3 p;\n\
      \n\
      for (int i = 0; i < 64; i++) {\n\
        p = ro + rd * t;\n\
        d = mapScene(p);\n\
        if (d < 0.001 || t > 10.0) break;\n\
        t += d * 0.5;\n\
      }\n\
      \n\
      vec4 color = vec4(0.0);\n\
      \n\
      if (d < 0.01) {\n\
        vec3 normal = calcNormal(p);\n\
        \n\
        // Fresnel\n\
        float fresnel = pow(1.0 - max(dot(normal, -rd), 0.0), 3.0);\n\
        \n\
        // Lighting\n\
        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n\
        float diff = max(dot(normal, lightDir), 0.0);\n\
        \n\
        // Shimmer\n\
        float shimmer = sin(uTime * 3.0 + p.x * 10.0 + p.y * 10.0) * 0.1 + 0.9;\n\
        \n\
        vec3 finalColor = uColor * (0.3 + diff * 0.5) + vec3(fresnel * 0.4) * shimmer;\n\
        float alpha = 0.7 + fresnel * 0.3;\n\
        \n\
        color = vec4(finalColor, alpha);\n\
      }\n\
      \n\
      gl_FragColor = color;\n\
    }\n\
  ';

  var METABALL_VERT = '\n\
    void main() {\n\
      gl_Position = vec4(position, 1.0);\n\
    }\n\
  ';

  function MetaballFusionSystem(renderer, config) {
    this.renderer = renderer;
    this.config = config || { metaballK: 7.0 };
    this.isActive = false;
    this.metaballMesh = null;
    this.scene = null;
    this.camera = null;
    
    this.metaballPositions = [
      { x: 0, y: 0, z: 0 },
      { x: 0.3, y: 0.2, z: 0 },
      { x: -0.3, y: 0.1, z: 0 },
      { x: 0.1, y: -0.3, z: 0 }
    ];
    
    this.init();
    debugLog('demo', 'MetaballFusionSystem initialized');
  }

  MetaballFusionSystem.prototype.init = function() {
    if (typeof THREE === 'undefined') {
      debugLog('demo', 'THREE not available for metaball system');
      return;
    }
    
    // Get renderer from particle system
    var ps = this.renderer || getParticleSystem();
    if (!ps || !ps.renderer) {
      debugLog('demo', 'No renderer for metaball system');
      return;
    }
    
    this.threeRenderer = ps.renderer;
    this.parentScene = ps.scene;
    this.parentCamera = ps.camera;
    
    // Create ortho camera for fullscreen quad
    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    this.scene = new THREE.Scene();
    
    // Fullscreen quad
    var geometry = new THREE.PlaneGeometry(2, 2);
    
    var uniforms = {
      uTime: { value: 0 },
      uColor: { value: new THREE.Color(0x7C3AED) },
      uFusionStrength: { value: this.config.metaballK },
      uResolution: { value: new THREE.Vector2(
        this.threeRenderer.domElement.width,
        this.threeRenderer.domElement.height
      )},
      uMetaballs: { value: this.getMetaballArray() },
      uMetaballCount: { value: 4 }
    };
    
    this.uniforms = uniforms;
    
    var material = new THREE.ShaderMaterial({
      uniforms: uniforms,
      vertexShader: METABALL_VERT,
      fragmentShader: METABALL_FRAG,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    
    this.metaballMesh = new THREE.Mesh(geometry, material);
    this.metaballMesh.visible = false;
    this.scene.add(this.metaballMesh);
  };

  MetaballFusionSystem.prototype.getMetaballArray = function() {
    var arr = [];
    for (var i = 0; i < 8; i++) {
      if (i < this.metaballPositions.length) {
        var pos = this.metaballPositions[i];
        arr.push(new THREE.Vector3(pos.x, pos.y, pos.z));
      } else {
        arr.push(new THREE.Vector3(1000, 1000, 1000)); // Far away
      }
    }
    return arr;
  };

  MetaballFusionSystem.prototype.update = function(deltaTime) {
    if (!this.isActive || !this.uniforms) return;
    
    this.uniforms.uTime.value += deltaTime;
    
    // Animate metaball positions
    var time = this.uniforms.uTime.value;
    this.metaballPositions[1].x = Math.sin(time * 0.5) * 0.4;
    this.metaballPositions[1].y = Math.cos(time * 0.7) * 0.3;
    this.metaballPositions[2].x = Math.cos(time * 0.6) * 0.35;
    this.metaballPositions[2].y = Math.sin(time * 0.4) * 0.25;
    this.metaballPositions[3].x = Math.sin(time * 0.8) * 0.3;
    this.metaballPositions[3].y = Math.cos(time * 0.5) * 0.35;
    
    this.uniforms.uMetaballs.value = this.getMetaballArray();
  };

  MetaballFusionSystem.prototype.enable = function() {
    if (!this.metaballMesh) return;
    
    this.isActive = true;
    this.metaballMesh.visible = true;
    
    // Hide particles
    var ps = getParticleSystem();
    if (ps && ps.particles) {
      ps.particles.visible = false;
    }
    
    debugLog('demo', 'Metaball fusion enabled');
  };

  MetaballFusionSystem.prototype.disable = function() {
    if (!this.metaballMesh) return;
    
    this.isActive = false;
    this.metaballMesh.visible = false;
    
    // Show particles
    var ps = getParticleSystem();
    if (ps && ps.particles) {
      ps.particles.visible = true;
    }
    
    debugLog('demo', 'Metaball fusion disabled');
  };

  MetaballFusionSystem.prototype.setColor = function(color) {
    if (this.uniforms && this.uniforms.uColor) {
      this.uniforms.uColor.value = color instanceof THREE.Color ? color : new THREE.Color(color);
    }
  };

  MetaballFusionSystem.prototype.render = function() {
    if (!this.isActive || !this.threeRenderer || !this.scene || !this.camera) return;
    
    // Render metaball layer
    this.threeRenderer.render(this.scene, this.camera);
  };

  MetaballFusionSystem.prototype.destroy = function() {
    if (this.metaballMesh) {
      this.scene.remove(this.metaballMesh);
      this.metaballMesh.geometry.dispose();
      this.metaballMesh.material.dispose();
      this.metaballMesh = null;
    }
    this.isActive = false;
  };

  return MetaballFusionSystem;
})();


// ============================================
// DEMO CONTROLS SYSTEM
// ============================================

/**
 * Setup console API for testing and demos
 */
function setupDemoControls() {
  var ps = getParticleSystem();
  var pi = window.particleIntelligence || window.particleSystem;
  
  window.demoParticles = {
    // ═══════════════════════════════════════════════════════════════════
    // SHAPE MORPHING - Basic Shapes
    // ═══════════════════════════════════════════════════════════════════
    ellipsoid: function() { return morph('ellipsoid'); },
    sphere: function() { return morph('sphere'); },
    torus: function() { return morph('torus'); },
    helix: function() { return morph('helix'); },
    dna: function() { return morph('dna'); },
    wave: function() { return morph('wave'); },
    vortex: function() { return morph('vortex'); },
    heart: function() { return morph('heart'); },
    infinity: function() { return morph('infinity'); },
    cube: function() { return morph('cube'); },
    pyramid: function() { return morph('pyramid'); },
    ring: function() { return morph('ring'); },
    blob: function() { return morph('blob'); },
    fusion: function() { return morph('fusion_core'); },
    
    // ═══════════════════════════════════════════════════════════════════
    // SHAPE MORPHING - Industry Shapes
    // ═══════════════════════════════════════════════════════════════════
    dental: function() { return morph('dental'); },
    tooth: function() { return morph('dental'); },
    smile: function() { return morph('smile'); },
    hvac: function() { return morph('hvac'); },
    snowflake: function() { return morph('hvac'); },
    flame: function() { return morph('flame'); },
    legal: function() { return morph('legal'); },
    scales: function() { return morph('legal'); },
    gavel: function() { return morph('gavel'); },
    plumbing: function() { return morph('plumbing'); },
    droplet: function() { return morph('plumbing'); },
    wrench: function() { return morph('wrench'); },
    medspa: function() { return morph('medspa'); },
    lotus: function() { return morph('medspa'); },
    face: function() { return morph('face'); },
    ant: function() { return morph('ant'); },
    bee: function() { return morph('bee'); },
    shield: function() { return morph('shield'); },
    pest: function() { return morph('pestcontrol'); },
    
    // Generic morph
    morph: function(shape) { return morph(shape); },
    
    // ═══════════════════════════════════════════════════════════════════
    // WORD MORPHING
    // ═══════════════════════════════════════════════════════════════════
        word: function(text) {
  text = String(text || '').toUpperCase();

  if (window.demoOrbitalFlow && typeof window.demoOrbitalFlow.morphWord === 'function') {
    window.demoOrbitalFlow.morphWord(text);
    console.log('[Demo] LEFT lane word:', text);
  } else {
    console.warn('[Demo] OrbitalFlow not available');
  }
},

icon: function(shape) {
  shape = String(shape || '').toLowerCase();

  if (window.demoOrbitalFlow && typeof window.demoOrbitalFlow.morphIcon === 'function') {
    window.demoOrbitalFlow.morphIcon(shape);
    console.log('[Demo] RIGHT lane icon:', shape);
  } else {
    console.warn('[Demo] OrbitalFlow not available');
  }
},

// Add new dual command
dual: function(word, icon) {
  word = word || 'GROW';
  icon = icon || 'dental';
  
  if (window.demoOrbitalFlow) {
    window.demoOrbitalFlow.morphWord(word);
    setTimeout(function() {
      window.demoOrbitalFlow.morphIcon(icon);
    }, 150);
    console.log('[Demo] Dual morph - LEFT:', word, 'RIGHT:', icon);
  } else {
    console.warn('[Demo] OrbitalFlow not available');
  }
},

// Add stats command
stats: function() {
  if (window.demoOrbitalFlow) {
    var stats = window.demoOrbitalFlow.getStats();
    console.log('[Demo] Left Lane:', stats.leftLane);
    console.log('[Demo] Right Lane:', stats.rightLane);
    return stats;
  }
  console.warn('[Demo] OrbitalFlow not available');
},
    
    // ═══════════════════════════════════════════════════════════════════
    // SEQUENCES & EFFECTS
    // ═══════════════════════════════════════════════════════════════════
    fusionSequence: function() {
      var sys = window.particleIntelligence;
      if (sys && typeof sys.runFusionSequence === 'function') {
        sys.runFusionSequence('manual');
        console.log('[Demo] Starting fusion sequence...');
      } else {
        console.warn('[Demo] ParticleIntelligence not available');
      }
    },
    
    explode: function(x, y) {
      x = typeof x === 'number' ? x : 0;
      y = typeof y === 'number' ? y : 0;
      triggerExplosion(x, y, 0);
      console.log('[Demo] Explosion at', x.toFixed(2), y.toFixed(2));
    },
    
    greeting: function() {
      var sys = window.particleIntelligence;
      if (sys && typeof sys.triggerGreeting === 'function') {
        sys.triggerGreeting();
        console.log('[Demo] Replaying greeting...');
      } else if (window.morphEngine && typeof window.morphEngine.playGreeting === 'function') {
        window.morphEngine.playGreeting(getParticleSystem());
        console.log('[Demo] Greeting via morphEngine...');
      }
    },
    
    // ═══════════════════════════════════════════════════════════════════
    // MOTION PRESETS
    // ═══════════════════════════════════════════════════════════════════
    solid: function() { return setMotion('solid'); },
    liquid: function() { return setMotion('liquid'); },
    locked: function() { return setMotion('locked'); },
    idle: function() { return setMotion('idle'); },
    
    // ═══════════════════════════════════════════════════════════════════
    // SPECIAL MODES
    // ═══════════════════════════════════════════════════════════════════
    portal: function() {
      if (window.ringCoupling) {
        window.ringCoupling.enablePortalMode();
      }
      console.log('[Demo] Portal mode enabled');
    },
    
    noPortal: function() {
      if (window.ringCoupling) {
        window.ringCoupling.disablePortalMode();
      }
      console.log('[Demo] Portal mode disabled');
    },
    
    metaball: function(enabled) {
      enabled = enabled !== false;
      if (window.metaballFusion) {
        if (enabled) {
          window.metaballFusion.enable();
        } else {
          window.metaballFusion.disable();
        }
      }
      console.log('[Demo] Metaball:', enabled ? 'enabled' : 'disabled');
    },
    
    // ═══════════════════════════════════════════════════════════════════
    // VOICE SIMULATION
    // ═══════════════════════════════════════════════════════════════════
    voice: function(amplitude) {
      amplitude = Math.max(0, Math.min(1, amplitude || 0));
      window.dispatchEvent(new CustomEvent('voiceAmplitude', {
        detail: { amplitude: amplitude }
      }));
      console.log('[Demo] Voice amplitude:', amplitude.toFixed(2));
    },
    
    speak: function(text) {
      window.dispatchEvent(new CustomEvent('emmaSpeak', {
        detail: { text: text || 'Hello' }
      }));
      console.log('[Demo] Emma speaking:', text);
    },
    
    callStart: function() {
      window.dispatchEvent(new CustomEvent('callStart'));
      console.log('[Demo] Call started');
    },
    
    callEnd: function() {
      window.dispatchEvent(new CustomEvent('callEnd'));
      console.log('[Demo] Call ended');
    },
    
    // ═══════════════════════════════════════════════════════════════════
    // DEBUG & INFO
    // ═══════════════════════════════════════════════════════════════════
    state: function() {
      var sys = window.particleIntelligence;
      var state = sys ? sys.getState() : 'unknown';
      console.log('[Demo] Current state:', state);
      return state;
    },
    
    debug: function() {
      var info = {};
      
      // From particle intelligence
      var pi = window.particleIntelligence;
      if (pi && typeof pi.getStats === 'function') {
        info = pi.getStats();
      }
      
      // From particle system
      var ps = getParticleSystem();
      if (ps) {
        info.particleCount = ps.particleCount || 'unknown';
        info.fps = ps.currentFPS || (ps.getFPS ? ps.getFPS() : 'unknown');
      }
      
      // From quality system
      if (window.adaptiveQuality) {
        var qStats = window.adaptiveQuality.getStats();
        info.quality = qStats.tier || qStats.quality;
        info.qualityFPS = qStats.fps;
      }
      
      console.table(info);
      return info;
    },
    
    quality: function(level) {
      if (level) {
        if (window.adaptiveQuality) {
          window.adaptiveQuality.forceTier(level, true);
          console.log('[Demo] Quality forced to:', level);
        }
      } else {
        if (window.adaptiveQuality) {
          var stats = window.adaptiveQuality.getStats();
          console.table(stats);
          return stats;
        }
      }
    },
    
    updateTextZones: function() {
      if (window.textCollisionManager) {
        window.textCollisionManager.detectTextElements();
        console.log('[Demo] Text collision zones updated:', window.textCollisionManager.zoneCount);
      }
    },
    
    // ═══════════════════════════════════════════════════════════════════
    // AVAILABLE SHAPES LIST
    // ═══════════════════════════════════════════════════════════════════
    shapes: [
      'ellipsoid', 'sphere', 'torus', 'helix', 'dna', 'wave', 'vortex',
      'heart', 'infinity', 'cube', 'pyramid', 'ring', 'blob', 'fusion_core',
      'dental', 'smile', 'hvac', 'flame', 'legal', 'gavel',
      'plumbing', 'wrench', 'medspa', 'face', 'ant', 'bee', 'shield', 'pestcontrol'
    ],
    
    // ═══════════════════════════════════════════════════════════════════
    // HELP
    // ═══════════════════════════════════════════════════════════════════
    help: function() {
      console.log('\n' +
'🌌 PARTICLE SYSTEM CONTROLS\n' +
'═══════════════════════════════════════════════════\n' +
'\n' +
'SHAPES:\n' +
'  demoParticles.dna()       - DNA double helix\n' +
'  demoParticles.heart()     - Heart shape\n' +
'  demoParticles.ant()       - Detailed ant\n' +
'  demoParticles.bee()       - Detailed bee\n' +
'  demoParticles.scales()    - Scales of justice\n' +
'  demoParticles.lotus()     - Lotus flower\n' +
'  demoParticles.shapes      - List all shapes\n' +
'\n' +
'WORDS:\n' +
'  demoParticles.word("HELLO") - Morph to word\n' +
'\n' +
'EFFECTS:\n' +
'  demoParticles.fusionSequence() - Full cinematic\n' +
'  demoParticles.explode()        - Center explosion\n' +
'  demoParticles.explode(0.5, -0.3) - Position explosion\n' +
'  demoParticles.greeting()       - Replay intro\n' +
'\n' +
'MOTION:\n' +
'  demoParticles.solid()  - Tight, rigid motion\n' +
'  demoParticles.liquid() - Fluid, wavy motion\n' +
'  demoParticles.locked() - Minimal motion\n' +
'  demoParticles.idle()   - Normal motion\n' +
'\n' +
'VOICE SIMULATION:\n' +
'  demoParticles.voice(0.8)    - Set amplitude 0-1\n' +
'  demoParticles.callStart()   - Simulate call start\n' +
'  demoParticles.callEnd()     - Simulate call end\n' +
'  demoParticles.speak("text") - Trigger speech event\n' +
'\n' +
'DEBUG:\n' +
'  demoParticles.debug()   - Show system info\n' +
'  demoParticles.state()   - Current state\n' +
'  demoParticles.quality() - Quality stats\n' +
'  demoParticles.quality("low") - Force quality level\n'
      );
    }
  };
  
    // Helper functions
  function morph(shape) {
    var sys = window.particleIntelligence || window.particleSystem;
    if (sys && typeof sys.morphToShape === 'function') {
      sys.morphToShape(shape, 1800);
      console.log('[Demo] Morphing to:', shape);
    } else if (window.morphEngine && typeof window.morphEngine.morphToShape === 'function') {
      window.morphEngine.morphToShape(getParticleSystem(), shape, { duration: 1800, fluid: true });
      console.log('[Demo] Morphing via morphEngine to:', shape);
    } else {
      console.warn('[Demo] No morph system available');
    }
  }
  
  function setMotion(mode) {
    var ps = getParticleSystem();
    if (ps && typeof ps.setMotionPreset === 'function') {
      ps.setMotionPreset(mode);
      console.log('[Demo] Motion preset:', mode);
    } else {
      console.warn('[Demo] setMotionPreset not available');
    }
  }
  
  console.log('🌌 demoParticles ready! Type demoParticles.help() for commands.');
}


// ============================================
// EXTENDED ANIMATION LOOP INTEGRATION
// ============================================

/**
 * Extended update function that integrates all Phase 5 systems
 * Called from the main animation loop
 */
function extendedAnimationUpdate(deltaTime) {
  deltaTime = deltaTime || 0.016;
  
  // Update ring coupling (particle physics)
  if (window.ringCoupling && typeof window.ringCoupling.update === 'function') {
    window.ringCoupling.update(deltaTime);
  }
  
  // Update text collision (repulsion)
  if (window.textCollision && typeof window.textCollision.update === 'function') {
    window.textCollision.update();
  }
  
  // Update metaball fusion (shader animation)
  if (window.metaballFusion && typeof window.metaballFusion.update === 'function') {
    window.metaballFusion.update(deltaTime);
  }
  
  // Render metaball if active
  if (window.metaballFusion && window.metaballFusion.isActive) {
    window.metaballFusion.render();
  }
}


// ============================================
// PHASE 5 INITIALIZATION
// ============================================

/**
 * Initialize all Phase 5 systems
 * Called after main particle system is ready
 */
function initPhase5Systems() {
  debugLog('demo', 'Initializing Phase 5 systems...');
  
  var ps = getParticleSystem();

  // ✅ GUARD: If OrbitalFlow is active, skip ringCoupling (they fight for particles)
  if (ps && ps.orbitalFlow) {
    debugLog('demo', 'Phase5: OrbitalFlow active → skipping ringCoupling init');
  } else {
    // Create RingParticleCoupling
    if (!window.ringCoupling) {
      window.ringCoupling = new RingParticleCoupling(ps);
    }
  }

  // Create MetaballFusionSystem
  if (!window.metaballFusion && typeof THREE !== 'undefined') {
    window.metaballFusion = new MetaballFusionSystem(ps, { metaballK: 7.0 });
  }
  
  // Initialize text collision if not already done
  if (window.textCollisionManager && !window.textCollisionManager.isInitialized) {
    var canvas = document.querySelector('#live-demo-canvas, .live-demo-canvas, .sw-particle-canvas');
    if (canvas) {
      window.textCollisionManager.init(canvas);
      window.textCollision = window.textCollisionManager;
    }
  } else if (window.textCollisionManager) {
    window.textCollision = window.textCollisionManager;
  }
  
  // Setup demo controls
  setupDemoControls();
  
  // Hook into animation loop
  hookAnimationLoop();
  
  // Handle ?demo=true URL parameter for voice simulation
  try {
    var urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has('demo') || urlParams.get('demo') === 'true') {
      startDemoMode();
    }
  } catch (e) {}
  
  debugLog('demo', 'Phase 5 systems initialized');
  
  // Dispatch ready event
  window.dispatchEvent(new CustomEvent('sw:phase5Ready', {
    detail: {
      ringCoupling: !!window.ringCoupling,
      metaballFusion: !!window.metaballFusion,
      textCollision: !!window.textCollision,
      demoControls: !!window.demoParticles
    }
  }));
}

/**
 * Hook extended update into existing animation loop
 */
// Safe no-op: keep for compatibility but don't re-wrap animate
function hookAnimationLoop() {
  debugLog('demo', 'hookAnimationLoop called (no-op)');
}


/**
 * Demo mode - simulates voice input for testing
 */
function startDemoMode() {
  debugLog('demo', 'Demo mode active - simulating voice input');
  
  var phase = 0;
  
  setInterval(function() {
    phase += 0.1;
    
    var base = 0.3;
    var variation = Math.sin(phase) * 0.2 + Math.sin(phase * 2.7) * 0.15;
    var random = (Math.random() - 0.5) * 0.1;
    var amplitude = Math.max(0, Math.min(1, base + variation + random));
    
    window.dispatchEvent(new CustomEvent('voiceAmplitude', {
      detail: { amplitude: amplitude }
    }));
  }, 100);
  
  // Periodically trigger speech events
  var speechPhrases = [
    'Hello, welcome to Shockwave',
    'How can I help you today',
    'Let me check that for you',
    'Our services are top rated',
    'Would you like to schedule an appointment'
  ];
  
  var phraseIndex = 0;
  setInterval(function() {
    window.dispatchEvent(new CustomEvent('emmaSpeak', {
      detail: { text: speechPhrases[phraseIndex] }
    }));
    phraseIndex = (phraseIndex + 1) % speechPhrases.length;
  }, 8000);
}


// ============================================
// AUTO-INIT ON PARTICLE SYSTEM READY
// ============================================

// Wait for particle system to be ready, then init Phase 5
window.addEventListener('sw:particleSystemReady', function() {
  debugLog('demo', 'Particle system ready, initializing Phase 5...');
  
  // Small delay to ensure everything is wired up
  setTimeout(initPhase5Systems, 200);
});

// Also try to init if particle system already exists
if (getParticleSystem()) {
  setTimeout(initPhase5Systems, 500);
}

// Fallback: Init after DOM load
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', function() {
    setTimeout(function() {
      if (getParticleSystem() && !window.ringCoupling) {
        initPhase5Systems();
      }
    }, 1000);
  });
}


// ============================================
// EXPORTS FOR WINDOW
// ============================================

window.RingParticleCoupling = RingParticleCoupling;
window.MetaballFusionSystem = MetaballFusionSystem;
window.initPhase5Systems = initPhase5Systems;
window.extendedAnimationUpdate = extendedAnimationUpdate;
window.setupDemoControls = setupDemoControls;

})();
</script>

<script>
/* Mobile-only (iOS Safari) keyboard-safe scroll for chat input */
(function () {
  'use strict';

  // Hard guard: only run on small screens (prevents desktop behavior entirely)
  if (!window.matchMedia || !window.matchMedia('(max-width: 768px)').matches) return;

  // iOS + Safari (exclude Chrome/Firefox/Edge on iOS)
  var ua = navigator.userAgent || '';
  var isIOS = /iP(hone|od|ad)/.test(ua) || (ua.includes('Mac') && 'ontouchend' in document);
  var isSafari = /Safari/.test(ua) && !/CriOS|FxiOS|OPiOS|EdgiOS/.test(ua);
  if (!isIOS || !isSafari) return;

  function attach(input) {
    if (!input || input.__swIOSFixAttached) return;
    input.__swIOSFixAttached = true;

    input.addEventListener('focus', function () {
      // Let the keyboard start animating in
      setTimeout(function () {
        try {
          // Try to center the input in view
          input.scrollIntoView({ behavior: 'smooth', block: 'center' });

          // Extra nudge for iOS Safari when sticky/viewport gets weird
          if (window.visualViewport) {
            // If keyboard shrinks visual viewport, re-scroll once more after it settles
            setTimeout(function () {
              input.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }, 250);
          }
        } catch (e) {}
      }, 250);
    }, { passive: true });
  }

  function findAndAttach() {
    var input = document.querySelector('.sw-demo-chat-input');
    if (input) attach(input);
    return !!input;
  }

  // Try now + on DOM ready (your demo injects HTML after DOMContentLoaded sometimes)
  if (!findAndAttach()) {
    document.addEventListener('DOMContentLoaded', function () {
      if (findAndAttach()) return;

      // If the demo builds later, observe until the input appears
      var obs = new MutationObserver(function () {
        if (findAndAttach()) obs.disconnect();
      });

      obs.observe(document.documentElement, { childList: true, subtree: true });

      // Safety timeout (don’t watch forever)
      setTimeout(function () { try { obs.disconnect(); } catch (e) {} }, 8000);
    });
  }
})();
</script>


<!-- ═══════════════════════════════════════════════════════════════════════════
     BLOCK 5: AUTO-INITIALIZATION (PARTICLE INTELLIGENCE SYSTEM)
     Wire everything together after DOM ready.
     ═══════════════════════════════════════════════════════════════════════════ -->
<script>
(function() {
  'use strict';

  // Prevent double-init
  if (window.__SW_PARTICLE_INIT_STARTED__) {
    console.log('[Shockwave] Particle init already started, skipping');
    return;
  }
  window.__SW_PARTICLE_INIT_STARTED__ = true;

  function initShockwaveParticles() {
  try {
    // Check if THREE.js failed
    if (window.__SW_THREE_FAILED__) {
      console.warn('[Shockwave] THREE.js not available; using CSS fallback');
      document.body.classList.add('sw-no-webgl');
      return;
    }
    
    // Check dependencies
    if (typeof THREE === 'undefined') {
      console.warn('[Shockwave] THREE.js not available; 3D effects disabled');
      return;
    }
    
    // Detect settings early
    var isMobile = (window.innerWidth || 1024) < 768;
    var industry = typeof window.detectIndustry === 'function' ? window.detectIndustry() : 'default';
    var particleCount = isMobile ? 900 : 1500;
    
    console.log('[Shockwave] Initializing with:', {
      particleCount: particleCount,
      industry: industry,
      isMobile: isMobile
    });
    
    // ═══════════════════════════════════════════════════════════════
    // STEP 1: Initialize MorphEngine with correct particle count
    // ═══════════════════════════════════════════════════════════════
    
    var morpher = null;
    
    if (typeof window.getMorphEngine === 'function') {
  // Use factory (preferred); disable GPU SPH for now to avoid WebGL2 'active' errors
  morpher = window.getMorphEngine({
    particleCount: particleCount,
    useGPU: false
  });
  console.log('[Shockwave] MorphEngine obtained via factory (GPU disabled)');
} else if (typeof window.MorphEngine === 'function') {
      // Direct instantiation fallback
      if (window.morphEngine && window.morphEngine.particleCount === particleCount) {
        morpher = window.morphEngine;
      } else {
        morpher = new window.MorphEngine({ particleCount: particleCount });
        window.morphEngine = morpher;
        window.particleMorpher = morpher;
      }
      console.log('[Shockwave] MorphEngine created directly');
    }
    
    // ═══════════════════════════════════════════════════════════════
    // STEP 2: Find container
    // ═══════════════════════════════════════════════════════════════
    
    var container = document.querySelector('#live-demo-canvas') ||
                   document.querySelector('.live-demo-bg-wrap') ||
                   document.querySelector('.live-demo') ||
                   document.querySelector('[data-live-demo-root]');
    
    if (!container) {
      console.warn('[Shockwave] No container found for particle system');
      return;
    }
    
    // ═══════════════════════════════════════════════════════════════
    // STEP 3: Create ParticleSystem (will use existing morpher)
    // ═══════════════════════════════════════════════════════════════
    
    if (typeof window.ParticleSystem === 'function') {
      // Check for existing instance
      if (window.particleSystem instanceof window.ParticleSystem) {
        console.log('[Shockwave] Reusing existing ParticleSystem instance');
      } else {
        window.particleSystem = new window.ParticleSystem(container, {
          particleCount: particleCount,
          industry: industry,
          isMobile: isMobile,
          ultraCalmClamp: false
        });
        console.log('[Shockwave] ParticleSystem created');
      }
    } else {
      console.warn('[Shockwave] ParticleSystem class not available');
    }

      // STEP 3.5: Global aliases (single source of truth)
if (window.particleSystem) {
  // Optional: if an older instance exists and supports destroy(), kill it to avoid double RAF loops
  if (window.enhancedParticleSystem && window.enhancedParticleSystem !== window.particleSystem) {
    try { window.enhancedParticleSystem.destroy && window.enhancedParticleSystem.destroy(); } catch (e) {}
  }
  if (window.swParticleSystem && window.swParticleSystem !== window.particleSystem) {
    try { window.swParticleSystem.destroy && window.swParticleSystem.destroy(); } catch (e) {}
  }

  // Canonical aliases
  window.swParticleSystem = window.particleSystem;
  window.enhancedParticleSystem = window.particleSystem; // keep older calls working
}

    
    // ═══════════════════════════════════════════════════════════════
    // STEP 4: Create ParticleIntelligenceSystem and link everything
    // ═══════════════════════════════════════════════════════════════
    
    if (typeof window.ParticleIntelligenceSystem === 'function') {
      // Check for existing instance
      if (window.particleIntelligence instanceof window.ParticleIntelligenceSystem) {
        console.log('[Shockwave] Reusing existing ParticleIntelligenceSystem');
        
        // Ensure it's linked to particle system
        if (window.particleSystem && !window.particleIntelligence.particleSystem) {
          window.particleIntelligence.setParticleSystem(window.particleSystem);
        }
      } else {
        window.particleIntelligence = new window.ParticleIntelligenceSystem({
  particleCount: particleCount,
  industry: industry,
  debug: window.SW_DEBUG === true
});

// Initialize using default selector ('#live-demo-canvas')
window.particleIntelligence.init('#particle-canvas').then(function(success) {
  if (success) {
    console.log('[Shockwave] ParticleIntelligenceSystem initialized');
  }
  
  // Link to particle system
  if (window.particleSystem) {
    window.particleIntelligence.setParticleSystem(window.particleSystem);
  }
});
      }
    }
    
    // ═══════════════════════════════════════════════════════════════
    // STEP 5: Verify and broadcast ready
    // ═══════════════════════════════════════════════════════════════
    
    var status = {
      morpher: !!window.morphEngine,
      morpherCount: window.morphEngine ? window.morphEngine.particleCount : 0,
      particleSystem: !!window.particleSystem,
      particleSystemCount: window.particleSystem ? window.particleSystem.particleCount : 0,
      intelligence: !!window.particleIntelligence,
      industry: industry
    };
    
    // Verify counts match
    if (status.morpherCount !== status.particleSystemCount && status.morpherCount > 0 && status.particleSystemCount > 0) {
      console.error('[Shockwave] ⚠️ PARTICLE COUNT MISMATCH:', status);
    } else {
      console.log('[Shockwave] ✅ All systems initialized:', status);
    }
    
    // Broadcast ready event
    window.dispatchEvent(new CustomEvent('sw:particleSystemReady', {
      detail: {
        intelligence: window.particleIntelligence,
        particleSystem: window.particleSystem,
        morpher: window.morphEngine,
        industry: industry,
        particleCount: particleCount
      }
    }));
    
  } catch (err) {
    console.error('[Shockwave] Error during particle init:', err);
    if (err.stack) console.error(err.stack);
  }
}

// Fallback initialization using just ParticleSystem
function initParticleSystemFallback() {
  try {
    var container = document.querySelector('.live-demo') ||
                   document.querySelector('#live-demo-canvas') ||
                   document.querySelector('[data-live-demo-root]');
    
    if (!container) {
      console.warn('[Shockwave] No container found for particle system');
      return;
    }
    
    var isMobile = (window.innerWidth || 1024) < 768;
    var industry = typeof window.detectIndustry === 'function' ? window.detectIndustry() : 'default';
    var particleCount = isMobile ? 900 : 1500;
    
    // Ensure morpher has correct count
    if (typeof window.getMorphEngine === 'function') {
  window.getMorphEngine({ particleCount: particleCount, useGPU: false });
}
    
    window.particleSystem = new window.ParticleSystem(container, {
      particleCount: particleCount,
      industry: industry,
      ultraCalmClamp: false
    });

    // aliases
window.swParticleSystem = window.particleSystem;
window.enhancedParticleSystem = window.particleSystem;
    
    console.log('[Shockwave] ✅ ParticleSystem fallback online');
    
    window.dispatchEvent(new CustomEvent('sw:particleSystemReady', {
      detail: { particleSystem: window.particleSystem }
    }));
    
  } catch (err) {
    console.error('[Shockwave] Fallback init failed:', err);
  }
}

// ═══════════════════════════════════════════════════════════════
// DEPENDENCY-AWARE INITIALIZATION
// ═══════════════════════════════════════════════════════════════

function waitForDependencies(callback, timeout) {
  timeout = timeout || 5000;
  var startTime = Date.now();
  
  var requiredDeps = {
    THREE: function() { return typeof THREE !== 'undefined'; },
    MorphEngine: function() { return typeof window.MorphEngine === 'function' || typeof window.getMorphEngine === 'function'; },
    ParticleSystem: function() { return typeof window.ParticleSystem === 'function'; }
  };
  
  var optionalDeps = {
    ParticleIntelligenceSystem: function() { return typeof window.ParticleIntelligenceSystem === 'function'; },
    AdaptiveQualitySystem: function() { return typeof window.AdaptiveQualitySystem === 'function'; }
  };
  
  function checkDeps() {
    var elapsed = Date.now() - startTime;
    var allRequired = true;
    var missing = [];
    
    for (var dep in requiredDeps) {
      if (!requiredDeps[dep]()) {
        allRequired = false;
        missing.push(dep);
      }
    }
    
    if (allRequired) {
      // Log optional deps status
      var optionalStatus = {};
      for (var opt in optionalDeps) {
        optionalStatus[opt] = optionalDeps[opt]();
      }
      console.log('[Shockwave] Dependencies ready. Optional:', optionalStatus);
      
      callback();
    } else if (elapsed < timeout) {
      setTimeout(checkDeps, 50);
    } else {
      console.warn('[Shockwave] Timeout waiting for dependencies:', missing);
      
      // Try fallback if ParticleSystem is available
      if (typeof window.ParticleSystem === 'function') {
        console.log('[Shockwave] Attempting fallback initialization...');
        initParticleSystemFallback();
      }
    }
  }
  
  checkDeps();
}

// Run on DOM ready with dependency checking
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', function() {
    waitForDependencies(initShockwaveParticles);
  });
} else {
  // Small delay to ensure all scripts have executed
  setTimeout(function() {
    waitForDependencies(initShockwaveParticles);
  }, 50);
}
})();
</script>
